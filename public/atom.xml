<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DécouVerte</title>
  
  <subtitle>生命不息 折腾不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yluo.name/"/>
  <updated>2020-01-16T06:22:34.561Z</updated>
  <id>http://yluo.name/</id>
  
  <author>
    <name>Yang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu下Qt Creator无法输入中文问题</title>
    <link href="http://yluo.name/2020/01/17/qt_im/"/>
    <id>http://yluo.name/2020/01/17/qt_im/</id>
    <published>2020-01-17T06:20:00.000Z</published>
    <updated>2020-01-16T06:22:34.561Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="1-确认安装fcitx-frontend-qt5"><a href="#1-确认安装fcitx-frontend-qt5" class="headerlink" title="1. 确认安装fcitx-frontend-qt5"></a>1. 确认安装fcitx-frontend-qt5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install fcitx-frontend-qt5</div></pre></td></tr></table></figure><h3 id="2-确认该路径下存在文件"><a href="#2-确认该路径下存在文件" class="headerlink" title="2. 确认该路径下存在文件"></a>2. 确认该路径下存在文件</h3><p>由于Sogou Linux输入法采用的是fcitx框架，因此，需要确认<code>libfcitxplatforminputcontextplugin.so</code>是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts</div><div class="line">ls | grep libfcitx</div></pre></td></tr></table></figure><h3 id="3-将此lib文件复制到Qt与Qt-Creator的对应路径下"><a href="#3-将此lib文件复制到Qt与Qt-Creator的对应路径下" class="headerlink" title="3. 将此lib文件复制到Qt与Qt Creator的对应路径下"></a>3. 将此lib文件复制到Qt与Qt Creator的对应路径下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/</div><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/5.12.2/gcc_64/plugins/platforminputcontexts/</div></pre></td></tr></table></figure><p>随后重启Qt Creator，便可以输入中文了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。&lt;/p&gt;
&lt;h2 id=&quot;解决步
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="qt" scheme="http://yluo.name/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu右上角状态指示栏顺序配置</title>
    <link href="http://yluo.name/2020/01/16/ubuntu_indicator/"/>
    <id>http://yluo.name/2020/01/16/ubuntu_indicator/</id>
    <published>2020-01-16T02:29:00.000Z</published>
    <updated>2020-01-16T03:17:33.458Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。</p><h1 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h1><p>在Ubuntu中存在一个表单，这个表单里固定了一部分indicator的顺序，这个文件保存在如下位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/share/indicator-application/ordering-override.keyfile</div></pre></td></tr></table></figure><p>若是针对个人用户的配置，可以将ordering-override.keyfile复制到用户目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /usr/share/indicator-application/ordering-override.keyfile ~/.local/share/indicators/application/</div></pre></td></tr></table></figure><p>随后利用<code>vim ~/.local/share/indicators/application/ordering-override.keyfile</code>打开<code>.keyfile</code>文件，可以看到，文件里的内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Ordering Index Overrides]</div><div class="line">nm-applet=1</div><div class="line">My_Weather_Indicator=2</div><div class="line">lang_indicator=3</div><div class="line">bluetooth_manager=4</div><div class="line">transmission=6</div></pre></td></tr></table></figure><p>数字越大则越靠近左边，而数字越小则越靠近右边。若想要indicator放置在最左边，则可以使数值为-1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">indicator_sysmonitor=-1</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。&lt;/p&gt;
&lt;h1 id=&quot;设置方法&quot;&gt;&lt;a href=&quot;#设置方法&quot; class=&quot;headerlink&quot; title=&quot;设置方法&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="OS" scheme="http://yluo.name/categories/OS/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="tips" scheme="http://yluo.name/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Git 未知索引格式错误</title>
    <link href="http://yluo.name/2019/09/29/Git_fatal/"/>
    <id>http://yluo.name/2019/09/29/Git_fatal/</id>
    <published>2019-09-29T03:00:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误说明"><a href="#错误说明" class="headerlink" title="错误说明"></a>错误说明</h1><p>运行<code>git status</code>时，提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal: Unknown index entry format xxxxx</div></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>进入仓库文件夹，输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm -f .git/index</div><div class="line">git reset</div></pre></td></tr></table></figure><p>大功告成，喜大普奔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误说明&quot;&gt;&lt;a href=&quot;#错误说明&quot; class=&quot;headerlink&quot; title=&quot;错误说明&quot;&gt;&lt;/a&gt;错误说明&lt;/h1&gt;&lt;p&gt;运行&lt;code&gt;git status&lt;/code&gt;时，提示&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="Git" scheme="http://yluo.name/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：自定义消息类型</title>
    <link href="http://yluo.name/2019/08/06/ros_message/"/>
    <id>http://yluo.name/2019/08/06/ros_message/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS消息文件"><a href="#ROS消息文件" class="headerlink" title="ROS消息文件"></a>ROS消息文件</h1><p>ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下，可以被用来生成不同语言的源代码。</p><h1 id="消息数据类型"><a href="#消息数据类型" class="headerlink" title="消息数据类型"></a>消息数据类型</h1><p>ROS中的消息可使用的基本数据类型如下：</p><ul><li>int8, int16, int32, int64 (plus uint*)</li><li>float32, float64</li><li>string</li><li>time, duration</li><li>可变长度的数组，例如int8[]，以及固定长度的数组，例如float32[10]</li></ul><p>ROS消息中还有一个特殊的数据类型：Header， 其含有时间戳和坐标系信息。通常在很多msg文件的第一行有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Header header</div></pre></td></tr></table></figure></p><p>个人理解（不一定准确），Header类型通常包含在频繁发送的消息中，这样订阅节点可以根据Header中的时间戳信息等做信息同步处理。</p><p>同时，msg文件中还可以包括其他消息文件类型，例如在下面xxx.msg文件中，使用了Header, string以及另外两个消息类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Header header</div><div class="line">string child_frame_id</div><div class="line">geometry_msgs/PoseWithCovariance pose</div><div class="line">geometry_msgs/TwistWithCovariance twist</div></pre></td></tr></table></figure></p><h1 id="使用消息"><a href="#使用消息" class="headerlink" title="使用消息"></a>使用消息</h1><p>为了使用消息，需要在package.xml中添加编译依赖和执行依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</div></pre></td></tr></table></figure></p><p>并且在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find_package(catkin REQUIRED COMPONENTS</div><div class="line">    ...</div><div class="line">    message_generation</div><div class="line">)</div></pre></td></tr></table></figure></p><p>同时，利用catkin_package函数设置运行依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catkin_package(</div><div class="line">    ...</div><div class="line">    CATKIN_DEPENDS message_runtime ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>并添加需要参与编译的msg文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">add_message_files(</div><div class="line">    FILES</div><div class="line">    xxx.msg</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>确保CMake知道在消息文件更改后重新编译msg文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">generate_messages(</div><div class="line">    DEPENDENCIES</div><div class="line">    std_msgs</div><div class="line">)</div></pre></td></tr></table></figure></p><p>随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rosmsg命令查看自定义的消息类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosmsg show xxx</div></pre></td></tr></table></figure></p><h1 id="消息相关命令"><a href="#消息相关命令" class="headerlink" title="消息相关命令"></a>消息相关命令</h1><ul><li>rosmsg show xxx: 查看消息xxx类型，可以不指定功能包名。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS消息文件&quot;&gt;&lt;a href=&quot;#ROS消息文件&quot; class=&quot;headerlink&quot; title=&quot;ROS消息文件&quot;&gt;&lt;/a&gt;ROS消息文件&lt;/h1&gt;&lt;p&gt;ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：自定义服务</title>
    <link href="http://yluo.name/2019/08/06/ros_service/"/>
    <id>http://yluo.name/2019/08/06/ros_service/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS中的服务"><a href="#ROS中的服务" class="headerlink" title="ROS中的服务"></a>ROS中的服务</h1><p>服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（Request），由服务端（Server）节点处理后反馈应答（Response）。</p><h1 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h1><p>ROS中的服务可以通过srv文件夹下的xxx.srv文件进行语言无关的接口定义。文件包括请求与应答两个数据域，使用“—-”进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int64 a</div><div class="line">int64 b</div><div class="line">---</div><div class="line">int64 sum</div></pre></td></tr></table></figure><h1 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h1><p>首先需要在package.xml文件表明对消息生成系统的依赖，即构建依赖项message_generation和运行依赖项message_runtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;build_depend&gt;rospy&lt;/build_depend&gt;</div><div class="line">&lt;run_depend&gt;rospy&lt;/run_depend&gt;</div><div class="line"></div><div class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;</div></pre></td></tr></table></figure><p>随后在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find_package(catkin REQUIRED COMPONENTS</div><div class="line">    ...</div><div class="line">    message_generation</div><div class="line">)</div></pre></td></tr></table></figure></p><p>同时，利用catkin_package函数设置运行依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catkin_package(</div><div class="line">    ...</div><div class="line">    CATKIN_DEPENDS message_runtime ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>并添加需要参与编译的srv文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">add_service_files(</div><div class="line">    FILES</div><div class="line">    xxx.srv</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>确保CMake知道在消息文件更改后重新编译msg文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">generate_messages(</div><div class="line">    DEPENDENCIES</div><div class="line">    std_msgs</div><div class="line">)</div></pre></td></tr></table></figure></p><p>随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rossrv命令检验服务的定义是否和我们想的一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rossrv show xxx</div></pre></td></tr></table></figure></p><p>还可以使用rossrv list来查看所有可用的服务，使用rossrv packages来查看所有提供了服务的包，使用rossrv package xxx来查看xxx功能包提供的服务。</p><p>注意，ROS中还有一个命令rosservice，这个命令是用来在ROS运行时和启动的服务进行交互的命令，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice call /spawn 8.0 8.0 0.0 &apos;turtle2&apos;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS中的服务&quot;&gt;&lt;a href=&quot;#ROS中的服务&quot; class=&quot;headerlink&quot; title=&quot;ROS中的服务&quot;&gt;&lt;/a&gt;ROS中的服务&lt;/h1&gt;&lt;p&gt;服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（R
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：ROS命名空间及重映射</title>
    <link href="http://yluo.name/2019/08/06/ros_namespace/"/>
    <id>http://yluo.name/2019/08/06/ros_namespace/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS的命名"><a href="#ROS的命名" class="headerlink" title="ROS的命名"></a>ROS的命名</h1><p>命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为camera，并且相机可以输出一个话题image，同时读取一个frame_rate的参数来控制发送图像的频率。一个有效的命名具备以下特点：</p><ul><li>首字符为字母（[a-z|A-Z]）、波浪线（～）或左斜杠（/）。（不可以为下划线_）</li><li>后续字符可以是字母或数字（[0-9|a-z|A-Z]）、下划线（_）或者左斜杠（/）</li></ul><p>当一个机器人上存在两个相机时，由于相机的功能几乎完全一样，我们没有必要为两个相机分别编写一个程序，同时，也不想让两个相机的话题都发布在image话题上，这样会导致两个相机的画面交替出现。更一般地，命名的冲突在机器人系统中非常容易发生，这是因为机器人上常常包含相同的硬件或软件来简化工作量，例如相同的左右机械臂、相同的相机以及相同的多个轮子。为了避免命名上的冲突，ROS中采用两种机制来处理这种情况：命名空间和重映射。</p><h1 id="命名空间-Namespace"><a href="#命名空间-Namespace" class="headerlink" title="命名空间 Namespace"></a>命名空间 Namespace</h1><p>命名空间是计算机科学中的一个基本概念。根据UNIX路径和网络URI的规范，ROS使用斜杠（/）来分隔命名空间。ROS可以在不同的命名空间中启动同一个节点来避免命名冲突。</p><p>例如，具有两个相机的机器人可以在不同的命名空间<code>left</code>和<code>right</code>中启动两个相机的节点，最终会有两路图像流，分别为<code>left/image</code>和<code>right/image</code>。</p><h1 id="重映射-Remap"><a href="#重映射-Remap" class="headerlink" title="重映射 Remap"></a>重映射 Remap</h1><p>命名空间避免了命名的冲突，以相机为例，左相机发布的图像流话题为<code>left/image</code>，而在ROS中存在另一个节点nodex，专门接收<code>image</code>话题，由于两个话题在不同的命名空间之下，因此无法接收到左相机的图像信息。为了解决这个问题，一种方法是在同一个命名空间下启动这个节点，即在<code>left</code>命名空间下启动节点nodex，于是节点变为<code>left/nodex</code>，此时接收的image话题也将变为<code>left/image</code>。但是在复杂的程序当中，有可能节点需要“深入”不止一个命名空间之中，十分不方便。因此ROS中还可以用重映射（remap）的方式来解决这个问题。</p><p>在ROS中，程序中任何一个用于命名的字符串都可以在运行时重映射。例如，ROS中的一个常用程序image_view将image主题实时渲染在窗口上。使用重映射，可以使image_view接收<code>left/image</code>或者<code>right/image</code>，而无需修改image_view的代码。</p><h1 id="命名空间和重映射的使用"><a href="#命名空间和重映射的使用" class="headerlink" title="命名空间和重映射的使用"></a>命名空间和重映射的使用</h1><h2 id="在命令行中使用"><a href="#在命令行中使用" class="headerlink" title="在命令行中使用"></a>在命令行中使用</h2><p>由于ROS的设计模式鼓励软件的重用，重命名在开发和部署ROS软件的时候非常普遍。为了简化操作，ROS在命令行启动节点时提供了标准语法来重命名。</p><ul><li><p>将<code>image</code>话题重映射到<code>right/image</code>可以利用重映射语法来完成：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package image_view image:=right/image</div></pre></td></tr></table></figure></li><li><p>把节点放置到命名空间中可以利用<code>__ns</code>命名空间重映射语法来完成：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package camera __ns:=right</div></pre></td></tr></table></figure></li><li><p>修改节点的名字可以利用<code>__name</code>重命名语法来完成：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package camera __name:=camera2</div></pre></td></tr></table></figure></li></ul><h2 id="在launch文件中使用"><a href="#在launch文件中使用" class="headerlink" title="在launch文件中使用"></a>在launch文件中使用</h2><ul><li><p>通过设置name参数来确定节点的名字：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;node name=&quot;turtlesim_node2&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot;/&gt;</div></pre></td></tr></table></figure></li><li><p>通过设置ns参数来确定默认命名空间：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;node name=&quot;turtlesim_node&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot; ns=&quot;sim1&quot; /&gt;</div></pre></td></tr></table></figure></li><li><p>通过remap标签设置重映射：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;remap from=&quot;image&quot; to=&quot;right/image&quot;/&gt;</div></pre></td></tr></table></figure></li></ul><h2 id="在ROS程序终端中使用"><a href="#在ROS程序终端中使用" class="headerlink" title="在ROS程序终端中使用"></a>在ROS程序终端中使用</h2><p>可以利用环境变量设置默认命名空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export ROS_NAMESPACE=default-namespace</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS的命名&quot;&gt;&lt;a href=&quot;#ROS的命名&quot; class=&quot;headerlink&quot; title=&quot;ROS的命名&quot;&gt;&lt;/a&gt;ROS的命名&lt;/h1&gt;&lt;p&gt;命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为cam
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：CMakeLists.txt文件</title>
    <link href="http://yluo.name/2019/08/06/ros_cmakelist/"/>
    <id>http://yluo.name/2019/08/06/ros_cmakelist/</id>
    <published>2019-08-06T06:17:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><p>ROS中使用的编译器catkin是对cmake的一种封装，因此编译规则使用的也是CMakeLists.txt文件，关于CMakeLists.txt文件的规则之前在博客中已经提及过，不再赘述。</p><h1 id="编译规则"><a href="#编译规则" class="headerlink" title="编译规则"></a>编译规则</h1><p>在ROS功能包中的CMakeLists文件主要包括以下配置项：</p><ul><li>project(PROJ_NAME): 项目名称，一般情况下使用catkin_create_pkg命令会自动生成；</li><li>find_package(catkin REQUIRED COMPONTS rospy roscpp …): 寻找相关的功能包；</li><li>include_directories(include ${catkin_INCLUDE_DIRES}): 设置头文件的相对路径，通常在功能包下将相关的头文件都放置在include文件夹下；</li><li>add_executable(node_name src/xxx.cpp): 设置需要编译的代码和生成的可执行文件；</li><li>target_link_libraries(node_name ${catkin_LIBRARIES}): 设置链接库；</li><li>add_dependencies(node_name ${PROJECT_NAME}_generate_messages_cpp): 设置依赖，一般情况下自定义了消息类型的话便需要添加依赖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CMakeLists-txt&quot;&gt;&lt;a href=&quot;#CMakeLists-txt&quot; class=&quot;headerlink&quot; title=&quot;CMakeLists.txt&quot;&gt;&lt;/a&gt;CMakeLists.txt&lt;/h1&gt;&lt;p&gt;ROS中使用的编译器catkin是对cmak
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：package清单文件</title>
    <link href="http://yluo.name/2019/08/06/ros_package_xml/"/>
    <id>http://yluo.name/2019/08/06/ros_package_xml/</id>
    <published>2019-08-06T06:00:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="package清单文件"><a href="#package清单文件" class="headerlink" title="package清单文件"></a>package清单文件</h1><p>每一个ROS的功能包都包含一个package.xml的功能包清单文件，用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p><h1 id="package-xml规则"><a href="#package-xml规则" class="headerlink" title="package.xml规则"></a>package.xml规则</h1><p>package.xml文件采用xml标记语言来编写，其中的主要信息包括一下几种：</p><ul><li>name: 功能包的名称；</li><li>version: 功能包的版本；</li><li>description: 功能包的描述；</li><li>maintainer: 功能包的维护者信息；</li><li>license: 许可信息，MIT，BSD，GPL等；</li></ul><p>除此之外，package.xml中还包含了功能包所需的各种依赖项，主要包括：</p><ul><li>buildtool_depend: 编译工具依赖项，通常为catkin；</li><li>build_depend: 功能包代码编译所需的依赖项，例如roscpp，rospy，geometry_msgs，message_generation等；</li><li>run_depend: 功能包运行过程中所需的依赖项，例如roscpp，rospy，std_msgs，message_runtime等；</li></ul><p>如果是元功能包，则还需包含一个引用标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;export&gt;</div><div class="line">   &lt;metapackage/&gt;</div><div class="line">&lt;/export&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;package清单文件&quot;&gt;&lt;a href=&quot;#package清单文件&quot; class=&quot;headerlink&quot; title=&quot;package清单文件&quot;&gt;&lt;/a&gt;package清单文件&lt;/h1&gt;&lt;p&gt;每一个ROS的功能包都包含一个package.xml的功能包清单文件
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：功能包package文件结构</title>
    <link href="http://yluo.name/2019/08/06/ros_package_struct/"/>
    <id>http://yluo.name/2019/08/06/ros_package_struct/</id>
    <published>2019-08-06T05:14:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS功能包package"><a href="#ROS功能包package" class="headerlink" title="ROS功能包package"></a>ROS功能包package</h1><p>在ROS下，所有的文件按照功能包（package）的形式进行组织，是ROS软件中的基本单元。其中包括ROS节点、库、配置文件等。</p><h1 id="package的典型文件结构"><a href="#package的典型文件结构" class="headerlink" title="package的典型文件结构"></a>package的典型文件结构</h1><p>ROS package的典型结构包含一下文件及文件夹：</p><ul><li>config（文件夹）：放置功能包中的配置文件，由用户创建，文件名可以不同。</li><li>include（文件夹）：放置功能包中需要用到的头文件。</li><li>scripts（文件夹）：放置可以直接运行的Python脚本。</li><li>src（文件夹）：放置需要编译的C++代码。</li><li>launch（文件夹）：放置功能包中的所有启动文件。</li><li>msg（文件夹）：放置功能包自定义的消息类型。</li><li>srv（文件夹）：放置功能包自定义的服务类型。</li><li>action（文件夹）：放置功能包自定义的动作指令。</li><li>CMakeLists.txt（文件）：编译器编译功能包的规则（cmake的规则文件）。</li><li>package.xml（文件）：功能包清单，这个文件可以显示包信息，并注明依赖项，之后可以利用rosdep来安装依赖。</li></ul><h1 id="元功能包meta-package"><a href="#元功能包meta-package" class="headerlink" title="元功能包meta package"></a>元功能包meta package</h1><p>元功能包是一种特殊的功能包，只包含一个package.xml元功能包清单文件，其主要功能是将多个功能包整合成一个逻辑上的独立功能包，类似于功能包集的概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS功能包package&quot;&gt;&lt;a href=&quot;#ROS功能包package&quot; class=&quot;headerlink&quot; title=&quot;ROS功能包package&quot;&gt;&lt;/a&gt;ROS功能包package&lt;/h1&gt;&lt;p&gt;在ROS下，所有的文件按照功能包（package）的
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu与Windows双系统时间设置问题</title>
    <link href="http://yluo.name/2019/08/01/ubuntu_windows_time/"/>
    <id>http://yluo.name/2019/08/01/ubuntu_windows_time/</id>
    <published>2019-08-01T07:38:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h1><p>现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常时间快8个小时，要么比正常时间慢8个小时。即使利用网络同步时间之后，当切换过系统之后还是会出现时间差的问题。</p><p>这种现象是由于Windows与Ubuntu默认对时间的管理方式不同造成的。我们知道电脑的BIOS里记录着一串时间数据，操作系统就是根据这个数据得到当前时间的。Ubuntu系统使用的是UTC时间（世界协调时），系统会把BIOS里记录的时间看成GMT+0时间，即世界标准时。在Ubuntu系统中有一个设置，是配置当前所在时区的，在中国就会配置为东八区（GMT+8），所以Ubuntu会把BIOS中得到的时间加上8个小时显示出来，随后在系统关机的时候，将当前显示的时间减去8个小时后存入BIOS中。</p><p>而在Windows中，会将BIOS中的时间看做本地时间，直接显示出来，因此，当从Ubuntu切换到Windows时，会出现时间差8个小时的情况。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>最简单的方法就是将Ubuntu下的UTC时间关闭，采用和Window一样的时间管理方式。只需要在Ubuntu终端下运行一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo timedatectrl set-local-utc 1</div></pre></td></tr></table></figure><p>这样便可以使Windows和Ubuntu下的时间同步了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题缘由&quot;&gt;&lt;a href=&quot;#问题缘由&quot; class=&quot;headerlink&quot; title=&quot;问题缘由&quot;&gt;&lt;/a&gt;问题缘由&lt;/h1&gt;&lt;p&gt;现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="linux" scheme="http://yluo.name/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分屏终端Terminator上手</title>
    <link href="http://yluo.name/2019/04/06/terminator_intro/"/>
    <id>http://yluo.name/2019/04/06/terminator_intro/</id>
    <published>2019-04-05T16:18:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来<a href="https://github.com/ljjhome" target="_blank" rel="external">佳神</a>给推荐了一款老外经常使用的终端Terminator，上手了几天的确感觉很方便，尤其是分屏功能，可以在一个终端上像Vim一样分成多个终端，在使用ROS这种需要同时运行多个终端的软件时尤为便利。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>Terminator可以在同一个窗口上分割多个子窗口，每个小窗口运行独立的命令程序。一个父窗口管理多个子窗口，清晰明了知道每个子窗口的运行情况。可以快速自由切换子窗口，并且对子窗口进行最大化和全屏状态。除此之外还有自定义窗口标题、激活标签等等。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu软件源可以直接安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install terminator</div></pre></td></tr></table></figure></p><p>若想要安装最新版，则需要手动添加ppa<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:gnome-terminator</div><div class="line">sudo apt update</div><div class="line">sudo apt install terminator</div></pre></td></tr></table></figure></p><p>安装后，按终端的快捷键<code>Ctrl+Alt+T</code>便可呼出Terminator终端</p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>设置看个人喜好，配色方案什么的可以在设置菜单终端首选项里自由发挥，对于我来说，我一般配置两个：</p><ul><li>背景配置成80%透明，这样在抄写各种东西的时候很方便，可以透过终端看到终端后面的东西。</li><li>在配置文件里添加对256色的支持，这个在18.04下是迷人支持的，但是在14.04下是不支持的，需要手动开启一下，否则像Vim的插件airline之类的颜色是无法显示的。</li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>水平分屏<code>Ctrl+Shift+O</code></li><li>垂直分屏<code>Ctrl+Shift+E</code></li><li>搜索<code>Ctrl+Shift+F</code> </li><li>复制<code>Ctrl+Shift+C</code></li><li>粘贴<code>Ctrl+Shift+V</code></li><li>关闭当前终端<code>Ctrl+Shift+W</code></li><li>退出当前窗口<code>Ctrl+Shift+Q</code></li><li>切换显示当前窗口<code>Ctrl+Shift+X</code></li><li>全屏状态<code>F11</code></li><li>Clear屏幕<code>Ctrl+Shift+G</code></li><li>移动分隔条<code>Ctrl+Shift+方向键</code></li><li>隐藏/显示滚动条<code>Ctrl+Shift+S</code></li></ul><h1 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a>添加右键菜单</h1><p>若想把Terminator添加到右键菜单方便使用，有2种方案：</p><ul><li><code>nautilus-actions</code>工具，貌似在18.04上不好使</li><li><code>fma-config-tool</code>工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来&lt;a href=&quot;https://github.com/ljjhome&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="linux" scheme="http://yluo.name/tags/linux/"/>
    
      <category term="terminator" scheme="http://yluo.name/tags/terminator/"/>
    
  </entry>
  
  <entry>
    <title>Qt的ui编译机制浅析</title>
    <link href="http://yluo.name/2019/03/17/qt_uic/"/>
    <id>http://yluo.name/2019/03/17/qt_uic/</id>
    <published>2019-03-17T15:15:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt的ui编译机制"><a href="#Qt的ui编译机制" class="headerlink" title="Qt的ui编译机制"></a>Qt的ui编译机制</h1><p>利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用ui文件来编写界面，在cpp中编写界面没有在ui文件中利用拖拽的形式来编写界面来更直观。但是Qt是如何将ui文件转换成C++代码却很令我困惑，因此我特意了解了一下Qt的ui编译机制，加深对Qt的理解。</p><h1 id="利用uic来编译-ui文件"><a href="#利用uic来编译-ui文件" class="headerlink" title="利用uic来编译.ui文件"></a>利用uic来编译.ui文件</h1><p>Qt的.ui文件通过Qt Designer设计好以后，利用uic程序将.ui文件中的xml语法转换为c++的类文件，假设ui文件名为<code>mainwindow.ui</code>，在命令行中输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uic mainwindow.ui -o ui_mainwindow.h</div></pre></td></tr></table></figure></p><blockquote><p>注意：若存在多个Qt版本，则可能需要指定相应uic执行路径</p></blockquote><p>通过uic会生成<code>mainwindow.ui</code>文件对应的头文件<code>ui_mainwindow.h</code>，这个<code>ui_mainwindow.h</code>文件的内容大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/********************************************************************************</div><div class="line">** Form generated from reading UI file &apos;mainwindow.ui&apos;</div><div class="line">**</div><div class="line">** Created by: Qt User Interface Compiler version 5.9.5</div><div class="line">**</div><div class="line">** WARNING! All changes made in this file will be lost when recompiling UI file!</div><div class="line">********************************************************************************/</div><div class="line"></div><div class="line">#ifndef UI_MAINWINDOW_H</div><div class="line">#define UI_MAINWINDOW_H</div><div class="line"></div><div class="line">#include &lt;QtCore/QVariant&gt;</div><div class="line">#include &lt;QtWidgets/QAction&gt;</div><div class="line">#include &lt;QtWidgets/QApplication&gt;</div><div class="line">#include &lt;QtWidgets/QButtonGroup&gt;</div><div class="line">#include &lt;QtWidgets/QHeaderView&gt;</div><div class="line">#include &lt;QtWidgets/QMainWindow&gt;</div><div class="line">#include &lt;QtWidgets/QMenuBar&gt;</div><div class="line">#include &lt;QtWidgets/QStatusBar&gt;</div><div class="line">#include &lt;QtWidgets/QToolBar&gt;</div><div class="line">#include &lt;QtWidgets/QWidget&gt;</div><div class="line"></div><div class="line">QT_BEGIN_NAMESPACE</div><div class="line"></div><div class="line">class Ui_MainWindow</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    QMenuBar *menuBar;</div><div class="line">    QToolBar *mainToolBar;</div><div class="line">    QWidget *centralWidget;</div><div class="line">    QStatusBar *statusBar;</div><div class="line"></div><div class="line">    void setupUi(QMainWindow *MainWindow)</div><div class="line">    &#123;</div><div class="line">        if (MainWindow-&gt;objectName().isEmpty())</div><div class="line">            MainWindow-&gt;setObjectName(QStringLiteral(&quot;MainWindow&quot;));</div><div class="line">        MainWindow-&gt;resize(400, 300);</div><div class="line">        menuBar = new QMenuBar(MainWindow);</div><div class="line">        menuBar-&gt;setObjectName(QStringLiteral(&quot;menuBar&quot;));</div><div class="line">        MainWindow-&gt;setMenuBar(menuBar);</div><div class="line">        mainToolBar = new QToolBar(MainWindow);</div><div class="line">        mainToolBar-&gt;setObjectName(QStringLiteral(&quot;mainToolBar&quot;));</div><div class="line">        MainWindow-&gt;addToolBar(mainToolBar);</div><div class="line">        centralWidget = new QWidget(MainWindow);</div><div class="line">        centralWidget-&gt;setObjectName(QStringLiteral(&quot;centralWidget&quot;));</div><div class="line">        MainWindow-&gt;setCentralWidget(centralWidget);</div><div class="line">        statusBar = new QStatusBar(MainWindow);</div><div class="line">        statusBar-&gt;setObjectName(QStringLiteral(&quot;statusBar&quot;));</div><div class="line">        MainWindow-&gt;setStatusBar(statusBar);</div><div class="line"></div><div class="line">        retranslateUi(MainWindow);</div><div class="line"></div><div class="line">        QMetaObject::connectSlotsByName(MainWindow);</div><div class="line">    &#125; // setupUi</div><div class="line"></div><div class="line">    void retranslateUi(QMainWindow *MainWindow)</div><div class="line">    &#123;</div><div class="line">        MainWindow-&gt;setWindowTitle(QApplication::translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, Q_NULLPTR));</div><div class="line">    &#125; // retranslateUi</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">namespace Ui &#123;</div><div class="line">    class MainWindow: public Ui_MainWindow &#123;&#125;;</div><div class="line">&#125; // namespace Ui</div><div class="line"></div><div class="line">QT_END_NAMESPACE</div><div class="line"></div><div class="line">#endif // UI_MAINWINDOW_H</div></pre></td></tr></table></figure></p><p>这个文件就是将.ui文件转换为C++可以看得懂的代码，之后参与Qt源代码的编译，可以看到这个文件中定义了一个<code>Ui_MainWindow</code>类，里面包含了在.ui文件中创建的各种窗口部件的实现，文件最后还定义了一个命名空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace Ui &#123;</div><div class="line">    class MainWindow: public Ui_MainWindow &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个命名空间Ui中包含了一个新类<code>MainWindow</code>，而这个新类继承自<code>Ui_MainWindow</code>类，之后我们便可以在别的文件中利用<code>Ui::MainWindow</code>调用这个ui类，或者直接调用<code>Ui_MainWindow</code>也可以。</p><h1 id="Ui调用"><a href="#Ui调用" class="headerlink" title="Ui调用"></a>Ui调用</h1><p>在Qt项目中，在<code>mainwindow.h</code>中添加Ui命名空间的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace Ui &#123;</div><div class="line">class MainWindow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之后在继承<code>QMainWindow</code>类的对象声明中添加成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ui::MainWindow *ui;</div></pre></td></tr></table></figure></p><p>在<code>mainwindow.cpp</code>的类构造函数中，初始化ui成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ui = new Ui::MainWindow;</div><div class="line">ui-&gt;setupUi(this);</div></pre></td></tr></table></figure></p><p>在类的析构函数中释放ui指针指向的内存空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete ui;</div></pre></td></tr></table></figure></p><p>这样便实现了ui的调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt的ui编译机制&quot;&gt;&lt;a href=&quot;#Qt的ui编译机制&quot; class=&quot;headerlink&quot; title=&quot;Qt的ui编译机制&quot;&gt;&lt;/a&gt;Qt的ui编译机制&lt;/h1&gt;&lt;p&gt;利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="qt" scheme="http://yluo.name/tags/qt/"/>
    
      <category term="uic" scheme="http://yluo.name/tags/uic/"/>
    
  </entry>
  
  <entry>
    <title>Qt高分屏支持</title>
    <link href="http://yluo.name/2019/03/17/qt_high_dpi/"/>
    <id>http://yluo.name/2019/03/17/qt_high_dpi/</id>
    <published>2019-03-17T14:47:00.000Z</published>
    <updated>2020-01-16T05:54:40.498Z</updated>
    
    <content type="html"><![CDATA[<p>随着智能手机等电子设备的发展，越来越多的电子设备开始使用上了高分屏，高分屏的确让屏幕的观感更好，但是若没有相应的支持，由于DPI过高，会导致程序字体按钮等看上去特别小，影响使用。而Qt从5.6版本开始对高分屏有了相应的支持，只需要一行代码即可完成对高分屏的支持。</p><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><p>在程序的<code>main</code>函数中<code>QApplication</code>对象初始化之前加入如下一行代码即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);</div></pre></td></tr></table></figure><p>这个文件看上去大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindow.h"</span> <span class="comment">//头文件</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); <span class="comment">//添加高分屏支持</span></div><div class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</div><div class="line">    MainWindow w;</div><div class="line">    w.show();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> a.exec();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>添加完上述代码后，若是高分屏的电脑则会将Qt的窗口相应的放大，若不是高分屏的电脑则分辨率不变，这样便实现了对高分屏的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着智能手机等电子设备的发展，越来越多的电子设备开始使用上了高分屏，高分屏的确让屏幕的观感更好，但是若没有相应的支持，由于DPI过高，会导致程序字体按钮等看上去特别小，影响使用。而Qt从5.6版本开始对高分屏有了相应的支持，只需要一行代码即可完成对高分屏的支持。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="qt" scheme="http://yluo.name/tags/qt/"/>
    
      <category term="dpi" scheme="http://yluo.name/tags/dpi/"/>
    
  </entry>
  
  <entry>
    <title>VIM插件推荐</title>
    <link href="http://yluo.name/2019/03/06/vim_intro/"/>
    <id>http://yluo.name/2019/03/06/vim_intro/</id>
    <published>2019-03-06T02:11:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个半入门级程序员，不会使用VIM这种大神级的文本编辑器，总感觉到心里有一丝丝的羞愧～～正好赶上这段空闲时间，便在网上买了一本《Practical VIM》，从头开始对VIM进行一下系统的学习。推荐一下Vim下的牛逼插件。</p><h1 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a>Vundle</h1><blockquote><p>下载地址: <a href="">https://github.com/VundleVim/Vundle.vim</a></p><p>超级方便的插件管理工具，我只能说这个是安装管理所有插件的开始，第一需要安装的就是它！</p></blockquote><h1 id="airline"><a href="#airline" class="headerlink" title="airline"></a>airline</h1><blockquote><p>下载地址：<a href="">https//github.com/vim-airline/vim-airline</a></p></blockquote><p>vim状态提示栏，我认为的必需插件之一！</p><h1 id="YouCompeleteMe"><a href="#YouCompeleteMe" class="headerlink" title="YouCompeleteMe"></a>YouCompeleteMe</h1><blockquote><p>下载地址： <a href="">https://github.com/Valloric/YouCompleteMe</a></p></blockquote><p>超强悍代码补全插件</p><h1 id="tpope"><a href="#tpope" class="headerlink" title="tpope"></a>tpope</h1><p>tpope不是插件，而是一个人，Vim插件的最主要贡献者之一，提供了众多好用插件，看看Github上的star就明白了，再此只推荐几个我经常用的。</p><ul><li>tpope/vim-fugitive</li><li>tpope/vim-surround</li><li>tpope/vim-abolish</li><li>tpope/vim-commentary</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个半入门级程序员，不会使用VIM这种大神级的文本编辑器，总感觉到心里有一丝丝的羞愧～～正好赶上这段空闲时间，便在网上买了一本《Practical VIM》，从头开始对VIM进行一下系统的学习。推荐一下Vim下的牛逼插件。&lt;/p&gt;
&lt;h1 id=&quot;Vundle&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="vim" scheme="http://yluo.name/tags/vim/"/>
    
      <category term="vim plugin" scheme="http://yluo.name/tags/vim-plugin/"/>
    
  </entry>
  
  <entry>
    <title>Vim相关指令汇总</title>
    <link href="http://yluo.name/2019/03/05/vim_cmd/"/>
    <id>http://yluo.name/2019/03/05/vim_cmd/</id>
    <published>2019-03-05T13:19:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h1><ul><li><code>f{char}</code>/<code>F{char}</code> 在行内查找下/上一指定字符，光标停留在查找到的指定字符上，重复<code>;</code>，回退<code>,</code>；</li><li><code>t{char}</code>/<code>T{char}</code> 在行内查找下/上一指定字符，光标停留在查找到的指定字符之前，重复<code>;</code>，回退<code>,</code>；</li><li><code>/pattern&lt;CR&gt;</code>/<code>?pattern&lt;CR&gt;</code> 在文档中查找下/上一处匹配项，重复<code>n</code>，回退<code>N</code>；</li><li><code>*</code> 查找当前光标下的单词，重复<code>n</code>，回退<code>N</code>。</li></ul><h1 id="替换指令"><a href="#替换指令" class="headerlink" title="替换指令"></a>替换指令</h1><ul><li><code>:s/target/replacement</code> 执行一处替换</li><li><code>:s/target/replacement/g</code> 执行一行替换</li><li><code>:%s/target/replacement/g</code> 执行全文替换</li></ul><h1 id="移动指令"><a href="#移动指令" class="headerlink" title="移动指令"></a>移动指令</h1><ul><li><code>j,k</code>/<code>gj,gk</code> 移动实际行/屏幕行</li><li><code>0</code>/<code>g0</code> 移动到实际行/屏幕行行首</li><li><code>^</code>/<code>g^</code> 移动到实际行/屏幕行的第一个非空白字符</li><li><script type="math/tex">`/`g</script> 移动到实际行/屏幕行的行尾</li></ul><h2 id="基于单词移动"><a href="#基于单词移动" class="headerlink" title="基于单词移动"></a>基于单词移动</h2><ul><li><code>w</code> 正向移动到下一单词开头</li><li><code>b</code> 反向移动到当前单词/上一单词的开头</li><li><code>e</code> 正向移动到当前单词/下一单词的结尾</li><li><code>ge</code> 反向移动到上一单词的结尾</li><li><code>W</code> 正向移动到下一字串开头</li><li><code>B</code> 反向移动到当前字串/上一字串的开头</li><li><code>E</code> 正向移动到当前字串/下一字串的结尾</li><li><code>gE</code> 反向移动到上一字串的结尾</li></ul><blockquote><p>简单理解：字串比单词更长，<code>e.g.</code>为4个单词或1个字串，如果要删除的词里有特殊符号，则用字串删除更方便</p></blockquote><h1 id="删除指令"><a href="#删除指令" class="headerlink" title="删除指令"></a>删除指令</h1><ul><li><code>x</code>/<code>dl</code> 删除当前字符</li><li><code>dd</code> 删除当前行</li><li><code>dw</code> 删除当前单词</li><li><code>daw</code> 删除当前文本对象</li><li><code>dap</code> 删除当前段落</li><li><code>&lt;C-h&gt;</code> 插入模式下删除前一个字符（同退格键）(bash也可用)</li><li><code>&lt;C-w&gt;</code> 插入模式下删除前一个单词(bash也可用)</li><li><code>&lt;C-u&gt;</code> 插入模式下删除至行首(bash也可用)</li></ul><h1 id="复制和粘贴指令"><a href="#复制和粘贴指令" class="headerlink" title="复制和粘贴指令"></a>复制和粘贴指令</h1><ul><li><code>y</code> 复制yank<ul><li><code>yw</code> 复制当前单词</li><li><code>yap</code> 复制当前段落</li><li><code>&quot;ayw</code> 复制当前单词到a寄存器</li></ul></li><li><code>p</code> 粘贴put（光标之后）<ul><li><code>&quot;ap</code> 将寄存器a中的内容复制到当前位置</li></ul></li><li><code>P</code> 粘贴（光标之前）</li><li><code>&lt;C-o&gt;{register}</code> 在插入模式下，粘贴寄存器{register}中的内容到当前光标下</li></ul><h1 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h1><ul><li><code>[count]&lt;C-a&gt;</code> 对当前光标上或之后的数值加[count]</li><li><code>[count]&lt;C-x&gt;</code> 对当前光标上或之后的数值减[count]</li></ul><p>注：<code>&lt;C-a&gt;</code>与<code>&lt;C-x&gt;</code>可以对光标之后的第一个数值进行操作，不必将光标移动到数值的位置也可。</p><h1 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h1><ul><li><code>g~</code> 反转大小写<ul><li><code>g~~</code> 反转当前行大小写</li><li><code>g~w</code> 反转当前单词大小写</li><li><code>g~W</code> 反转当前字串大小写</li><li><code>g~ap</code> 反转当前段落大小写</li></ul></li><li><code>gU</code> 转换为大写<ul><li><code>gUU</code> 转换当前行为大写</li><li><code>gUw</code> 转换当前单词为大写</li><li><code>gUap</code> 转换当前段落为大写</li></ul></li><li><code>gu</code> 转换为小写<ul><li><code>guu</code> 转换当前行为小写</li><li><code>guw</code> 转换当前单词为小写</li><li><code>guap</code> 转换当前段落为小写</li></ul></li><li><code>&gt;</code>/<code>&lt;</code> 增加/减小缩进<ul><li><code>&gt;&gt;</code> 缩进当前行</li><li><code>&gt;w</code>/<code>&gt;l</code> 增加当前行缩进（毕竟单词和字符都在一行）</li><li><code>&gt;ap</code> 增加当前段落缩进</li></ul></li><li><code>=</code> 自动缩进</li><li><code>gc</code> 注释/反注释（需安装tpope/vim-commentary插件）<ul><li><code>gcc</code> 注释/反注释当前行</li><li><code>gcap</code> 注释当前段落</li></ul></li><li><code>zz</code> 重绘屏幕，当前行显示在窗口正中<ul><li><code>&lt;C-o&gt;zz</code> 在插入模式下切换普通模式并重绘屏幕，之后重新返回插入模式</li></ul></li><li><code>xp</code> 调换光标之后的两个字符</li><li><code>ddp</code> 调换当前行和它的下一行</li><li><code>yyp</code> 创建当前行副本</li></ul><h1 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h1><ul><li><code>m{char}</code> 负责设置标记</li><li><code>\</code>{char}` 负责跳转到标记</li></ul><h1 id="经典组合"><a href="#经典组合" class="headerlink" title="经典组合"></a>经典组合</h1><ul><li><code>ea</code> 在单词结尾添加</li><li><code>f,dt.</code> 删除后半句（逗号到句号之间内容）</li></ul><h1 id="寄存器说明"><a href="#寄存器说明" class="headerlink" title="寄存器说明"></a>寄存器说明</h1><h2 id="有名寄存器（普通寄存器）"><a href="#有名寄存器（普通寄存器）" class="headerlink" title="有名寄存器（普通寄存器）"></a>有名寄存器（普通寄存器）</h2><ul><li><code>&quot;a</code>~<code>&quot;z</code> </li></ul><h2 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h2><ul><li><code>&quot;&quot;</code>无名寄存器，缺省使用，<code>x</code>，<code>s</code>，<code>d{motion}</code>，<code>y{motion}</code> 都会覆盖其内容；</li><li><code>&quot;0</code> 复制专用寄存器，当使用<code>y{motion}</code>时，会覆盖其内容；</li><li><code>&quot;_</code> 黑洞寄存器，有去无回。</li><li><code>&quot;+</code>/<code>&quot;*</code> 系统剪贴板，有一定区别，但是不加以区分了<ul><li><code>&quot;+p</code> 将系统剪贴板的内容粘贴</li></ul></li><li><code>&quot;=</code> 表达式寄存器</li><li><code>&quot;%</code> 当前文件名（read only）</li><li><code>&quot;#</code> 轮换文件名（read only）</li><li><code>&quot;.</code> 上次插入的文本（read only）</li><li><code>&quot;:</code> 上次执行的Ex命令（read only）</li><li><code>&quot;/</code> 上次查找的模式（可使用<code>:let</code>进行赋值）</li></ul><h1 id="技巧总结"><a href="#技巧总结" class="headerlink" title="技巧总结"></a>技巧总结</h1><ul><li>能够重复，就别用次数。 <code>dw.</code>要优于<code>2dw</code>和<code>d2w</code></li><li>尽量不用光标键，使手指始终位于本位行上</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查找指令&quot;&gt;&lt;a href=&quot;#查找指令&quot; class=&quot;headerlink&quot; title=&quot;查找指令&quot;&gt;&lt;/a&gt;查找指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f{char}&lt;/code&gt;/&lt;code&gt;F{char}&lt;/code&gt; 在行内查找下/上一指定字符，
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="vim" scheme="http://yluo.name/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>利用CMAKE构建Qt和OpenCV项目</title>
    <link href="http://yluo.name/2019/03/05/cmake_qt_opencv/"/>
    <id>http://yluo.name/2019/03/05/cmake_qt_opencv/</id>
    <published>2019-03-05T04:18:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p>Qt是一套完整的跨平台软件开发框架，在开源世界无人不知无人不晓。</p><p>官网地址：<a href="https://qt.io/" target="_blank" rel="external">https://qt.io</a></p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><p>开源计算机视觉库，如何编译OpenCV可以参考我的另一篇博客<a href="http://yluo.name/2019/02/12/cmake_build_opencv/">《利用CMAKE编译OpenCV源码》</a></p><h2 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h2><p>关于什么是CMAKE可以参考我的另一篇博客<a href="http://yluo.name/2019/01/02/cmake/">《利用CMAKE构建和管理软件项目》</a>。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li>项目目录：qt_cmake<ul><li>源文件目录： src<ul><li>文件： </li><li>main.cpp</li><li>mainwindow.cpp</li><li>mainwindow.h</li><li>mainwindow.ui</li></ul></li><li>构建文件目录：build</li></ul></li></ul><h1 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h1><p>新建一个文件夹名为<code>qt_cmake</code>，在文件夹下新建两个文件夹，一个为<code>src</code>，另一个为<code>build</code>。其中<code>src</code>用来放置工程源代码文件，<code>build</code>用来存放构建生成的项目文件。</p><p>在<code>src</code>文件夹下新建<code>main.cpp</code>文件，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;mainwindow.h&quot;</div><div class="line">#include &lt;QApplication&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    QApplication a(argc, argv);</div><div class="line">    MainWindow w;</div><div class="line">    w.show();</div><div class="line"></div><div class="line">    return a.exec();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>利用Qt Creator新建一个Qt设计师界面类，会自动生成3个文件：<code>mainwindow.h</code>，<code>mainwindow.cpp</code>，<code>mainwindow.ui</code>。</p><p>随后打开<code>mainwindow.cpp</code>文件，在其中填入相关的OpenCV代码做测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &quot;mainwindow.h&quot;</div><div class="line">#include &quot;ui_mainwindow.h&quot;</div><div class="line"></div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line"></div><div class="line">MainWindow::MainWindow(QWidget *parent) :</div><div class="line">    QMainWindow(parent),</div><div class="line">    ui(new Ui::MainWindow)</div><div class="line">&#123;</div><div class="line">    ui-&gt;setupUi(this);</div><div class="line"></div><div class="line">    cv::Mat srcImg = cv::imread(&quot;/path/to/your/image.jpg&quot;);</div><div class="line">    cv::imshow(&quot;origin image&quot;,srcImg);</div><div class="line"></div><div class="line">    cv::waitKey(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainWindow::~MainWindow()</div><div class="line">&#123;</div><div class="line">    delete ui;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在<code>src</code>文件夹下建立CMakeLists.txt文件，在里面建立内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">cmake_minimum_required(VERSION 3.1)</div><div class="line"></div><div class="line">project(qt_cmake)</div><div class="line"></div><div class="line"># Find includes in corresponding build directories</div><div class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</div><div class="line"># Instruct cmake to run moc automatically when needed</div><div class="line">set(CMAKE_AUTOMOC ON)</div><div class="line"># Create code from a list of Qt designer ui files</div><div class="line">set(CMAKE_AUTOUIC ON)</div><div class="line"></div><div class="line"># set OpenCV directory</div><div class="line">#set(OpenCV_DIR /usr/share/OpenCV)</div><div class="line"></div><div class="line"># set Qt directory</div><div class="line">#set(CMAKE_PREFIX_PATH /home/think/Qt5.11.1/5.11.1/gcc_64/lib/cmake)</div><div class="line"></div><div class="line"># Find the QtWidgets library</div><div class="line">find_package(Qt5 REQUIRED Widgets Core)</div><div class="line">#find_package(Qt5Widgets CONFIG REQUIRED)</div><div class="line"># Finde OpenCV library</div><div class="line">find_package(OpenCV REQUIRED)</div><div class="line"></div><div class="line"></div><div class="line">message(STATUS &quot;OpenCV library status:&quot;)</div><div class="line">message(STATUS &quot;    version: $&#123;OpenCV_VERSION&#125;&quot;)</div><div class="line">message(STATUS &quot;    libraries: $&#123;OpenCV_LIBS&#125;&quot;)</div><div class="line">message(STATUS &quot;    include path: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)</div><div class="line"></div><div class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</div><div class="line"></div><div class="line">set(SOURCES</div><div class="line">main.cpp</div><div class="line">mainwindow.cpp)</div><div class="line"></div><div class="line">set(FORMS</div><div class="line">mainwindow.ui)</div><div class="line"></div><div class="line">add_executable(main $&#123;SOURCES&#125; $&#123;FORMS&#125;)</div><div class="line">#link_directories($&#123;OpenCV_LIBRARY_DIRS&#125;)</div><div class="line">target_link_libraries(main Qt5::Widgets $&#123;OpenCV_LIBS&#125;)</div></pre></td></tr></table></figure><p>简单介绍一下CMakeLists.txt文件中代码含义</p><ol><li><p>cmake_minimum_required(VERSION 3.1)</p><p> 接下来是设置cmake要求的最低版本号：为3.1。CMAKE在3.1版本以上才支持Qt。</p></li><li><p>project(qt_cmake [CXX] [C] [Java])</p><p> 定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的，这个指令隐式的定义了两个cmake变量:qt_cmake_BINARY_DIR以及qt_cmake_SOURCE_DIR。前者指构建路径，后者指工程路径，即CMakeLists.txt所在的路径。</p><p> 同时cmake系统也帮助我们预定义了PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR变量，他们的值分别跟qt_cmake_BINARY_DIR与qt_cmake_SOURCE_DIR一致。</p><p> 为了统一起见，建议以后直接使用PROJECT_BINARY_DIR，PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。如果使用了qt_cmake_SOURCE_DIR，修改工程名称后，需要同时修改这些变量。</p></li><li><p>set(OpenCV_DIR /usr/share/OpenCV)</p><p> 设置OpenCV_DIR变量，若只安装了一个版本的OpenCV则不用设置这个变量，若存在多个版本的OpenCV则需要利用OpenCV_DIR变量来指定想要的版本。</p></li><li><p>find_package(OpenCV REQUIRED)</p><p> find_package这个指令以被用来在系统中自动查找配置构建工程所需的程序库。在linux和unix类系统下这个命令尤其有用。CMake自带的模块文件里有大半是对各种常见开源库的find_package支持，支持库的种类非常多。</p><p> 当它找到OpenCV程序库之后，就会帮助我们预定义几个变量，OpenCV_FOUND、OpenCV_INCLUDE_DIRS、OpenCV_LIBRARY_DIRS、OpenCV_LIBRARIES，它们分别指是否找到OpenCV，OpenCV的头文件目录，OpenCV的库文件目录，OpenCV的所有库文件列表。</p></li><li><p>include_directories(${OpenCV_INCLUDE_DIRS})</p><p> OpenCV相关包含路径</p></li><li><p>add_executable(main ${SOURCES} ${FORMS})</p><p> 添加可执行文件main</p></li><li><p>target_link_libraries(main Qt5::Widgets ${OpenCV_LIBS})</p><p> 添加动态链接库</p></li></ol><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><ul><li>进入build目录</li><li>执行<code>cmake ../src</code></li><li>执行<code>make</code></li><li>运行程序<code>./main</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;Qt&quot;&gt;&lt;a href=&quot;#Qt&quot; class=&quot;headerlink&quot; title=&quot;Qt&quot;&gt;&lt;/a&gt;Qt&lt;/h
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="opencv" scheme="http://yluo.name/tags/opencv/"/>
    
      <category term="Qt" scheme="http://yluo.name/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>利用CMAKE编译OpenCV源码</title>
    <link href="http://yluo.name/2019/02/12/cmake_build_opencv/"/>
    <id>http://yluo.name/2019/02/12/cmake_build_opencv/</id>
    <published>2019-02-12T14:05:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV是什么"><a href="#OpenCV是什么" class="headerlink" title="OpenCV是什么"></a>OpenCV是什么</h1><p>OpenCV的中文名称是”开源计算机视觉库“（Open Source Computer Vision Library），于1999年由Intel建立，是一个基于开源发行的跨平台计算机视觉库，可以运行在Linux、Windows、Mac OS、Android、iOS、FreeBSD、OpenBSD等操作系统上。OpenCV由一系列C函数和C++类构成，轻量且高效。除了支持C/C++语言编译开发之外，还支持使用C#，Python、Ruby等语言的接口。</p><h1 id="为什么要编译源码"><a href="#为什么要编译源码" class="headerlink" title="为什么要编译源码"></a>为什么要编译源码</h1><p>在OpenCV的官网提供了许多编译好的Release版本的OpenCV二进制文件，但是由于很多人的需求不同，比如OpenCV官网提供的Windows版本是利用MSVC编译的，但是很多人却需要在Windows下使用MinGW编译代码，因此需要Windows下MinGW可以利用的二进制文件，由于OpenCV提供源码，因此可以利用OpenCV的源码编译出各种二进制文件，也可以修改官网的OpenCV源码并编译后为自己所用。</p><h1 id="利用CMAKE编译OpenCV源码"><a href="#利用CMAKE编译OpenCV源码" class="headerlink" title="利用CMAKE编译OpenCV源码"></a>利用CMAKE编译OpenCV源码</h1><p>关于什么是CMAKE可以参考我的另一篇博客<a href="http://yluo.name/2019/01/02/cmake/">《利用CMAKE构建和管理软件项目》</a>。</p><ul><li>安装完CMAKE之后，启动cmake-gui。</li><li>指定OpenCV<strong>源码存放路径</strong>。点击<code>Browse Source</code>按钮，在弹出的对话框中指定OpenCV源码存放路径<code>/path/to/opencv/sources</code>。</li><li>指定OpenCV<strong>构建存放路径</strong>。点击<code>Browse Build</code>按钮，在弹出的对话框中指定OpenCV构建文件存放路径，可随意设置，但不要放在源码路径下。</li><li>点击<code>Configure</code>按钮，进行第一次配置，之后会弹出编译器选择对话框，选择想要生成的项目文件（比如MSVC或者MinGW），可以使用默认的编译器，也可以指定编译器，比如在使用MinGW编译时，可以指定采用GCC和G++来编译OpenCV源码。确认无误点击<code>Finish</code>按钮开始第一次配置过程。</li><li>第一次配置完成后，会在主对话框上出现很多编译选项，勾选<code>Advanced</code>还会显示更多，这些都是默认的编译选项，可以进行修改，比如勾选<code>WITH_OPENGL</code>和<code>WITH_QT</code>选项等。设置完成后还需要进行第二次配置，再次点击<code>Configure</code>按钮，高亮的选项会变成正常（若还是有高亮选择则需要继续修改配置选项然后点击<code>Configure</code>配置）。</li><li>点击<code>Generate</code>生成项目文件，会在<strong>构建存放路径</strong>下生成对应的项目文件，比如VS的.sln解决方案文件，或者MinGW的Makefile文件，于是便可以利用对应的项目文件生成二进制文件了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV是什么&quot;&gt;&lt;a href=&quot;#OpenCV是什么&quot; class=&quot;headerlink&quot; title=&quot;OpenCV是什么&quot;&gt;&lt;/a&gt;OpenCV是什么&lt;/h1&gt;&lt;p&gt;OpenCV的中文名称是”开源计算机视觉库“（Open Source Compute
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="opencv" scheme="http://yluo.name/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装时如何分配目录空间</title>
    <link href="http://yluo.name/2019/01/25/ubuntu_partition/"/>
    <id>http://yluo.name/2019/01/25/ubuntu_partition/</id>
    <published>2019-01-25T11:52:00.000Z</published>
    <updated>2020-01-16T02:31:18.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>像我这种主力系统为Linux，但是有些软件还必须在Windows上运行的人，在笔记本上安装Linux与Windows是必不可少的。估计很多用双系统的同学在手动安装Ubuntu或者其他Linux发行版时会像我一样，对如何给Linux的各个目录分配空间头疼不已。因此我下定决心研究了一下这些目录的功能，在此分享给大家。</p><h1 id="Linux的分区和挂载"><a href="#Linux的分区和挂载" class="headerlink" title="Linux的分区和挂载"></a>Linux的分区和挂载</h1><p>Linux的分区和Windows有很大不同。在Windows下，是以<code>盘符</code>来分割各个空间，而且一般操作系统都安装在<code>C盘</code>，剩下的<code>D盘</code>，<code>E盘</code>可以用来存储其他的文件和程序。而Linux不同，Linux有一个最基本的根目录<code>/</code>，所有其他的目录都在这个目录下，根目录<code>/</code>就像是一个大房子，<code>/</code>目录下面的其他目录，比如<code>/etc</code>，<code>/boot</code>等，就像是一个一个功能区，<code>/etc</code>用来存储配置文件，<code>/bin</code>用来放二进制程序，<code>/boot</code>用来放启动文件，<code>/home</code>用来放用户的文件等等。</p><p>Linux的分区和目录的关系是：可以指定一个目录力的东西存在某个分区里，如果不指定，则这个目录里的东西存在上一级目录所在分区中，如果上一级目录页没有特殊制定分期，则再上溯一级目录，以此类推。最后可以上溯到根目录<code>/</code>。所以装系统的时候，其他的都可以不指定，但是一定要指定<code>/</code>目录存放的分区。</p><h1 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h1><p>给Ubuntu一般30G左右就够用了，一般安装的时候我们都给<code>/boot</code>,<code>/swap</code>,<code>/</code>和<code>/home</code>分配一下相应的空间，其余的可以不分配。</p><ul><li><code>/boot</code>为启动分区，分配大小：200MB，分区类型：主分区，分区位置：空间起始位置，用于：Ext4日志文件系统，挂载点：/boot；</li><li><code>swap</code>为交换空间，一般为实际内存2倍左右，但是如果内存足够大，就不需要设置。分配大小：内存×2，分区类型：逻辑分区，分区位置：空间起始位置，用于：交换空间，挂载点：SWAP；</li><li><code>/</code>为根目录，分配大小：至少10G以上，分区类型：逻辑分区，分区位置：空间起始位置，用于：Ex4日志文件系统，挂载点：/；</li><li><code>/home</code>为用户目录，分配大小：剩余所有空间，分区类型：逻辑分区，分区位置：空间起始位置，用于：Ext4日志文件系统，挂载点：/home。</li></ul><h1 id="安装启动引导设备"><a href="#安装启动引导设备" class="headerlink" title="安装启动引导设备"></a>安装启动引导设备</h1><p>Ubuntu采用Grub来引导系统，选择<code>/boot</code>所在分区即可。</p><h1 id="UEFI引导下的配置"><a href="#UEFI引导下的配置" class="headerlink" title="UEFI引导下的配置"></a>UEFI引导下的配置</h1><p>若用UEFI引导系统，则空间分配时无需给<code>/boot</code>分配空间，在安装启动引导设备的选项中，选择<code>Windows Boot Manager</code>所在的分区即可完成引导。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;像我这种主力系统为Linux，但是有些软件还必须在Windows上运行的人，在笔记本上安装Linux与Windows是必不可
      
    
    </summary>
    
      <category term="OS" scheme="http://yluo.name/categories/OS/"/>
    
    
      <category term="linux" scheme="http://yluo.name/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>GRUB简介与配置</title>
    <link href="http://yluo.name/2019/01/24/grub/"/>
    <id>http://yluo.name/2019/01/24/grub/</id>
    <published>2019-01-24T15:17:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是GRUB"><a href="#什么是GRUB" class="headerlink" title="什么是GRUB"></a>什么是GRUB</h1><p>GNU GRUB（简称“GRUB”）是一个来自GNU项目的启动引导程序。GRUB 来自 GRand Unified Bootloader 的缩写。它的功能是在启动时从 BIOS 接管掌控、加载自身、加载 Linux 内核到内存，然后再把执行权交给内核。一旦内核开始掌控，GRUB 就完成了它的任务，也就不再需要了。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。</p><p>简单的说，如果你的电脑上需要同时安装多个操作系统，比如Windows，Ubuntu，Centos，RHEL等（各种LINUX发行版）的话，就可以利用GRUB来作为启动引导程序，来引导系统启动。</p><h1 id="GRUB菜单"><a href="#GRUB菜单" class="headerlink" title="GRUB菜单"></a>GRUB菜单</h1><p>GRUB 菜单的功能是当默认的内核不是想要的时，允许用户从已经安装的内核中选择一个进行引导。通过上下箭头键允许你选中想要的内核，敲击回车键会使用选中的内核继续引导进程。</p><p>GRUB 菜单也提供了超时机制，因此如果用户没有做任何选择，GRUB 就会在没有用户干预的情况下使用默认内核继续引导。敲击键盘上除了回车键之外的任何键会停止终端上显示的倒数计时器。立即敲击回车键会使用默认内核或者选中的内核继续引导进程。</p><h1 id="GRUB配置"><a href="#GRUB配置" class="headerlink" title="GRUB配置"></a>GRUB配置</h1><p>GRUB的一个重要的特性是安装它不需依附一个操作系统，但是这种安装需要一个Linux/Windows副本。由于单独工作，GRUB实质上是一个微型系统，通过链式启动的方式，它可以启动所有安装的主流操作系统。</p><p>因此GRUB通常在Linux系统下进行配置。<code>grub.cfg</code>文件是GRUB配置文件。它由<code>grub-mkconfig</code>程序根据用户的配置使用一组主配置文件以及GRUB默认文件而生成。<code>/boot/grub/grub.cfg</code>文件在Linux安装时会初次生成，安装新内核时又会重新生成。但是如果需要手动配置GRUB，则不能修改这个文件，而是修改<code>/etc/default/grub</code>文件，这个文件的内容大致如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">GRUB_DEFAULT=0</div><div class="line">GRUB_HIDDEN_TIMEOUT=0</div><div class="line">GRUB_TIMEOUT=10</div><div class="line">GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`</div><div class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</div><div class="line">GRUB_CMDLINE_LINUX=&quot;&quot;</div><div class="line"></div><div class="line"># Uncomment to enable BadRAM filtering, modify to suit your needs</div><div class="line"># This works with Linux (no patch required) and with any kernel that obtains</div><div class="line"># the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)</div><div class="line">#GRUB_BADRAM=&quot;0x01234567,0xfefefefe,0x89abcdef,0xefefefef&quot;</div><div class="line"></div><div class="line"># Uncomment to disable graphical terminal (grub-pc only)</div><div class="line">#GRUB_TERMINAL=console</div><div class="line"></div><div class="line"># The resolution used on graphical terminal</div><div class="line"># note that you can use only modes which your graphic card supports via VBE</div><div class="line"># you can see them in real GRUB with the command `vbeinfo&apos;</div><div class="line">GRUB_GFXMODE=1366x768</div><div class="line"></div><div class="line"># Uncomment if you don&apos;t want GRUB to pass &quot;root=UUID=xxx&quot; parameter to Linux</div><div class="line">#GRUB_DISABLE_LINUX_UUID=true</div><div class="line"></div><div class="line"># Uncomment to disable generation of recovery mode menu entries</div><div class="line">#GRUB_DISABLE_RECOVERY=&quot;true&quot;</div><div class="line"></div><div class="line"># Uncomment to get a beep at grub start</div><div class="line">#GRUB_INIT_TUNE=&quot;480 440 1&quot;</div></pre></td></tr></table></figure><p>在修改完<code>/etc/default/grub</code>文件之后，需要在终端运行<code>update-grub</code>来更新<code>/boot/grub/grub.cfg</code>文件，这样就完成了对GRUB的配置。</p><p>下面介绍几个本人比较常用的GRUB配置。</p><h2 id="修改开机默认引导上次选择的操作系统"><a href="#修改开机默认引导上次选择的操作系统" class="headerlink" title="修改开机默认引导上次选择的操作系统"></a>修改开机默认引导上次选择的操作系统</h2><ul><li><p>打开<code>/etc/default/grub</code>文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/default/grub</div></pre></td></tr></table></figure></li><li><p>修改并加入如下代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GRUB_DEFAULT=saved</div><div class="line">GRUB_SAVEDEFAULT=true</div></pre></td></tr></table></figure></li><li><p>更新<code>/boot/grub/grub.cfg</code>文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure></li></ul><h2 id="修改GRUB开机引导画面"><a href="#修改GRUB开机引导画面" class="headerlink" title="修改GRUB开机引导画面"></a>修改GRUB开机引导画面</h2><p>GRUB最爽的就是开机引导画面的定制，可以下载各种大神制作的主题，使开机画面美轮美奂。</p><ul><li><p>下载GRUB主题，将主题下的文件夹中的内容复制到<code>/boot/grub/themes</code>下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp -R /path/to/your_theme /boot/grub/themes</div></pre></td></tr></table></figure></li><li><p>修改<code>/etc/default/grub</code>文件</p><ol><li><p>将<code>GRUB_GFXMODE</code>修改为自己屏幕分辨率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRUB_GFXMODE=1366*768</div></pre></td></tr></table></figure></li><li><p>修改或添加一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRUB_THEME=/boot/grub/themes/your_theme/theme.txt</div></pre></td></tr></table></figure></li><li><p>更新<code>/boot/grub/grub.cfg</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure></li></ol></li></ul><h1 id="GRUB引导修复"><a href="#GRUB引导修复" class="headerlink" title="GRUB引导修复"></a>GRUB引导修复</h1><p>当<code>/boot/grub/grub.conf</code>配置文件丢失, 或者关键配置出现错误, 或者MBR、UEFI记录的引导程序遭到破坏时, Linux主机启动后可能只会出现“grub&gt;”的提示符，无法完成进一步的系统启动过程。</p><p>这表示你的grub2的配置文件损坏，GRUB找不到Ubuntu系统的引导项. 从而进入修复模式了(grub rescue), 也称救援模式。在救援模式下只有很少的命令可以用: set，ls，insmod，root，prefix。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set</td><td>查看环境变量</td></tr><tr><td>ls</td><td>查看设备</td></tr><tr><td>insmod</td><td>加载模块</td></tr><tr><td>root</td><td>指定用于启动系统的分区，设置GRUB启动分区</td></tr><tr><td>prefix</td><td>设定GRUB启动路径</td></tr></tbody></table></div><h2 id="进入GRUB救援模式后手动引导系统"><a href="#进入GRUB救援模式后手动引导系统" class="headerlink" title="进入GRUB救援模式后手动引导系统"></a>进入GRUB救援模式后手动引导系统</h2><ul><li>利用<code>ls</code>命令列出所有磁盘分区，查找启动分区，一般情况下EFI启动分区大小为500M左右，Linux的<code>/boot</code>分区为200M～500M。</li><li><p>执行以下命令来手动引导系统</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grub&gt;set root=(hd0,msdos8) //假设启动分区为(hd0,msdos8)</div><div class="line">grub&gt;set prefix=(hd0,msdos8)/boot/grub</div><div class="line">grub&gt;insmod normal                     //启动normal启动</div><div class="line">grub&gt;normal</div></pre></td></tr></table></figure></li><li><p>重启之后就可以进入Linux系统了，在进入系统之后，可以更新GRUB引导项来恢复GRUB引导</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure></li><li><p>或者重新安装GRUB</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-install /dev/sda // /dev/sda为启动分区位置</div></pre></td></tr></table></figure></li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><p>若系统是用UEFI引导的话，则输入更新GRUB指令<code>sudo update-grub</code>可能无法奏效，这是因为这条命令会更新<code>/boot/grub/grub.cfg</code>文件，但是EFI下的配置文件是在<code>/boot/efi/EFI/ubuntu/grub.cfg</code>路径下，因此需要输入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-mkconfig -o /boot/efi/EFI/ubuntu/grub.cfg</div></pre></td></tr></table></figure><p>  重启便会更新GRUB。</p></li><li><p>有时GRUB引导进入Ubuntu时会提示<code>file &quot;/boot/grub/grubenv&quot; not found</code>或者<code>file &quot;EFI/ubuntu/grubenv&quot; not found</code>，</p><p>  出现这种情况话，进入系统，输入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-editenv /boot/grub/grubenv create</div></pre></td></tr></table></figure><p>  或者</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-editenv /boot/efi/EFI/ubuntu/grubenv create</div></pre></td></tr></table></figure><p>  来创建GRUB环境文件即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是GRUB&quot;&gt;&lt;a href=&quot;#什么是GRUB&quot; class=&quot;headerlink&quot; title=&quot;什么是GRUB&quot;&gt;&lt;/a&gt;什么是GRUB&lt;/h1&gt;&lt;p&gt;GNU GRUB（简称“GRUB”）是一个来自GNU项目的启动引导程序。GRUB 来自 GRand 
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="grub" scheme="http://yluo.name/tags/grub/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Shadowsocks代理及终端使用ss</title>
    <link href="http://yluo.name/2019/01/24/terminal_via_ss/"/>
    <id>http://yluo.name/2019/01/24/terminal_via_ss/</id>
    <published>2019-01-24T15:17:00.000Z</published>
    <updated>2019-11-15T02:42:48.373Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名勤勤恳恳的科研人员，在使用Ubuntu的时候，避免不了要经常科学上网，最好用的莫过于Shadowsocks代理，在此简单介绍下如何在Ubuntu下使用Shadowsocks（以下简称ss）代理以及让终端也使用ss上网。</p><h1 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h1><ul><li>一台境外VPS服务器，并且已经搭载好ss服务</li><li>本机安装了Ubuntu系统（其他Linux发行版操作类似）</li></ul><h1 id="安装shadowsocks-qt5"><a href="#安装shadowsocks-qt5" class="headerlink" title="安装shadowsocks-qt5"></a>安装shadowsocks-qt5</h1><p>shadowsocks-qt5是ss在linux下的gui程序，在终端输入以下指令，添加ss-qt5的PPA源并更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</div><div class="line">sudo apt-get update</div></pre></td></tr></table></figure><p>随后安装ss-qt5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install shadowsocks-qt5</div></pre></td></tr></table></figure><p>之后运行ss-qt5，在里面配置相应的服务器信息后便可以测试连接是否成功。为了可以在浏览器里方便的使用ss，推荐Chrome浏览器下的插件SwitchyOmega，简单介绍以下SwitchOmega的配置。</p><h1 id="安装配置SwitchyOmega"><a href="#安装配置SwitchyOmega" class="headerlink" title="安装配置SwitchyOmega"></a>安装配置SwitchyOmega</h1><p>在Chrome商店或者<a href="">https://www.switchyomega.com/download/</a>下载SwitchyOmega插件并安装到Chrome。</p><p>随后在SwitchOmega配置中新建一个情景模式proxy,协议选择socks 5, 地址127.0.0.1,端口1080（根据ss-qt5中的配置适当修改）。其实这样配置之后启动proxy模式便可以实现科学上网了，但是此时所有的上网流量都需要经过VPS，很多国内的网站，比如百度等也是需要经过代理上网，增加了上网的延时，因此可以配置PAC来实现墙内网站直接连接，墙外网站走代理的完美解决方案。</p><h1 id="配置PAC"><a href="#配置PAC" class="headerlink" title="配置PAC"></a>配置PAC</h1><p>在SwitchyOmega的自动切换模式下，在<code>规则列表规则</code>前面的框打√，再将后面的情景模式设置为proxy，意思是规则列表中的内容，我们使用proxy情景模式。然后规则列表设置中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">规则列表格式： AutoProxy </div><div class="line">规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</div></pre></td></tr></table></figure></p><p>输入上面的网址后请点击“立即更新情景模式”，更新成功后可以看到下面的更新时间和内容，这样设置完成 “规则列表规则” 后就不需要在切换规则中一个一个添加条件了。</p><h1 id="配置终端走ss代理"><a href="#配置终端走ss代理" class="headerlink" title="配置终端走ss代理"></a>配置终端走ss代理</h1><p>终端下走代理需要proxychains这个小软件的帮助，首先安装proxychains</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install proxychains</div></pre></td></tr></table></figure><p>安装完毕后，修改<code>/etc/proxychains.conf</code>中的内容，在最后[ProxyList]选项里填入ss的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socks5 127.0.0.1 1080</div></pre></td></tr></table></figure><p>这样就已经配置成功了，若想让终端的命令走ss代理的话，就在命令前加上<code>proxychains</code>即可。</p><p>验证是否配置成功，首先输入<code>curl ip.gs</code>查看当前未走代理的ip地址，之后输入<code>proxychains curl ip.gs</code>查看走代理的ip地址，若ip地址是VPS的服务器地址，则配置成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名勤勤恳恳的科研人员，在使用Ubuntu的时候，避免不了要经常科学上网，最好用的莫过于Shadowsocks代理，在此简单介绍下如何在Ubuntu下使用Shadowsocks（以下简称ss）代理以及让终端也使用ss上网。&lt;/p&gt;
&lt;h1 id=&quot;预备条件&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="proxy" scheme="http://yluo.name/tags/proxy/"/>
    
      <category term="proxychains" scheme="http://yluo.name/tags/proxychains/"/>
    
  </entry>
  
</feed>
