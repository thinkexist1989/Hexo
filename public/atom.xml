<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DécouVerte</title>
  
  <subtitle>生命不息 折腾不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yluo.name/"/>
  <updated>2019-08-06T02:48:41.325Z</updated>
  <id>http://yluo.name/</id>
  
  <author>
    <name>Yang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu与Windows双系统时间设置问题</title>
    <link href="http://yluo.name/2019/08/01/ubuntu_windows_time/"/>
    <id>http://yluo.name/2019/08/01/ubuntu_windows_time/</id>
    <published>2019-08-01T07:38:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h1><p>现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常时间快8个小时，要么比正常时间慢8个小时。即使利用网络同步时间之后，当切换过系统之后还是会出现时间差的问题。</p><p>这种现象是由于Windows与Ubuntu默认对时间的管理方式不同造成的。我们知道电脑的BIOS里记录着一串时间数据，操作系统就是根据这个数据得到当前时间的。Ubuntu系统使用的是UTC时间（世界协调时），系统会把BIOS里记录的时间看成GMT+0时间，即世界标准时。在Ubuntu系统中有一个设置，是配置当前所在时区的，在中国就会配置为东八区（GMT+8），所以Ubuntu会把BIOS中得到的时间加上8个小时显示出来，随后在系统关机的时候，将当前显示的时间减去8个小时后存入BIOS中。</p><p>而在Windows中，会将BIOS中的时间看做本地时间，直接显示出来，因此，当从Ubuntu切换到Windows时，会出现时间差8个小时的情况。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>最简单的方法就是将Ubuntu下的UTC时间关闭，采用和Window一样的时间管理方式。只需要在Ubuntu终端下运行一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo timedatectrl set-local-utc 1</div></pre></td></tr></table></figure><p>这样便可以使Windows和Ubuntu下的时间同步了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题缘由&quot;&gt;&lt;a href=&quot;#问题缘由&quot; class=&quot;headerlink&quot; title=&quot;问题缘由&quot;&gt;&lt;/a&gt;问题缘由&lt;/h1&gt;&lt;p&gt;现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="linux" scheme="http://yluo.name/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分屏终端Terminator上手</title>
    <link href="http://yluo.name/2019/04/06/terminator_intro/"/>
    <id>http://yluo.name/2019/04/06/terminator_intro/</id>
    <published>2019-04-05T16:18:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来<a href="https://github.com/ljjhome" target="_blank" rel="external">佳神</a>给推荐了一款老外经常使用的终端Terminator，上手了几天的确感觉很方便，尤其是分屏功能，可以在一个终端上像Vim一样分成多个终端，在使用ROS这种需要同时运行多个终端的软件时尤为便利。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>Terminator可以在同一个窗口上分割多个子窗口，每个小窗口运行独立的命令程序。一个父窗口管理多个子窗口，清晰明了知道每个子窗口的运行情况。可以快速自由切换子窗口，并且对子窗口进行最大化和全屏状态。除此之外还有自定义窗口标题、激活标签等等。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu软件源可以直接安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install terminator</div></pre></td></tr></table></figure></p><p>若想要安装最新版，则需要手动添加ppa<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:gnome-terminator</div><div class="line">sudo apt update</div><div class="line">sudo apt install terminator</div></pre></td></tr></table></figure></p><p>安装后，按终端的快捷键<code>Ctrl+Alt+T</code>便可呼出Terminator终端</p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>设置看个人喜好，配色方案什么的可以在设置菜单终端首选项里自由发挥，对于我来说，我一般配置两个：</p><ul><li>背景配置成80%透明，这样在抄写各种东西的时候很方便，可以透过终端看到终端后面的东西。</li><li>在配置文件里添加对256色的支持，这个在18.04下是迷人支持的，但是在14.04下是不支持的，需要手动开启一下，否则像Vim的插件airline之类的颜色是无法显示的。</li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>水平分屏<code>Ctrl+Shift+O</code></li><li>垂直分屏<code>Ctrl+Shift+E</code></li><li>搜索<code>Ctrl+Shift+F</code> </li><li>复制<code>Ctrl+Shift+C</code></li><li>粘贴<code>Ctrl+Shift+V</code></li><li>关闭当前终端<code>Ctrl+Shift+W</code></li><li>退出当前窗口<code>Ctrl+Shift+Q</code></li><li>切换显示当前窗口<code>Ctrl+Shift+X</code></li><li>全屏状态<code>F11</code></li><li>Clear屏幕<code>Ctrl+Shift+G</code></li><li>移动分隔条<code>Ctrl+Shift+方向键</code></li><li>隐藏/显示滚动条<code>Ctrl+Shift+S</code></li></ul><h1 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a>添加右键菜单</h1><p>若想把Terminator添加到右键菜单方便使用，有2种方案：</p><ul><li><code>nautilus-actions</code>工具，貌似在18.04上不好使</li><li><code>fma-config-tool</code>工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来&lt;a href=&quot;https://github.com/ljjhome&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="linux" scheme="http://yluo.name/tags/linux/"/>
    
      <category term="terminator" scheme="http://yluo.name/tags/terminator/"/>
    
  </entry>
  
  <entry>
    <title>Qt的ui编译机制浅析</title>
    <link href="http://yluo.name/2019/03/17/qt_uic/"/>
    <id>http://yluo.name/2019/03/17/qt_uic/</id>
    <published>2019-03-17T15:15:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt的ui编译机制"><a href="#Qt的ui编译机制" class="headerlink" title="Qt的ui编译机制"></a>Qt的ui编译机制</h1><p>利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用ui文件来编写界面，在cpp中编写界面没有在ui文件中利用拖拽的形式来编写界面来更直观。但是Qt是如何将ui文件转换成C++代码却很令我困惑，因此我特意了解了一下Qt的ui编译机制，加深对Qt的理解。</p><h1 id="利用uic来编译-ui文件"><a href="#利用uic来编译-ui文件" class="headerlink" title="利用uic来编译.ui文件"></a>利用uic来编译.ui文件</h1><p>Qt的.ui文件通过Qt Designer设计好以后，利用uic程序将.ui文件中的xml语法转换为c++的类文件，假设ui文件名为<code>mainwindow.ui</code>，在命令行中输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uic mainwindow.ui -o ui_mainwindow.h</div></pre></td></tr></table></figure></p><blockquote><p>注意：若存在多个Qt版本，则可能需要指定相应uic执行路径</p></blockquote><p>通过uic会生成<code>mainwindow.ui</code>文件对应的头文件<code>ui_mainwindow.h</code>，这个<code>ui_mainwindow.h</code>文件的内容大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/********************************************************************************</div><div class="line">** Form generated from reading UI file &apos;mainwindow.ui&apos;</div><div class="line">**</div><div class="line">** Created by: Qt User Interface Compiler version 5.9.5</div><div class="line">**</div><div class="line">** WARNING! All changes made in this file will be lost when recompiling UI file!</div><div class="line">********************************************************************************/</div><div class="line"></div><div class="line">#ifndef UI_MAINWINDOW_H</div><div class="line">#define UI_MAINWINDOW_H</div><div class="line"></div><div class="line">#include &lt;QtCore/QVariant&gt;</div><div class="line">#include &lt;QtWidgets/QAction&gt;</div><div class="line">#include &lt;QtWidgets/QApplication&gt;</div><div class="line">#include &lt;QtWidgets/QButtonGroup&gt;</div><div class="line">#include &lt;QtWidgets/QHeaderView&gt;</div><div class="line">#include &lt;QtWidgets/QMainWindow&gt;</div><div class="line">#include &lt;QtWidgets/QMenuBar&gt;</div><div class="line">#include &lt;QtWidgets/QStatusBar&gt;</div><div class="line">#include &lt;QtWidgets/QToolBar&gt;</div><div class="line">#include &lt;QtWidgets/QWidget&gt;</div><div class="line"></div><div class="line">QT_BEGIN_NAMESPACE</div><div class="line"></div><div class="line">class Ui_MainWindow</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    QMenuBar *menuBar;</div><div class="line">    QToolBar *mainToolBar;</div><div class="line">    QWidget *centralWidget;</div><div class="line">    QStatusBar *statusBar;</div><div class="line"></div><div class="line">    void setupUi(QMainWindow *MainWindow)</div><div class="line">    &#123;</div><div class="line">        if (MainWindow-&gt;objectName().isEmpty())</div><div class="line">            MainWindow-&gt;setObjectName(QStringLiteral(&quot;MainWindow&quot;));</div><div class="line">        MainWindow-&gt;resize(400, 300);</div><div class="line">        menuBar = new QMenuBar(MainWindow);</div><div class="line">        menuBar-&gt;setObjectName(QStringLiteral(&quot;menuBar&quot;));</div><div class="line">        MainWindow-&gt;setMenuBar(menuBar);</div><div class="line">        mainToolBar = new QToolBar(MainWindow);</div><div class="line">        mainToolBar-&gt;setObjectName(QStringLiteral(&quot;mainToolBar&quot;));</div><div class="line">        MainWindow-&gt;addToolBar(mainToolBar);</div><div class="line">        centralWidget = new QWidget(MainWindow);</div><div class="line">        centralWidget-&gt;setObjectName(QStringLiteral(&quot;centralWidget&quot;));</div><div class="line">        MainWindow-&gt;setCentralWidget(centralWidget);</div><div class="line">        statusBar = new QStatusBar(MainWindow);</div><div class="line">        statusBar-&gt;setObjectName(QStringLiteral(&quot;statusBar&quot;));</div><div class="line">        MainWindow-&gt;setStatusBar(statusBar);</div><div class="line"></div><div class="line">        retranslateUi(MainWindow);</div><div class="line"></div><div class="line">        QMetaObject::connectSlotsByName(MainWindow);</div><div class="line">    &#125; // setupUi</div><div class="line"></div><div class="line">    void retranslateUi(QMainWindow *MainWindow)</div><div class="line">    &#123;</div><div class="line">        MainWindow-&gt;setWindowTitle(QApplication::translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, Q_NULLPTR));</div><div class="line">    &#125; // retranslateUi</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">namespace Ui &#123;</div><div class="line">    class MainWindow: public Ui_MainWindow &#123;&#125;;</div><div class="line">&#125; // namespace Ui</div><div class="line"></div><div class="line">QT_END_NAMESPACE</div><div class="line"></div><div class="line">#endif // UI_MAINWINDOW_H</div></pre></td></tr></table></figure></p><p>这个文件就是将.ui文件转换为C++可以看得懂的代码，之后参与Qt源代码的编译，可以看到这个文件中定义了一个<code>Ui_MainWindow</code>类，里面包含了在.ui文件中创建的各种窗口部件的实现，文件最后还定义了一个命名空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace Ui &#123;</div><div class="line">    class MainWindow: public Ui_MainWindow &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个命名空间Ui中包含了一个新类<code>MainWindow</code>，而这个新类继承自<code>Ui_MainWindow</code>类，之后我们便可以在别的文件中利用<code>Ui::MainWindow</code>调用这个ui类，或者直接调用<code>Ui_MainWindow</code>也可以。</p><h1 id="Ui调用"><a href="#Ui调用" class="headerlink" title="Ui调用"></a>Ui调用</h1><p>在Qt项目中，在<code>mainwindow.h</code>中添加Ui命名空间的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace Ui &#123;</div><div class="line">class MainWindow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之后在继承<code>QMainWindow</code>类的对象声明中添加成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ui::MainWindow *ui;</div></pre></td></tr></table></figure></p><p>在<code>mainwindow.cpp</code>的类构造函数中，初始化ui成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ui = new Ui::MainWindow;</div><div class="line">ui-&gt;setupUi(this);</div></pre></td></tr></table></figure></p><p>在类的析构函数中释放ui指针指向的内存空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete ui;</div></pre></td></tr></table></figure></p><p>这样便实现了ui的调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt的ui编译机制&quot;&gt;&lt;a href=&quot;#Qt的ui编译机制&quot; class=&quot;headerlink&quot; title=&quot;Qt的ui编译机制&quot;&gt;&lt;/a&gt;Qt的ui编译机制&lt;/h1&gt;&lt;p&gt;利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="qt" scheme="http://yluo.name/tags/qt/"/>
    
      <category term="uic" scheme="http://yluo.name/tags/uic/"/>
    
  </entry>
  
  <entry>
    <title>Qt高分屏支持</title>
    <link href="http://yluo.name/2019/03/17/qt_high_dpi/"/>
    <id>http://yluo.name/2019/03/17/qt_high_dpi/</id>
    <published>2019-03-17T14:47:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>随着智能手机等电子设备的发展，越来越多的电子设备开始使用上了高分屏，高分屏的确让屏幕的观感更好，但是若没有相应的支持，由于DPI过高，会导致程序字体按钮等看上去特别小，影响使用。而Qt从5.6版本开始对高分屏有了相应的支持，只需要一行代码即可完成对高分屏的支持。</p><h1 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h1><p>在程序的<code>main</code>函数中<code>QApplication</code>对象初始化之前加入如下一行代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);</div></pre></td></tr></table></figure></p><p>这个文件看上去大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &quot;mainwindow.h&quot; //头文件</div><div class="line">#include &lt;QApplication&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //添加高分屏支持</div><div class="line">    QApplication a(argc, argv);</div><div class="line">    MainWindow w;</div><div class="line">    w.show();</div><div class="line"></div><div class="line">    return a.exec();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>添加完上述代码后，若是高分屏的电脑则会将Qt的窗口相应的放大，若不是高分屏的电脑则分辨率不变，这样便实现了对高分屏的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着智能手机等电子设备的发展，越来越多的电子设备开始使用上了高分屏，高分屏的确让屏幕的观感更好，但是若没有相应的支持，由于DPI过高，会导致程序字体按钮等看上去特别小，影响使用。而Qt从5.6版本开始对高分屏有了相应的支持，只需要一行代码即可完成对高分屏的支持。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="qt" scheme="http://yluo.name/tags/qt/"/>
    
      <category term="dpi" scheme="http://yluo.name/tags/dpi/"/>
    
  </entry>
  
  <entry>
    <title>VIM插件推荐</title>
    <link href="http://yluo.name/2019/03/06/vim_intro/"/>
    <id>http://yluo.name/2019/03/06/vim_intro/</id>
    <published>2019-03-06T02:11:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个半入门级程序员，不会使用VIM这种大神级的文本编辑器，总感觉到心里有一丝丝的羞愧～～正好赶上这段空闲时间，便在网上买了一本《Practical VIM》，从头开始对VIM进行一下系统的学习。推荐一下Vim下的牛逼插件。</p><h1 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a>Vundle</h1><blockquote><p>下载地址: <a href="">https://github.com/VundleVim/Vundle.vim</a></p><p>超级方便的插件管理工具，我只能说这个是安装管理所有插件的开始，第一需要安装的就是它！</p></blockquote><h1 id="airline"><a href="#airline" class="headerlink" title="airline"></a>airline</h1><blockquote><p>下载地址：<a href="">https//github.com/vim-airline/vim-airline</a></p></blockquote><p>vim状态提示栏，我认为的必需插件之一！</p><h1 id="YouCompeleteMe"><a href="#YouCompeleteMe" class="headerlink" title="YouCompeleteMe"></a>YouCompeleteMe</h1><blockquote><p>下载地址： <a href="">https://github.com/Valloric/YouCompleteMe</a></p></blockquote><p>超强悍代码补全插件</p><h1 id="tpope"><a href="#tpope" class="headerlink" title="tpope"></a>tpope</h1><p>tpope不是插件，而是一个人，Vim插件的最主要贡献者之一，提供了众多好用插件，看看Github上的star就明白了，再此只推荐几个我经常用的。</p><ul><li>tpope/vim-fugitive</li><li>tpope/vim-surround</li><li>tpope/vim-abolish</li><li>tpope/vim-commentary</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个半入门级程序员，不会使用VIM这种大神级的文本编辑器，总感觉到心里有一丝丝的羞愧～～正好赶上这段空闲时间，便在网上买了一本《Practical VIM》，从头开始对VIM进行一下系统的学习。推荐一下Vim下的牛逼插件。&lt;/p&gt;
&lt;h1 id=&quot;Vundle&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="vim" scheme="http://yluo.name/tags/vim/"/>
    
      <category term="vim plugin" scheme="http://yluo.name/tags/vim-plugin/"/>
    
  </entry>
  
  <entry>
    <title>Vim相关指令汇总</title>
    <link href="http://yluo.name/2019/03/05/vim_cmd/"/>
    <id>http://yluo.name/2019/03/05/vim_cmd/</id>
    <published>2019-03-05T13:19:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h1><ul><li><code>f{char}</code>/<code>F{char}</code> 在行内查找下/上一指定字符，光标停留在查找到的指定字符上，重复<code>;</code>，回退<code>,</code>；</li><li><code>t{char}</code>/<code>T{char}</code> 在行内查找下/上一指定字符，光标停留在查找到的指定字符之前，重复<code>;</code>，回退<code>,</code>；</li><li><code>/pattern&lt;CR&gt;</code>/<code>?pattern&lt;CR&gt;</code> 在文档中查找下/上一处匹配项，重复<code>n</code>，回退<code>N</code>；</li><li><code>*</code> 查找当前光标下的单词，重复<code>n</code>，回退<code>N</code>。</li></ul><h1 id="替换指令"><a href="#替换指令" class="headerlink" title="替换指令"></a>替换指令</h1><ul><li><code>:s/target/replacement</code> 执行一处替换</li><li><code>:s/target/replacement/g</code> 执行一行替换</li><li><code>:%s/target/replacement/g</code> 执行全文替换</li></ul><h1 id="移动指令"><a href="#移动指令" class="headerlink" title="移动指令"></a>移动指令</h1><ul><li><code>j,k</code>/<code>gj,gk</code> 移动实际行/屏幕行</li><li><code>0</code>/<code>g0</code> 移动到实际行/屏幕行行首</li><li><code>^</code>/<code>g^</code> 移动到实际行/屏幕行的第一个非空白字符</li><li><script type="math/tex">`/`g</script> 移动到实际行/屏幕行的行尾</li></ul><h2 id="基于单词移动"><a href="#基于单词移动" class="headerlink" title="基于单词移动"></a>基于单词移动</h2><ul><li><code>w</code> 正向移动到下一单词开头</li><li><code>b</code> 反向移动到当前单词/上一单词的开头</li><li><code>e</code> 正向移动到当前单词/下一单词的结尾</li><li><code>ge</code> 反向移动到上一单词的结尾</li><li><code>W</code> 正向移动到下一字串开头</li><li><code>B</code> 反向移动到当前字串/上一字串的开头</li><li><code>E</code> 正向移动到当前字串/下一字串的结尾</li><li><code>gE</code> 反向移动到上一字串的结尾</li></ul><blockquote><p>简单理解：字串比单词更长，<code>e.g.</code>为4个单词或1个字串，如果要删除的词里有特殊符号，则用字串删除更方便</p></blockquote><h1 id="删除指令"><a href="#删除指令" class="headerlink" title="删除指令"></a>删除指令</h1><ul><li><code>x</code>/<code>dl</code> 删除当前字符</li><li><code>dd</code> 删除当前行</li><li><code>dw</code> 删除当前单词</li><li><code>daw</code> 删除当前文本对象</li><li><code>dap</code> 删除当前段落</li><li><code>&lt;C-h&gt;</code> 插入模式下删除前一个字符（同退格键）(bash也可用)</li><li><code>&lt;C-w&gt;</code> 插入模式下删除前一个单词(bash也可用)</li><li><code>&lt;C-u&gt;</code> 插入模式下删除至行首(bash也可用)</li></ul><h1 id="复制和粘贴指令"><a href="#复制和粘贴指令" class="headerlink" title="复制和粘贴指令"></a>复制和粘贴指令</h1><ul><li><code>y</code> 复制yank<ul><li><code>yw</code> 复制当前单词</li><li><code>yap</code> 复制当前段落</li><li><code>&quot;ayw</code> 复制当前单词到a寄存器</li></ul></li><li><code>p</code> 粘贴put（光标之后）<ul><li><code>&quot;ap</code> 将寄存器a中的内容复制到当前位置</li></ul></li><li><code>P</code> 粘贴（光标之前）</li><li><code>&lt;C-o&gt;{register}</code> 在插入模式下，粘贴寄存器{register}中的内容到当前光标下</li></ul><h1 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h1><ul><li><code>[count]&lt;C-a&gt;</code> 对当前光标上或之后的数值加[count]</li><li><code>[count]&lt;C-x&gt;</code> 对当前光标上或之后的数值减[count]</li></ul><p>注：<code>&lt;C-a&gt;</code>与<code>&lt;C-x&gt;</code>可以对光标之后的第一个数值进行操作，不必将光标移动到数值的位置也可。</p><h1 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h1><ul><li><code>g~</code> 反转大小写<ul><li><code>g~~</code> 反转当前行大小写</li><li><code>g~w</code> 反转当前单词大小写</li><li><code>g~W</code> 反转当前字串大小写</li><li><code>g~ap</code> 反转当前段落大小写</li></ul></li><li><code>gU</code> 转换为大写<ul><li><code>gUU</code> 转换当前行为大写</li><li><code>gUw</code> 转换当前单词为大写</li><li><code>gUap</code> 转换当前段落为大写</li></ul></li><li><code>gu</code> 转换为小写<ul><li><code>guu</code> 转换当前行为小写</li><li><code>guw</code> 转换当前单词为小写</li><li><code>guap</code> 转换当前段落为小写</li></ul></li><li><code>&gt;</code>/<code>&lt;</code> 增加/减小缩进<ul><li><code>&gt;&gt;</code> 缩进当前行</li><li><code>&gt;w</code>/<code>&gt;l</code> 增加当前行缩进（毕竟单词和字符都在一行）</li><li><code>&gt;ap</code> 增加当前段落缩进</li></ul></li><li><code>=</code> 自动缩进</li><li><code>gc</code> 注释/反注释（需安装tpope/vim-commentary插件）<ul><li><code>gcc</code> 注释/反注释当前行</li><li><code>gcap</code> 注释当前段落</li></ul></li><li><code>zz</code> 重绘屏幕，当前行显示在窗口正中<ul><li><code>&lt;C-o&gt;zz</code> 在插入模式下切换普通模式并重绘屏幕，之后重新返回插入模式</li></ul></li><li><code>xp</code> 调换光标之后的两个字符</li><li><code>ddp</code> 调换当前行和它的下一行</li><li><code>yyp</code> 创建当前行副本</li></ul><h1 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h1><ul><li><code>m{char}</code> 负责设置标记</li><li><code>\</code>{char}` 负责跳转到标记</li></ul><h1 id="经典组合"><a href="#经典组合" class="headerlink" title="经典组合"></a>经典组合</h1><ul><li><code>ea</code> 在单词结尾添加</li><li><code>f,dt.</code> 删除后半句（逗号到句号之间内容）</li></ul><h1 id="寄存器说明"><a href="#寄存器说明" class="headerlink" title="寄存器说明"></a>寄存器说明</h1><h2 id="有名寄存器（普通寄存器）"><a href="#有名寄存器（普通寄存器）" class="headerlink" title="有名寄存器（普通寄存器）"></a>有名寄存器（普通寄存器）</h2><ul><li><code>&quot;a</code>~<code>&quot;z</code> </li></ul><h2 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h2><ul><li><code>&quot;&quot;</code>无名寄存器，缺省使用，<code>x</code>，<code>s</code>，<code>d{motion}</code>，<code>y{motion}</code> 都会覆盖其内容；</li><li><code>&quot;0</code> 复制专用寄存器，当使用<code>y{motion}</code>时，会覆盖其内容；</li><li><code>&quot;_</code> 黑洞寄存器，有去无回。</li><li><code>&quot;+</code>/<code>&quot;*</code> 系统剪贴板，有一定区别，但是不加以区分了<ul><li><code>&quot;+p</code> 将系统剪贴板的内容粘贴</li></ul></li><li><code>&quot;=</code> 表达式寄存器</li><li><code>&quot;%</code> 当前文件名（read only）</li><li><code>&quot;#</code> 轮换文件名（read only）</li><li><code>&quot;.</code> 上次插入的文本（read only）</li><li><code>&quot;:</code> 上次执行的Ex命令（read only）</li><li><code>&quot;/</code> 上次查找的模式（可使用<code>:let</code>进行赋值）</li></ul><h1 id="技巧总结"><a href="#技巧总结" class="headerlink" title="技巧总结"></a>技巧总结</h1><ul><li>能够重复，就别用次数。 <code>dw.</code>要优于<code>2dw</code>和<code>d2w</code></li><li>尽量不用光标键，使手指始终位于本位行上</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查找指令&quot;&gt;&lt;a href=&quot;#查找指令&quot; class=&quot;headerlink&quot; title=&quot;查找指令&quot;&gt;&lt;/a&gt;查找指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f{char}&lt;/code&gt;/&lt;code&gt;F{char}&lt;/code&gt; 在行内查找下/上一指定字符，
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="vim" scheme="http://yluo.name/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>利用CMAKE构建Qt和OpenCV项目</title>
    <link href="http://yluo.name/2019/03/05/cmake_qt_opencv/"/>
    <id>http://yluo.name/2019/03/05/cmake_qt_opencv/</id>
    <published>2019-03-05T04:18:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p>Qt是一套完整的跨平台软件开发框架，在开源世界无人不知无人不晓。</p><p>官网地址：<a href="https://qt.io/" target="_blank" rel="external">https://qt.io</a></p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><p>开源计算机视觉库，如何编译OpenCV可以参考我的另一篇博客<a href="http://yluo.name/2019/02/12/cmake_build_opencv/">《利用CMAKE编译OpenCV源码》</a></p><h2 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h2><p>关于什么是CMAKE可以参考我的另一篇博客<a href="http://yluo.name/2019/01/02/cmake/">《利用CMAKE构建和管理软件项目》</a>。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li>项目目录：qt_cmake<ul><li>源文件目录： src<ul><li>文件： </li><li>main.cpp</li><li>mainwindow.cpp</li><li>mainwindow.h</li><li>mainwindow.ui</li></ul></li><li>构建文件目录：build</li></ul></li></ul><h1 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h1><p>新建一个文件夹名为<code>qt_cmake</code>，在文件夹下新建两个文件夹，一个为<code>src</code>，另一个为<code>build</code>。其中<code>src</code>用来放置工程源代码文件，<code>build</code>用来存放构建生成的项目文件。</p><p>在<code>src</code>文件夹下新建<code>main.cpp</code>文件，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;mainwindow.h&quot;</div><div class="line">#include &lt;QApplication&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    QApplication a(argc, argv);</div><div class="line">    MainWindow w;</div><div class="line">    w.show();</div><div class="line"></div><div class="line">    return a.exec();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>利用Qt Creator新建一个Qt设计师界面类，会自动生成3个文件：<code>mainwindow.h</code>，<code>mainwindow.cpp</code>，<code>mainwindow.ui</code>。</p><p>随后打开<code>mainwindow.cpp</code>文件，在其中填入相关的OpenCV代码做测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &quot;mainwindow.h&quot;</div><div class="line">#include &quot;ui_mainwindow.h&quot;</div><div class="line"></div><div class="line">#include &lt;opencv2/opencv.hpp&gt;</div><div class="line"></div><div class="line">MainWindow::MainWindow(QWidget *parent) :</div><div class="line">    QMainWindow(parent),</div><div class="line">    ui(new Ui::MainWindow)</div><div class="line">&#123;</div><div class="line">    ui-&gt;setupUi(this);</div><div class="line"></div><div class="line">    cv::Mat srcImg = cv::imread(&quot;/path/to/your/image.jpg&quot;);</div><div class="line">    cv::imshow(&quot;origin image&quot;,srcImg);</div><div class="line"></div><div class="line">    cv::waitKey(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MainWindow::~MainWindow()</div><div class="line">&#123;</div><div class="line">    delete ui;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在<code>src</code>文件夹下建立CMakeLists.txt文件，在里面建立内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">cmake_minimum_required(VERSION 3.1)</div><div class="line"></div><div class="line">project(qt_cmake)</div><div class="line"></div><div class="line"># Find includes in corresponding build directories</div><div class="line">set(CMAKE_INCLUDE_CURRENT_DIR ON)</div><div class="line"># Instruct cmake to run moc automatically when needed</div><div class="line">set(CMAKE_AUTOMOC ON)</div><div class="line"># Create code from a list of Qt designer ui files</div><div class="line">set(CMAKE_AUTOUIC ON)</div><div class="line"></div><div class="line"># set OpenCV directory</div><div class="line">#set(OpenCV_DIR /usr/share/OpenCV)</div><div class="line"></div><div class="line"># set Qt directory</div><div class="line">#set(CMAKE_PREFIX_PATH /home/think/Qt5.11.1/5.11.1/gcc_64/lib/cmake)</div><div class="line"></div><div class="line"># Find the QtWidgets library</div><div class="line">find_package(Qt5 REQUIRED Widgets Core)</div><div class="line">#find_package(Qt5Widgets CONFIG REQUIRED)</div><div class="line"># Finde OpenCV library</div><div class="line">find_package(OpenCV REQUIRED)</div><div class="line"></div><div class="line"></div><div class="line">message(STATUS &quot;OpenCV library status:&quot;)</div><div class="line">message(STATUS &quot;    version: $&#123;OpenCV_VERSION&#125;&quot;)</div><div class="line">message(STATUS &quot;    libraries: $&#123;OpenCV_LIBS&#125;&quot;)</div><div class="line">message(STATUS &quot;    include path: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)</div><div class="line"></div><div class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</div><div class="line"></div><div class="line">set(SOURCES</div><div class="line">main.cpp</div><div class="line">mainwindow.cpp)</div><div class="line"></div><div class="line">set(FORMS</div><div class="line">mainwindow.ui)</div><div class="line"></div><div class="line">add_executable(main $&#123;SOURCES&#125; $&#123;FORMS&#125;)</div><div class="line">#link_directories($&#123;OpenCV_LIBRARY_DIRS&#125;)</div><div class="line">target_link_libraries(main Qt5::Widgets $&#123;OpenCV_LIBS&#125;)</div></pre></td></tr></table></figure><p>简单介绍一下CMakeLists.txt文件中代码含义</p><ol><li><p>cmake_minimum_required(VERSION 3.1)</p><p> 接下来是设置cmake要求的最低版本号：为3.1。CMAKE在3.1版本以上才支持Qt。</p></li><li><p>project(qt_cmake [CXX] [C] [Java])</p><p> 定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的，这个指令隐式的定义了两个cmake变量:qt_cmake_BINARY_DIR以及qt_cmake_SOURCE_DIR。前者指构建路径，后者指工程路径，即CMakeLists.txt所在的路径。</p><p> 同时cmake系统也帮助我们预定义了PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR变量，他们的值分别跟qt_cmake_BINARY_DIR与qt_cmake_SOURCE_DIR一致。</p><p> 为了统一起见，建议以后直接使用PROJECT_BINARY_DIR，PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。如果使用了qt_cmake_SOURCE_DIR，修改工程名称后，需要同时修改这些变量。</p></li><li><p>set(OpenCV_DIR /usr/share/OpenCV)</p><p> 设置OpenCV_DIR变量，若只安装了一个版本的OpenCV则不用设置这个变量，若存在多个版本的OpenCV则需要利用OpenCV_DIR变量来指定想要的版本。</p></li><li><p>find_package(OpenCV REQUIRED)</p><p> find_package这个指令以被用来在系统中自动查找配置构建工程所需的程序库。在linux和unix类系统下这个命令尤其有用。CMake自带的模块文件里有大半是对各种常见开源库的find_package支持，支持库的种类非常多。</p><p> 当它找到OpenCV程序库之后，就会帮助我们预定义几个变量，OpenCV_FOUND、OpenCV_INCLUDE_DIRS、OpenCV_LIBRARY_DIRS、OpenCV_LIBRARIES，它们分别指是否找到OpenCV，OpenCV的头文件目录，OpenCV的库文件目录，OpenCV的所有库文件列表。</p></li><li><p>include_directories(${OpenCV_INCLUDE_DIRS})</p><p> OpenCV相关包含路径</p></li><li><p>add_executable(main ${SOURCES} ${FORMS})</p><p> 添加可执行文件main</p></li><li><p>target_link_libraries(main Qt5::Widgets ${OpenCV_LIBS})</p><p> 添加动态链接库</p></li></ol><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><ul><li>进入build目录</li><li>执行<code>cmake ../src</code></li><li>执行<code>make</code></li><li>运行程序<code>./main</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;Qt&quot;&gt;&lt;a href=&quot;#Qt&quot; class=&quot;headerlink&quot; title=&quot;Qt&quot;&gt;&lt;/a&gt;Qt&lt;/h
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="opencv" scheme="http://yluo.name/tags/opencv/"/>
    
      <category term="Qt" scheme="http://yluo.name/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>利用CMAKE编译OpenCV源码</title>
    <link href="http://yluo.name/2019/02/12/cmake_build_opencv/"/>
    <id>http://yluo.name/2019/02/12/cmake_build_opencv/</id>
    <published>2019-02-12T14:05:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV是什么"><a href="#OpenCV是什么" class="headerlink" title="OpenCV是什么"></a>OpenCV是什么</h1><p>OpenCV的中文名称是”开源计算机视觉库“（Open Source Computer Vision Library），于1999年由Intel建立，是一个基于开源发行的跨平台计算机视觉库，可以运行在Linux、Windows、Mac OS、Android、iOS、FreeBSD、OpenBSD等操作系统上。OpenCV由一系列C函数和C++类构成，轻量且高效。除了支持C/C++语言编译开发之外，还支持使用C#，Python、Ruby等语言的接口。</p><h1 id="为什么要编译源码"><a href="#为什么要编译源码" class="headerlink" title="为什么要编译源码"></a>为什么要编译源码</h1><p>在OpenCV的官网提供了许多编译好的Release版本的OpenCV二进制文件，但是由于很多人的需求不同，比如OpenCV官网提供的Windows版本是利用MSVC编译的，但是很多人却需要在Windows下使用MinGW编译代码，因此需要Windows下MinGW可以利用的二进制文件，由于OpenCV提供源码，因此可以利用OpenCV的源码编译出各种二进制文件，也可以修改官网的OpenCV源码并编译后为自己所用。</p><h1 id="利用CMAKE编译OpenCV源码"><a href="#利用CMAKE编译OpenCV源码" class="headerlink" title="利用CMAKE编译OpenCV源码"></a>利用CMAKE编译OpenCV源码</h1><p>关于什么是CMAKE可以参考我的另一篇博客<a href="http://yluo.name/2019/01/02/cmake/">《利用CMAKE构建和管理软件项目》</a>。</p><ul><li>安装完CMAKE之后，启动cmake-gui。</li><li>指定OpenCV<strong>源码存放路径</strong>。点击<code>Browse Source</code>按钮，在弹出的对话框中指定OpenCV源码存放路径<code>/path/to/opencv/sources</code>。</li><li>指定OpenCV<strong>构建存放路径</strong>。点击<code>Browse Build</code>按钮，在弹出的对话框中指定OpenCV构建文件存放路径，可随意设置，但不要放在源码路径下。</li><li>点击<code>Configure</code>按钮，进行第一次配置，之后会弹出编译器选择对话框，选择想要生成的项目文件（比如MSVC或者MinGW），可以使用默认的编译器，也可以指定编译器，比如在使用MinGW编译时，可以指定采用GCC和G++来编译OpenCV源码。确认无误点击<code>Finish</code>按钮开始第一次配置过程。</li><li>第一次配置完成后，会在主对话框上出现很多编译选项，勾选<code>Advanced</code>还会显示更多，这些都是默认的编译选项，可以进行修改，比如勾选<code>WITH_OPENGL</code>和<code>WITH_QT</code>选项等。设置完成后还需要进行第二次配置，再次点击<code>Configure</code>按钮，高亮的选项会变成正常（若还是有高亮选择则需要继续修改配置选项然后点击<code>Configure</code>配置）。</li><li>点击<code>Generate</code>生成项目文件，会在<strong>构建存放路径</strong>下生成对应的项目文件，比如VS的.sln解决方案文件，或者MinGW的Makefile文件，于是便可以利用对应的项目文件生成二进制文件了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenCV是什么&quot;&gt;&lt;a href=&quot;#OpenCV是什么&quot; class=&quot;headerlink&quot; title=&quot;OpenCV是什么&quot;&gt;&lt;/a&gt;OpenCV是什么&lt;/h1&gt;&lt;p&gt;OpenCV的中文名称是”开源计算机视觉库“（Open Source Compute
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="opencv" scheme="http://yluo.name/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装时如何分配目录空间</title>
    <link href="http://yluo.name/2019/01/25/ubuntu_partition/"/>
    <id>http://yluo.name/2019/01/25/ubuntu_partition/</id>
    <published>2019-01-25T11:52:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>像我这种主力系统为Linux，但是有些软件还必须在Windows上运行的人，在笔记本上安装Linux与Windows是必不可少的。估计很多用双系统的同学在手动安装Ubuntu或者其他Linux发行版时会像我一样，对如何给Linux的各个目录分配空间头疼不已。因此我下定决心研究了一下这些目录的功能，在此分享给大家。</p><h1 id="Linux的分区和挂载"><a href="#Linux的分区和挂载" class="headerlink" title="Linux的分区和挂载"></a>Linux的分区和挂载</h1><p>Linux的分区和Windows有很大不同。在Windows下，是以<code>盘符</code>来分割各个空间，而且一般操作系统都安装在<code>C盘</code>，剩下的<code>D盘</code>，<code>E盘</code>可以用来存储其他的文件和程序。而Linux不同，Linux有一个最基本的根目录<code>/</code>，所有其他的目录都在这个目录下，根目录<code>/</code>就像是一个大房子，<code>/</code>目录下面的其他目录，比如<code>/etc</code>，<code>/boot</code>等，就像是一个一个功能区，<code>/etc</code>用来存储配置文件，<code>/bin</code>用来放二进制程序，<code>/boot</code>用来放启动文件，<code>/home</code>用来放用户的文件等等。</p><p>Linux的分区和目录的关系是：可以指定一个目录力的东西存在某个分区里，如果不指定，则这个目录里的东西存在上一级目录所在分区中，如果上一级目录页没有特殊制定分期，则再上溯一级目录，以此类推。最后可以上溯到根目录<code>/</code>。所以装系统的时候，其他的都可以不指定，但是一定要指定<code>/</code>目录存放的分区。</p><h1 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h1><p>给Ubuntu一般30G左右就够用了，一般安装的时候我们都给<code>/boot</code>,<code>/swap</code>,<code>/</code>和<code>/home</code>分配一下相应的空间，其余的可以不分配。</p><ul><li><code>/boot</code>为启动分区，分配大小：200MB，分区类型：主分区，分区位置：空间起始位置，用于：Ext4日志文件系统，挂载点：/boot；</li><li><code>swap</code>为交换空间，一般为实际内存2倍左右，但是如果内存足够大，就不需要设置。分配大小：内存×2，分区类型：逻辑分区，分区位置：空间起始位置，用于：交换空间，挂载点：SWAP；</li><li><code>/</code>为根目录，分配大小：至少10G以上，分区类型：逻辑分区，分区位置：空间起始位置，用于：Ex4日志文件系统，挂载点：/；</li><li><code>/home</code>为用户目录，分配大小：剩余所有空间，分区类型：逻辑分区，分区位置：空间起始位置，用于：Ext4日志文件系统，挂载点：/home。</li></ul><h1 id="安装启动引导设备"><a href="#安装启动引导设备" class="headerlink" title="安装启动引导设备"></a>安装启动引导设备</h1><p>Ubuntu采用Grub来引导系统，选择<code>/boot</code>所在分区即可。</p><h1 id="UEFI引导下的配置"><a href="#UEFI引导下的配置" class="headerlink" title="UEFI引导下的配置"></a>UEFI引导下的配置</h1><p>若用UEFI引导系统，则空间分配时无需给<code>/boot</code>分配空间，在安装启动引导设备的选项中，选择<code>Windows Boot Manager</code>所在的分区即可完成引导。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;像我这种主力系统为Linux，但是有些软件还必须在Windows上运行的人，在笔记本上安装Linux与Windows是必不可
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="linux" scheme="http://yluo.name/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Shadowsocks代理及终端使用ss</title>
    <link href="http://yluo.name/2019/01/24/terminal_via_ss/"/>
    <id>http://yluo.name/2019/01/24/terminal_via_ss/</id>
    <published>2019-01-24T15:17:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名勤勤恳恳的科研人员，在使用Ubuntu的时候，避免不了要经常科学上网，最好用的莫过于Shadowsocks代理，在此简单介绍下如何在Ubuntu下使用Shadowsocks（以下简称ss）代理以及让终端也使用ss上网。</p><h1 id="预备条件"><a href="#预备条件" class="headerlink" title="预备条件"></a>预备条件</h1><ul><li>一台境外VPS服务器，并且已经搭载好ss服务</li><li>本机安装了Ubuntu系统（其他Linux发行版操作类似）</li></ul><h1 id="安装shadowsocks-qt5"><a href="#安装shadowsocks-qt5" class="headerlink" title="安装shadowsocks-qt5"></a>安装shadowsocks-qt5</h1><p>shadowsocks-qt5是ss在linux下的gui程序，在终端输入以下指令，添加ss-qt5的PPA源并更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</div><div class="line">sudo apt-get update</div></pre></td></tr></table></figure><p>随后安装ss-qt5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install shadowsocks-qt5</div></pre></td></tr></table></figure><p>之后运行ss-qt5，在里面配置相应的服务器信息后便可以测试连接是否成功。为了可以在浏览器里方便的使用ss，推荐Chrome浏览器下的插件SwitchyOmega，简单介绍以下SwitchOmega的配置。</p><h1 id="安装配置SwitchyOmega"><a href="#安装配置SwitchyOmega" class="headerlink" title="安装配置SwitchyOmega"></a>安装配置SwitchyOmega</h1><p>在Chrome商店或者<a href="">https://www.switchyomega.com/download/</a>下载SwitchyOmega插件并安装到Chrome。</p><p>随后在SwitchOmega配置中新建一个情景模式proxy,协议选择socks 5, 地址127.0.0.1,端口1080（根据ss-qt5中的配置适当修改）。其实这样配置之后启动proxy模式便可以实现科学上网了，但是此时所有的上网流量都需要经过VPS，很多国内的网站，比如百度等也是需要经过代理上网，增加了上网的延时，因此可以配置PAC来实现墙内网站直接连接，墙外网站走代理的完美解决方案。</p><h1 id="配置PAC"><a href="#配置PAC" class="headerlink" title="配置PAC"></a>配置PAC</h1><p>在SwitchyOmega的自动切换模式下，在<code>规则列表规则</code>前面的框打√，再将后面的情景模式设置为proxy，意思是规则列表中的内容，我们使用proxy情景模式。然后规则列表设置中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">规则列表格式： AutoProxy </div><div class="line">规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</div></pre></td></tr></table></figure></p><p>输入上面的网址后请点击“立即更新情景模式”，更新成功后可以看到下面的更新时间和内容，这样设置完成 “规则列表规则” 后就不需要在切换规则中一个一个添加条件了。</p><h1 id="配置终端走ss代理"><a href="#配置终端走ss代理" class="headerlink" title="配置终端走ss代理"></a>配置终端走ss代理</h1><p>终端下走代理需要proxychains这个小软件的帮助，首先安装proxychains</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install proxychains</div></pre></td></tr></table></figure><p>安装完毕后，修改<code>/etc/proxychains.conf</code>中的内容，在最后[ProxyList]选项里填入ss的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socks5 127.0.0.1 1080</div></pre></td></tr></table></figure><p>这样就已经配置成功了，若想让终端的命令走ss代理的话，就在命令前加上<code>proxychains</code>即可。</p><p>验证是否配置成功，首先输入<code>curl ip.gs</code>查看当前未走代理的ip地址，之后输入<code>proxychains curl ip.gs</code>查看走代理的ip地址，若ip地址是VPS的服务器地址，则配置成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名勤勤恳恳的科研人员，在使用Ubuntu的时候，避免不了要经常科学上网，最好用的莫过于Shadowsocks代理，在此简单介绍下如何在Ubuntu下使用Shadowsocks（以下简称ss）代理以及让终端也使用ss上网。&lt;/p&gt;
&lt;h1 id=&quot;预备条件&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="proxy" scheme="http://yluo.name/tags/proxy/"/>
    
      <category term="proxychains" scheme="http://yluo.name/tags/proxychains/"/>
    
  </entry>
  
  <entry>
    <title>GRUB简介与配置</title>
    <link href="http://yluo.name/2019/01/24/grub/"/>
    <id>http://yluo.name/2019/01/24/grub/</id>
    <published>2019-01-24T15:17:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是GRUB"><a href="#什么是GRUB" class="headerlink" title="什么是GRUB"></a>什么是GRUB</h1><p>GNU GRUB（简称“GRUB”）是一个来自GNU项目的启动引导程序。GRUB 来自 GRand Unified Bootloader 的缩写。它的功能是在启动时从 BIOS 接管掌控、加载自身、加载 Linux 内核到内存，然后再把执行权交给内核。一旦内核开始掌控，GRUB 就完成了它的任务，也就不再需要了。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。</p><p>简单的说，如果你的电脑上需要同时安装多个操作系统，比如Windows，Ubuntu，Centos，RHEL等（各种LINUX发行版）的话，就可以利用GRUB来作为启动引导程序，来引导系统启动。</p><h1 id="GRUB菜单"><a href="#GRUB菜单" class="headerlink" title="GRUB菜单"></a>GRUB菜单</h1><p>GRUB 菜单的功能是当默认的内核不是想要的时，允许用户从已经安装的内核中选择一个进行引导。通过上下箭头键允许你选中想要的内核，敲击回车键会使用选中的内核继续引导进程。</p><p>GRUB 菜单也提供了超时机制，因此如果用户没有做任何选择，GRUB 就会在没有用户干预的情况下使用默认内核继续引导。敲击键盘上除了回车键之外的任何键会停止终端上显示的倒数计时器。立即敲击回车键会使用默认内核或者选中的内核继续引导进程。</p><h1 id="GRUB配置"><a href="#GRUB配置" class="headerlink" title="GRUB配置"></a>GRUB配置</h1><p>GRUB的一个重要的特性是安装它不需依附一个操作系统，但是这种安装需要一个Linux/Windows副本。由于单独工作，GRUB实质上是一个微型系统，通过链式启动的方式，它可以启动所有安装的主流操作系统。</p><p>因此GRUB通常在Linux系统下进行配置。<code>grub.cfg</code>文件是GRUB配置文件。它由<code>grub-mkconfig</code>程序根据用户的配置使用一组主配置文件以及GRUB默认文件而生成。<code>/boot/grub/grub.cfg</code>文件在Linux安装时会初次生成，安装新内核时又会重新生成。但是如果需要手动配置GRUB，则不能修改这个文件，而是修改<code>/etc/default/grub</code>文件，这个文件的内容大致如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">GRUB_DEFAULT=0</div><div class="line">GRUB_HIDDEN_TIMEOUT=0</div><div class="line">GRUB_TIMEOUT=10</div><div class="line">GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`</div><div class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</div><div class="line">GRUB_CMDLINE_LINUX=&quot;&quot;</div><div class="line"></div><div class="line"># Uncomment to enable BadRAM filtering, modify to suit your needs</div><div class="line"># This works with Linux (no patch required) and with any kernel that obtains</div><div class="line"># the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)</div><div class="line">#GRUB_BADRAM=&quot;0x01234567,0xfefefefe,0x89abcdef,0xefefefef&quot;</div><div class="line"></div><div class="line"># Uncomment to disable graphical terminal (grub-pc only)</div><div class="line">#GRUB_TERMINAL=console</div><div class="line"></div><div class="line"># The resolution used on graphical terminal</div><div class="line"># note that you can use only modes which your graphic card supports via VBE</div><div class="line"># you can see them in real GRUB with the command `vbeinfo&apos;</div><div class="line">GRUB_GFXMODE=1366x768</div><div class="line"></div><div class="line"># Uncomment if you don&apos;t want GRUB to pass &quot;root=UUID=xxx&quot; parameter to Linux</div><div class="line">#GRUB_DISABLE_LINUX_UUID=true</div><div class="line"></div><div class="line"># Uncomment to disable generation of recovery mode menu entries</div><div class="line">#GRUB_DISABLE_RECOVERY=&quot;true&quot;</div><div class="line"></div><div class="line"># Uncomment to get a beep at grub start</div><div class="line">#GRUB_INIT_TUNE=&quot;480 440 1&quot;</div></pre></td></tr></table></figure><p>在修改完<code>/etc/default/grub</code>文件之后，需要在终端运行<code>update-grub</code>来更新<code>/boot/grub/grub.cfg</code>文件，这样就完成了对GRUB的配置。</p><p>下面介绍几个本人比较常用的GRUB配置。</p><h2 id="修改开机默认引导上次选择的操作系统"><a href="#修改开机默认引导上次选择的操作系统" class="headerlink" title="修改开机默认引导上次选择的操作系统"></a>修改开机默认引导上次选择的操作系统</h2><ul><li><p>打开<code>/etc/default/grub</code>文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/default/grub</div></pre></td></tr></table></figure></li><li><p>修改并加入如下代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GRUB_DEFAULT=saved</div><div class="line">GRUB_SAVEDEFAULT=true</div></pre></td></tr></table></figure></li><li><p>更新<code>/boot/grub/grub.cfg</code>文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure></li></ul><h2 id="修改GRUB开机引导画面"><a href="#修改GRUB开机引导画面" class="headerlink" title="修改GRUB开机引导画面"></a>修改GRUB开机引导画面</h2><p>GRUB最爽的就是开机引导画面的定制，可以下载各种大神制作的主题，使开机画面美轮美奂。</p><ul><li><p>下载GRUB主题，将主题下的文件夹中的内容复制到<code>/boot/grub/themes</code>下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp -R /path/to/your_theme /boot/grub/themes</div></pre></td></tr></table></figure></li><li><p>修改<code>/etc/default/grub</code>文件</p><ol><li><p>将<code>GRUB_GFXMODE</code>修改为自己屏幕分辨率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRUB_GFXMODE=1366*768</div></pre></td></tr></table></figure></li><li><p>修改或添加一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRUB_THEME=/boot/grub/themes/your_theme/theme.txt</div></pre></td></tr></table></figure></li><li><p>更新<code>/boot/grub/grub.cfg</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure></li></ol></li></ul><h1 id="GRUB引导修复"><a href="#GRUB引导修复" class="headerlink" title="GRUB引导修复"></a>GRUB引导修复</h1><p>当<code>/boot/grub/grub.conf</code>配置文件丢失, 或者关键配置出现错误, 或者MBR、UEFI记录的引导程序遭到破坏时, Linux主机启动后可能只会出现“grub&gt;”的提示符，无法完成进一步的系统启动过程。</p><p>这表示你的grub2的配置文件损坏，GRUB找不到Ubuntu系统的引导项. 从而进入修复模式了(grub rescue), 也称救援模式。在救援模式下只有很少的命令可以用: set，ls，insmod，root，prefix。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set</td><td>查看环境变量</td></tr><tr><td>ls</td><td>查看设备</td></tr><tr><td>insmod</td><td>加载模块</td></tr><tr><td>root</td><td>指定用于启动系统的分区，设置GRUB启动分区</td></tr><tr><td>prefix</td><td>设定GRUB启动路径</td></tr></tbody></table></div><h2 id="进入GRUB救援模式后手动引导系统"><a href="#进入GRUB救援模式后手动引导系统" class="headerlink" title="进入GRUB救援模式后手动引导系统"></a>进入GRUB救援模式后手动引导系统</h2><ul><li>利用<code>ls</code>命令列出所有磁盘分区，查找启动分区，一般情况下EFI启动分区大小为500M左右，Linux的<code>/boot</code>分区为200M～500M。</li><li><p>执行以下命令来手动引导系统</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grub&gt;set root=(hd0,msdos8) //假设启动分区为(hd0,msdos8)</div><div class="line">grub&gt;set prefix=(hd0,msdos8)/boot/grub</div><div class="line">grub&gt;insmod normal                     //启动normal启动</div><div class="line">grub&gt;normal</div></pre></td></tr></table></figure></li><li><p>重启之后就可以进入Linux系统了，在进入系统之后，可以更新GRUB引导项来恢复GRUB引导</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo update-grub</div></pre></td></tr></table></figure></li><li><p>或者重新安装GRUB</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-install /dev/sda // /dev/sda为启动分区位置</div></pre></td></tr></table></figure></li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><p>若系统是用UEFI引导的话，则输入更新GRUB指令<code>sudo update-grub</code>可能无法奏效，这是因为这条命令会更新<code>/boot/grub/grub.cfg</code>文件，但是EFI下的配置文件是在<code>/boot/efi/EFI/ubuntu/grub.cfg</code>路径下，因此需要输入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-mkconfig -o /boot/efi/EFI/ubuntu/grub.cfg</div></pre></td></tr></table></figure><p>  重启便会更新GRUB。</p></li><li><p>有时GRUB引导进入Ubuntu时会提示<code>file &quot;/boot/grub/grubenv&quot; not found</code>或者<code>file &quot;EFI/ubuntu/grubenv&quot; not found</code>，</p><p>  出现这种情况话，进入系统，输入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-editenv /boot/grub/grubenv create</div></pre></td></tr></table></figure><p>  或者</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo grub-editenv /boot/efi/EFI/ubuntu/grubenv create</div></pre></td></tr></table></figure><p>  来创建GRUB环境文件即可。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是GRUB&quot;&gt;&lt;a href=&quot;#什么是GRUB&quot; class=&quot;headerlink&quot; title=&quot;什么是GRUB&quot;&gt;&lt;/a&gt;什么是GRUB&lt;/h1&gt;&lt;p&gt;GNU GRUB（简称“GRUB”）是一个来自GNU项目的启动引导程序。GRUB 来自 GRand 
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="grub" scheme="http://yluo.name/tags/grub/"/>
    
  </entry>
  
  <entry>
    <title>利用CMAKE构建和管理软件项目</title>
    <link href="http://yluo.name/2019/01/02/cmake/"/>
    <id>http://yluo.name/2019/01/02/cmake/</id>
    <published>2019-01-02T02:02:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMAKE是什么"><a href="#CMAKE是什么" class="headerlink" title="CMAKE是什么"></a>CMAKE是什么</h1><p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。</p><p>对于一个大型软件，其编译、维护是一个复杂而耗时的过程。它涉及到大量的文件、目录，这些文件可能是在不同的时间、由不同的人、在不同的地方分别写的，其中一些是程序，有些是数据，有些是文档，有些是衍生文件。甚至参与开发的人员也不一定清楚所有文件的细节，包括如何处理它们。此外，构成软件的文件数目可能达到成百上千，甚至成千上万个，开发过程中当修改了少量几个文件后，往往只需要重新编译、生成少数几个文件。有效地描述这些文件之间的依赖关系以及处理命令，当个别文件改动后仅执行必要的处理，而不必重复整个编译过程，可以大大提高软件开发的效率。</p><h1 id="为什么用CMAKE"><a href="#为什么用CMAKE" class="headerlink" title="为什么用CMAKE"></a>为什么用CMAKE</h1><p>如果你之前有过维护软件包的构建和安装的经验，你就会对CMake有兴趣。当前很多项目都可以在Linux下用Makefile和在Windows下用Visual Studio进行编译；这要求开发者在对应的系统下保持构建工具的更新，并且不同系统的构建行为保持一致；如果再引入XCode，这需要更多的构建工具，这样会是一个问题。如果在此基础上引入可选组件，比如如果系统上有libjpeg，项目就支援JPEG，这会造成更大的麻烦。CMake提供了一个简单的，易于理解的文件格式来解决上述问题。如果一个项目有多个开发者参与，或者这个项目有多个目标平台；那么不可避免的需要在多台PC上进行构建，不同的PC在开发环境上会有差异。</p><ul><li>自动进行项目构建所需的program、library、header file的查找能力；</li><li>在source tree以外进行构建的能力；</li><li>为Qt moc，SWIG等自动产生复杂的自定义命令的能力；</li><li>在configuration阶段进行可选组件定制的能力；</li><li>自动从简单文件文件产生workspace和project的能力；</li><li>配置生成静态库/动态库的能力；</li><li>自动产生文件依赖，支持并行编译；</li></ul><h1 id="CMAKE基本语法"><a href="#CMAKE基本语法" class="headerlink" title="CMAKE基本语法"></a>CMAKE基本语法</h1><p>build的过程由每个目录下的名为<code>CMakeFileLists.txt</code>的文件组成的一系列文件列表所控制；<br><code>CMakeFileLists.txt</code>文件由CMake语句进行项目描述，CMake语句的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command(args...)</div></pre></td></tr></table></figure><ul><li><code>command</code>是命令的名字，CMake是不区分大小写的；</li><li><p><code>args</code>是一系列由空格分隔的参数，如果参数中有空格，参数需要用双引号引起来；</p></li><li><p>变量被引用的格式是<code>${VAR}</code>;</p></li><li>多个参数可以使用<code>set</code>来使之构成一个list。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set(Foo a b c)</div></pre></td></tr></table></figure><p>这样设置的结果是<code>Foo</code>的值是 a b c;</p><p>CMake可以直接访问系统环境变量和Windows注册表；<br>访问系统环境变量的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$Env&#123;ARG&#125;</div></pre></td></tr></table></figure><p>访问Windows注册表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[HKEY_CURRENT_USER\\Software\\path1\\path2;key]</div></pre></td></tr></table></figure><h1 id="如何运行CMAKE"><a href="#如何运行CMAKE" class="headerlink" title="如何运行CMAKE"></a>如何运行CMAKE</h1><p>举一个简单的例子，在文件夹下建立一个C语言源文件<code>main.c</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">  float sum;</div><div class="line">  int i;</div><div class="line"></div><div class="line">  for(int i=0;i&lt;100;i++)</div><div class="line">          sum += 0.1;</div><div class="line"></div><div class="line">  printf(&quot;sum:%f\n&quot;,sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在文件夹下建立<code>CMakeLists.txt</code>文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cmake_minimum_required(VERSION 2.8)</div><div class="line">add_executable(Main main.c)</div></pre></td></tr></table></figure><p>在终端运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$cmake .</div></pre></td></tr></table></figure><p>则可以看到在文件夹下生成了Makefile文件，紧接着运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$make</div></pre></td></tr></table></figure></p><p>在文件夹下看到生成了可执行文件<code>Main</code>，于是在终端运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./Main</div></pre></td></tr></table></figure></p><p>可以看到终端运行了程序并输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sum:10.000002</div></pre></td></tr></table></figure></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>强烈推荐一本CMAKE圣经《Mastering CMAKE》，CMAKE的强大之处只有一点点的学习体会才能感受到，我也会在今后的学习中慢慢领悟CMAKE的精髓，用CMAKE来管理构建我自己的项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CMAKE是什么&quot;&gt;&lt;a href=&quot;#CMAKE是什么&quot; class=&quot;headerlink&quot; title=&quot;CMAKE是什么&quot;&gt;&lt;/a&gt;CMAKE是什么&lt;/h1&gt;&lt;p&gt;CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="Makefile" scheme="http://yluo.name/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络初探（四）：网络里的中间商—正向代理与反向代理</title>
    <link href="http://yluo.name/2018/12/29/network_4/"/>
    <id>http://yluo.name/2018/12/29/network_4/</id>
    <published>2018-12-29T11:46:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>知乎网络大神<a href="https://www.zhihu.com/people/chexiaopang/activities" target="_blank" rel="external">车小胖</a>对于<strong>正向代理</strong>与<strong>反向代理</strong>做了一个有趣的类比：</p><blockquote><p>很久以前，老王去饭店吃饭，需要先到饭店，七荤八素点好菜，坐等饭菜上桌，然后大快朵颐，不亦乐乎。有了第三方订餐外卖平台，老王懒得动身前往饭店，老王打个电话或用APP，先选好某个饭店，再点好菜，外卖小哥会送上门来。这种模式被起名为<strong>正向代理（Forward Proxy）</strong><br>由于某个品牌的饭店口碑特别好，食客络绎不绝涌入，第三方订餐电话也不绝于耳，但是限于饭店接待能力有限，无法提供及时服务，很多食客等得不耐烦了，纷纷铩羽而归，饭店老总看着煮熟的鸭子飞走了，心疼不已。痛定思痛，老总又成立了几个连锁饭店，形成一个集群，对外提供统一标准的菜品服务，电话订餐电话400-xxx-7777，当食客涌入饭店总台，总台将食客用大巴运到各个连锁店，这样食客既不需要排队，各连锁店都能高速运转起来，一举两得，老总乐开了花，并为此种运作模式起名为<strong>反向代理（Reverse Proxy）</strong>。反向代理在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。<br>  <br> <img src="/images/forward_proxy.svg" alt="Forward Proxy"></p><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p><p><img src="/images/reverse_proxy.svg" alt="Reverse Proxy"></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。</p><p>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。</p><p>正向代理和反向代理最关键的两点区别：</p><ul><li><p>是否指定目标服务器</p></li><li><p>客户端是否要做设置</p></li></ul><p>正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。</p><p>从用途上来区分：</p><ul><li>正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率</li><li>反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能</li></ul><p>从安全性来讲：</p><ul><li>正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务</li><li>反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</p><p>从上面的介绍也就可以猜出来正向代理的至少一个功能（比如科学上网），也即：</p><blockquote><p>用户A无法访问facebook，但是能访问服务器B，而服务器B可以访问facebook。于是用户A访问服务器B，通过服务器B去访问facebook，，服务器B收到请求后，去访问facebook，facebook把响应信息返回给服务器B，服务器B再把响应信息返回给A。这样，通过代理服务器B，就实现了翻墙。</p></blockquote><p>从上面的介绍也可以猜出来反向代理的至少一个功能（比如负载均衡），也即：</p><blockquote><p>假设用户A访问 <strong><a href="http://www.somesite.com/something.html" target="_blank" rel="external">http://www.somesite.com/something.html</a></strong>，但<strong><a href="">www.somesite.com</a></strong>上并不存在<strong>something.html</strong>页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道<strong>something.html</strong>页面究竟位于哪台机器上。当我们请求 <strong><a href="">www.baidu.com</a> </strong>的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<strong><a href="">www.baidu.com</a> </strong>就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。</p></blockquote><p>当然反向代理的作用还有很多，这里简单列举一下：</p><ul><li>保护和隐藏原始资源服务器</li><li>加密和SSL加速</li><li>负载均衡</li><li>缓存静态内容</li><li>压缩</li><li>减速上传</li><li>安全</li><li>外网发布</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，正向代理代理的对象是客户端，反向代理代理的对象是服务端；正向代理隐藏了真实的客户端，反向代理隐藏了真实的服务端。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知乎网络大神&lt;a href=&quot;https://www.zhihu.com/people/chexiaopang/activities&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;车小胖&lt;/a&gt;对于&lt;strong&gt;正向代理&lt;/strong&gt;与&lt;strong
      
    
    </summary>
    
      <category term="Computer Network" scheme="http://yluo.name/categories/Computer-Network/"/>
    
    
      <category term="network" scheme="http://yluo.name/tags/network/"/>
    
      <category term="proxy" scheme="http://yluo.name/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>使用make编译LaTeX文档</title>
    <link href="http://yluo.name/2018/12/20/make_latex/"/>
    <id>http://yluo.name/2018/12/20/make_latex/</id>
    <published>2018-12-20T08:37:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>由于一直使用Ubuntu作为主力系统，很多代码编写的工作都用VIM来完成，VIM这个牛逼闪闪的编辑器的确装逼范十足，让人爱不释手，导致我恨不得将所有的编辑器都抛弃掉，全部采用VIM来编辑（除了WORD之外还真没什么不可以）。VIM下来编辑LaTeX文档自然不在话下，利用vim-latex插件可以轻松实现LaTeX文档的编写与编译。但是这个插件也有一定的缺陷——不能利用Magic Comments自动识别编译引擎来编译LaTeX文档，默认情况下<code>\ll</code>快捷键只能支持一种编译引擎！这就让经常需要在pdflatex和xelatex之间切换的我很尴尬，每次编写完文档，都需要切到终端去利用不用的命令行来实现LaTeX文档的编译工作。为了充分展现我懒惰的一面，打算采用make来编译LaTeX文档，这样在编写好Makefile之后，我只需要在终端输入<code>make</code>就可以实现文档的全自动编译，简直不要太美妙！</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在编写Makefile之前，请确认你的系统环境是否满足以下条件：</p><ul><li>TeX环境，可以是TeX Live或者MiKTeX；</li><li>GNU make工具，在Linux下一般默认已安装（或利用apt install make安装），若在Windows下则需要安装minGW。</li></ul><p>make命令在执行时，需要一个Makefile文件，以告诉make命令需要如何去编译和链接程序，接下来我就会编写一个针对于xelatex的Makefile文件。</p><h1 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h1><p>Makefile文件的编写规则大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">target ... : prerequisites ...</div><div class="line">command</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure><p><strong>target</strong>：可以是一个目标文件，也可以是一个执行文件，还可以是一个标签（伪目标）</p><p><strong>prerequisites</strong>：生成该target所依赖的文件或target</p><p><strong>command</strong>：该target要执行的命令（任意的shell命令）</p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件， 其生成规则定义在command中。说白一点就是说:prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会执行。</p><p>这就是Makefile的规则，也是Makefile最核心的内容。</p><h1 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">LATEX=xelatex #定义变量，指定编译引擎</div><div class="line">LATEXOPT=--shell-escape #定义变量 指定编译参数</div><div class="line">NONSTOP=--interaction=nonstopmode #定义变量 指定编译模式</div><div class="line"></div><div class="line">LATEXMK=latexmk #采用latexmk来编译latex文档</div><div class="line">LATEXMKOPT=-pdf #latexmk参数 输出pdf</div><div class="line">CONTINUOUS=-pvc #若加入-pvc选项则可以持续检测文件改动并实时显示</div><div class="line"></div><div class="line">MAIN=main #根文件名称</div><div class="line">SOURCES=$(MAIN).tex Makefile </div><div class="line">FIGURES := $(shell find figures/* movies/* -type f)</div><div class="line"></div><div class="line">all:    $(MAIN).pdf</div><div class="line"></div><div class="line">#$(MAIN).pdf: $(MAIN).tex $(SOURCES) $(FIGURES)</div><div class="line">#$(LATEXMK) $(LATEXMKOPT) $(CONTINUOUS) \</div><div class="line">#            -pdflatex=&quot;$(LATEX) $(LATEXOPT) $(NONSTOP) %O %S&quot; $(MAIN)</div><div class="line"></div><div class="line">$(MAIN).pdf: $(MAIN).tex $(SOURCES) $(FIGURES)</div><div class="line">$(LATEXMK) $(LATEXMKOPT)  \</div><div class="line">            -pdflatex=&quot;$(LATEX) $(LATEXOPT) $(NONSTOP) %O %S&quot; $(MAIN)</div><div class="line"></div><div class="line"></div><div class="line">force:</div><div class="line">rm $(MAIN).pdf</div><div class="line">$(LATEXMK) $(LATEXMKOPT) $(CONTINUOUS) \</div><div class="line">            -pdflatex=&quot;$(LATEX) $(LATEXOPT) %O %S&quot; $(MAIN)</div><div class="line"></div><div class="line">clean:</div><div class="line">$(LATEXMK) -C $(MAIN)</div><div class="line">rm -f $(MAIN).pdfsync</div><div class="line">rm -rf *~ *.tmp</div><div class="line">rm -f *.bbl *.blg *.aux *.end *.fls *.log *.out *.fdb_latexmk</div><div class="line"></div><div class="line">once:</div><div class="line">$(LATEXMK) $(LATEXMKOPT) -pdflatex=&quot;$(LATEX) $(LATEXOPT) %O %S&quot; $(MAIN)</div><div class="line"></div><div class="line">debug:</div><div class="line">$(LATEX) $(LATEXOPT) $(MAIN)</div><div class="line"></div><div class="line">.PHONY: clean force once all</div></pre></td></tr></table></figure><h1 id="make编译"><a href="#make编译" class="headerlink" title="make编译"></a>make编译</h1><p>把上面的内容放入Makefile文件，放在LaTeX文件夹下，根据需要修改文件头部定义的变量，可以更换编译引擎，编译参数和编译模式。之后在终端下输入<code>make</code>即可完成编译。</p><p>若想要删除目录下生成的中间文件，则输入<code>make clean</code>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于一直使用Ubuntu作为主力系统，很多代码编写的工作都用VIM来完成，VIM这个牛逼闪闪的编辑器的确装逼范十足，让人爱不释手，导致我恨不得将所有的编辑器都抛弃掉，全部采用VIM来编辑（除了WORD之外还真没什么不可以）。VIM下来编辑LaTeX文档自然不在话下，利用vi
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="make" scheme="http://yluo.name/tags/make/"/>
    
      <category term="makefile" scheme="http://yluo.name/tags/makefile/"/>
    
      <category term="latex" scheme="http://yluo.name/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络初探（三）：路由里的小搬运工—NAT</title>
    <link href="http://yluo.name/2018/09/07/network_3/"/>
    <id>http://yluo.name/2018/09/07/network_3/</id>
    <published>2018-09-07T05:05:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>现在由于我们每个人的手机、电脑、平板电脑等设备都有接入互联网的要求，可是我们家里通常只有一路网线入户，为了解决这个问题我们家里现在都会购买一台无线路由器，将这根入户网线连接到路由器的WAN口之后，便可以通过路由器上的LAN口或者WIFI接入来上网了。这时候我们查看一下我们设备的IP地址，通常为<code>192.168.1.110</code>这种形式，可是我们登陆<a href="http://ip138.com" target="_blank" rel="external">ip138.com</a>这种IP查询网站时，显示的却是类似<code>96.46.185.33</code>这样的IP，为什么本机显示的IP地址和IP查询网站上显示的IP不一样呢？到底是哪里出现了问题？其实这两个IP显示的都没错，这是因为我们路由器有一个小搬运工—NAT的存在，可是NAT的功能是什么？存在的意义是什么？这就要先从我们的IP地址说起。</p><h1 id="公网IP与私有IP"><a href="#公网IP与私有IP" class="headerlink" title="公网IP与私有IP"></a>公网IP与私有IP</h1><p>之前的博客里提过，IP地址是一串32比特的字符串，每8比特用一个<code>.</code>隔开，可表示为xx.xx.xx.xx，IP地址又有公网IP和私有IP之分，负责分配IP地址的机构预留了三块专有地址，作为私有IP地址供内部组网使用：</p><ul><li>A类：10.0.0.0～10.255.255.255/8</li><li>B类：172.16.0.0～172.31.255.255/12</li><li>C类：192.168.0.0～192.168.255.255/16</li></ul><p>IP地址是互联网设备的身份证，也就是每个接入互联网的设备都必须具备唯一的IP地址，这个唯一的IP地址就是公网IP。具备公网IP地址的设备就像是有了具体的门牌号，我们可以直接利用公网IP来和这个设备进行通信。可是IP地址是珍贵的资源，全世界只有20亿左右的IP地址资源，若以现在的互联网发展速度，是无法为每一台设备都分配一个公网IP地址的。但是由于互联网通信协议的要求，每个接入互联网的设备必须具备唯一的公网IP，因此为了解决这个冲突，NAT就应运而生了。</p><h1 id="什么是NAT"><a href="#什么是NAT" class="headerlink" title="什么是NAT"></a>什么是NAT</h1><p>NAT(Network Address Translation，网络地址转换) ，用于将一整个内部网络通过一个公网IP连接进互联网。我们家里的路由器都具备NAT的功能，也就是将我们分配给我们的设备私有IP转换为公网IP接入互联网，从而实现只具备私有IP的设备也可以接入互联网的功能。</p><h1 id="NAT工作过程"><a href="#NAT工作过程" class="headerlink" title="NAT工作过程"></a>NAT工作过程</h1><p>NAT的工作开始要从用户连接上路由器之后开始说起。当用户A利用手机WIFI连接上路由器后，通过路由器内置的DHCP服务器，会自动为用户分配以下信息：</p><ul><li>IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>缺省网关：192.168.1.1</li><li>DNS服务器：192.168.1.1</li></ul><p>用户A的手机在局域网下的IP(192.168.1.100)是唯一的，但这个IP是私有IP地址，无法直接连接互联网，可是现在用户A在手机上打开了浏览器，想要访问公网IP为2.2.2.2的服务器上的网页，于是乎一个隐藏在路由器内部的小搬运工—NAT即将登场了。</p><h2 id="1-客户端的IP报文发送给路由器"><a href="#1-客户端的IP报文发送给路由器" class="headerlink" title="1 客户端的IP报文发送给路由器"></a>1 客户端的IP报文发送给路由器</h2><p>用户A的手机浏览器会填写一个包含以下信息的报文发送给路由器：</p><ul><li>目的地：2.2.2.2</li><li>目的端口：80</li><li>发送方地址：192.168.1.100</li><li>发送方端口：1234</li></ul><h2 id="2-小搬运工NAT出场"><a href="#2-小搬运工NAT出场" class="headerlink" title="2 小搬运工NAT出场"></a>2 小搬运工NAT出场</h2><p>路由器收到了从192.168.1.100这个IP发送过来的报文，可是它不能直接将这个报文发送到互联网中，因为192.168.1.100这个IP是一个私有IP，若原封不动地发送上去的话，是无法收到2.2.2.2返回信息的。路由器的WAN是连接着互联网的，具有公有IP 1.1.1.1。于是路由器就请来了小搬运工NAT，将这个报文做了一些修改：</p><ul><li>目的地：2.2.2.2</li><li>目的端口：80</li><li>发送方地址：1.1.1.1</li><li>发送方端口：6789</li></ul><p>我们发现，NAT将报文中的发送方地址和端口修改成了路由器的公网IP 1.1.1.1，并且将端口号换成了6789。于是这个报文的发送方就具备了公网IP，于是便可以顺利的接收从2.2.2.2返回的消息了。</p><p>但这还没有结束，如果NAT只是简单的修改了发送方的地址和端口之后便撒手不管了，那么就算2.2.2.2返回了消息，可也只是路由器接收到了消息，路由器下面可能连接着数十个私有IP的设备，那这个消息到底应该转发给谁呢？</p><h2 id="3-NAT会作记录"><a href="#3-NAT会作记录" class="headerlink" title="3 NAT会作记录"></a>3 NAT会作记录</h2><p>小搬运工NAT有一个好习惯，就是每次修改了发送方地址和端口之后，都会用小本把这个改动记录下来，这就是地址转换表，每次路由器呼叫NAT来进行一次地址转换，NAT都会细心的把这个改动记录下来，这个记录大致是如下形式：</p><div class="table-container"><table><thead><tr><th style="text-align:center">公网IP</th><th style="text-align:center">私有IP</th><th style="text-align:center">路由器端口号</th><th style="text-align:center">主机端口号</th><th style="text-align:center">存活时间（秒）</th></tr></thead><tbody><tr><td style="text-align:center">2.2.2.2</td><td style="text-align:center">192.168.1.100</td><td style="text-align:center">6789</td><td style="text-align:center">1234</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">3.3.3.3</td><td style="text-align:center">192.168.1.106</td><td style="text-align:center">12859</td><td style="text-align:center">5896</td><td style="text-align:center">300</td></tr></tbody></table></div><h2 id="4-NAT将服务器报文转发给私有IP下的设备"><a href="#4-NAT将服务器报文转发给私有IP下的设备" class="headerlink" title="4 NAT将服务器报文转发给私有IP下的设备"></a>4 NAT将服务器报文转发给私有IP下的设备</h2><p>正是因为有了地址转换表的存在，当服务器2.2.2.2将用户A的手机想要得到的报文返回时，NAT会参照地址转换表中的内容，将相应的报文转发给局域网下具有私有IP的手机，手机就可以和互联网通信啦！</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>NAT的一系列动作，都是悄无声息的在路由器中完成的，甚至让很多人忘记了它的存在。这就是为什么我们在本地电脑上查看IP是私有IP，而在查询IP的网站<a href="http://ip138.com" target="_blank" rel="external">ip138.com</a>下查询到的却是公网IP了，全部都是NAT这个小搬运工在后面捣的鬼！可是我们要感谢NAT，要是没有它，我们的电脑可能就要被困在路由器的小黑屋中，无法和互联网中的世界联系啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在由于我们每个人的手机、电脑、平板电脑等设备都有接入互联网的要求，可是我们家里通常只有一路网线入户，为了解决这个问题我们家里现在都会购买一台无线路由器，将这根入户网线连接到路由器的WAN口之后，便可以通过路由器上的LAN口或者WIFI接入来上网了。这时候我们查看一下我们设
      
    
    </summary>
    
      <category term="Computer Network" scheme="http://yluo.name/categories/Computer-Network/"/>
    
    
      <category term="network" scheme="http://yluo.name/tags/network/"/>
    
      <category term="nat" scheme="http://yluo.name/tags/nat/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络初探（二）：自动配置上网信息的DHCP服务器</title>
    <link href="http://yluo.name/2018/09/06/network_2/"/>
    <id>http://yluo.name/2018/09/06/network_2/</id>
    <published>2018-09-06T13:34:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>一台计算机如果想要接入互联网，则必须要配置以下四项参数：</p><ul><li>IP地址</li><li>子网掩码</li><li>缺省网关</li><li>DNS服务器IP地址</li></ul><p>但通常我们利用网线连接路由器的网口或者连接上无线路由器WIFI之后，也没有手动配置过这些信息，但是我们就已经可以上网了，此时我们在命令行下运行<code>ipconfig -all</code>(Linux下运行<code>ifconfig</code>)就可以看到，以上所需的信息都已经自动配置完成了，这就是DHCP服务的功劳啦！</p><h1 id="什么是DHCP"><a href="#什么是DHCP" class="headerlink" title="什么是DHCP"></a>什么是DHCP</h1><p>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议) 是用于内部网络自动分配IP地址的网络协议。目前我们买到的路由器都具备DHCP服务器的功能，当我们连接上路由器后，我们的电脑就会在网络中寻找DHCP服务器，而DHCP服务器接收到消息后便会响应电脑的请求，分配空闲的IP地址给我们的电脑。</p><h1 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h1><h2 id="1-客户端寻找DHCP服务器"><a href="#1-客户端寻找DHCP服务器" class="headerlink" title="1 客户端寻找DHCP服务器"></a>1 客户端寻找DHCP服务器</h2><p>当客户端首次连接上路由器时，并没有任何的IP地址设定，因此它将以广播（broadcast）的方式，采用UDP协议在网络中发送DHCP Discover报文来寻找DHCP服务器（目的端口68，源端口67）。网络中所有安装了TCP/IP协议的主机都会接收到这个消息，但是只有DHCP服务器会作出响应。</p><h2 id="2-DHCP服务器给客户端分配IP参数"><a href="#2-DHCP服务器给客户端分配IP参数" class="headerlink" title="2 DHCP服务器给客户端分配IP参数"></a>2 DHCP服务器给客户端分配IP参数</h2><p>服务器接收到客户端发来的DHCP Discover报文，会从IP地址池中选择一个空闲的IP地址，对应的子网掩码、缺省网关、DNS服务器IP地址，以单播（unicast）的方式，采用UDP协议发送给客户端一个包含以上信息的DHCP Offer报文（目的端口67，源端口68）。</p><h2 id="3-客户端接受IP参数"><a href="#3-客户端接受IP参数" class="headerlink" title="3 客户端接受IP参数"></a>3 客户端接受IP参数</h2><p>DHCP客户端接收到DHCP Offer报文，选择接收到的第一个信息（若网络中存在多个DHCP服务器，则只接收第一个收到的DHCP报文），以单播方式回答一个DHCP Request报文，里面包含其所选定的DHCP服务器请求IP地址的内容。</p><h2 id="4-IP地址分配确认"><a href="#4-IP地址分配确认" class="headerlink" title="4 IP地址分配确认"></a>4 IP地址分配确认</h2><p>DHCP服务器接收到DHCP客户端响应的DHCP Request报文后，便以单播的形式向客户端发送DHCP Ack报文，告诉客户端可以使用其提供的IP地址。客户端接收到DHCP Ack报文后，会尝试用获得的参数配置TCP/IP协议栈，同时还要尝试ARP广播请求自己IP对应的MAC地址，这个为了确定这个IP地址是唯一，不会引起IP冲突，若没有受到任何回复则可以完成配置工作。</p><h1 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h1><p>DHCP服务器正常工作，要求和客户端处于同一个网段内，若一个公司具有数十个子网，便需要数十个DHCP服务器，这是很浪费的。这个问题可以通过DHCP中继处理来解决。即在每个网段内有一个DHCP中继代理，之后将每个中继代理和DHCP服务器处于同一网段下即可，DHCP中继代理就充当让客户端与服务器相互发现彼此的中介机构。</p><p>DHCP中继代理的工作过程如下：</p><ol><li>接受网段内DHCP广播报文</li><li>添加[中继代理 xx.xx.xx.xx]字段</li><li>将广播转单播发给DHCP服务器</li><li>接收DHCP服务器报文并法给客户端</li></ol><h1 id="DHCP优化"><a href="#DHCP优化" class="headerlink" title="DHCP优化"></a>DHCP优化</h1><p>DHCP服务器能够实现上述功能，看上去已经很好了，但是仍然存在一些问题，但聪明的程序员已经想到了解决方案。</p><h2 id="多DHCP服务共存"><a href="#多DHCP服务共存" class="headerlink" title="多DHCP服务共存"></a>多DHCP服务共存</h2><p>当多个网段处于同一个广播域下，存在多个DHCP服务器时，申请IP地址时，每个DHCP服务器都会响应客户端的报文，则客户端会以第一个收到的DHCP报文中包含的IP地址作为自己的IP地址，这在很多时候是不被允许的，客户端所处的网段是需要可控的。</p><p><strong>解决方法</strong> 可利用VLAN（虚拟局域网）技术来解决，VLAN可以隔离广播，限制不同网段之间的访问，这样就可以有效的避免DHCP广播报文在不同网段内的传播，提高了安全性。</p><h2 id="DHCP欺诈"><a href="#DHCP欺诈" class="headerlink" title="DHCP欺诈"></a>DHCP欺诈</h2><p>由于DHCP就是通过DHCP报文来分配IP地址的，那么在网络下若存在一台计算机，伪造了大量的MAC地址，并利用这些地址发送DHCP报文申请IP地址，则地址资源就要被耗尽，会造成同一个网段下其他用户无法上网。</p><p><strong>解决方法</strong> DHCP窥探（DHCP Snooping）监视端口，当DHCP Discover信息经过的时候，会在原报文基础上增加一个安全选项[Option 82]，这里面记录了交换机名称、端口号等信息，这样若发现端口申请了多个IP，则拒绝继续分配IP地址。</p><h2 id="ARP漏洞"><a href="#ARP漏洞" class="headerlink" title="ARP漏洞"></a>ARP漏洞</h2><p>计算机利用ARP广播协议在网络中发现彼此的MAC地址，若计算机A在发送ARP报文时，被网络中的一台伪造MAC地址的计算机B回答了，则本应发给目标计算机C的消息全部发送给了伪造MAC地址的计算机B，计算机B看到了内容之后再将消息转发给C，这样A和C之间的消息都被B给劫持了，这就是网络流量的劫持。</p><p><strong>解决方法</strong> 同样利用DHCP窥探，在DHCP窥探时，会生成一张绑定表，里面记录了端口号、主机MAC地址、IP地址等信息，因此若发现报文中MAC地址、IP地址与端口号有任何一个不符合都被认为是欺诈行为。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一台计算机如果想要接入互联网，则必须要配置以下四项参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP地址&lt;/li&gt;
&lt;li&gt;子网掩码&lt;/li&gt;
&lt;li&gt;缺省网关&lt;/li&gt;
&lt;li&gt;DNS服务器IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但通常我们利用网线连接路由器的网口或者连接上无线路由器W
      
    
    </summary>
    
      <category term="Computer Network" scheme="http://yluo.name/categories/Computer-Network/"/>
    
    
      <category term="network" scheme="http://yluo.name/tags/network/"/>
    
      <category term="dhcp" scheme="http://yluo.name/tags/dhcp/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络初探（一）：IP地址与域名解析</title>
    <link href="http://yluo.name/2018/09/02/network_1/"/>
    <id>http://yluo.name/2018/09/02/network_1/</id>
    <published>2018-09-02T13:49:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个工科男，一直对互联网这个每天离不开的庞大计算机网络充满了好奇。但互联网的知识如此繁杂，想了解但却又无从下手。虽说之前也配置过家里的路由器，利用过shadowsocks进行科学上网，但是却使用只能照着教程一步一步来，对互联网还是一知半解。正好遇上了同样喜欢研究的<a href="http://blog.chauncey.ml/wordpress" target="_blank" rel="external">丁博士</a>，趁着和他请教搭建VPS服务器的同时，研究了一下计算机网络的知识，对计算机网络的搭建有了初步的了解。</p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>当今的互联网是基于TCP/IP的思路设计的，由一些小的子网通过路由器连接起来形成一个巨大的网络。在计算机网络中，所有的设备都会被分配到一个IP地址，这个地址就像是家庭住址，互联网之间的信息传递就像是快递员送信，快递员如果不想把信送错地方，那么就需要每一个设备都有一个唯一的门牌号，例如“XX区XX街XX号”。实际的IP地址是一串32比特的数，每8比特（1字节）一组，分为四组，所以我们看到的IP地址就是这样的：192.168.0.1。</p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>TCP/IP是将多台计算机组成一个子网，然后再利用路由器将这些子网连接起来，IP地址是由网段号+主机号构成的，但是单看IP地址是无法确定哪些计算机在一个子网下的，于是乎一个叫子网掩码的东西就呼之欲出了。子网掩码（mask）是一串与IP地址相同长度的32比特数字，其左边一半都是1，右边一半都是0。子网掩码为1的部分表示网段号（子网下的计算机IP地址相同的部分），子网掩码为0的部分表示主机号（子网下不同的计算机IP地址不同的部分）。其表示方法有两种，例如，网段号24位，主机号8位的子网下的计算机A：192.168.0.1，可以表示为192.168.0.1/255.255.255.0，或者192.168.0.1/24。这就表示在192.168.0.1这个IP地址中192.168.0代表网段号，而.1代表主机号，于是IP为192.168.0.X（X表示1～254中的任意值）均处在同一个子网下。</p><p>值得一提的是，主机号部分比特全为0代表整个子网而不是某一台设备，例如192.168.0.0/24代表整个子网；而主机号部分比特全为1代表向子网上所有设备发送包，即广播（Broadcast，这很有用，比如ARP查询MAC地址时就需要利用广播）。</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>正常来讲，我们想访问网络中的任意一台计算机，只需要输入它的IP就能和它通信了。比如我们想访问<a href="baidu.com">百度</a>，其实可以直接在浏览器下输入其服务器的IP<a href="123.125.115.110">123.125.115.110</a>即可，可是几乎没人这样做，大家都是直接输入域名<a href="baidu.com">baidu.com</a>来访问的，这就像我们知道每个人的名字，但是却不会记住每个人的身份证一样，与其记住一串毫无规律的数字，不如去记住一个直观的名字来的容易。但是计算机之前是靠IP地址来通信的，当我们输入<a href="baidu.com">baidu.com</a>这个域名的时候，DNS服务器（Domain Name System，域名服务系统）就登场了，浏览器会去最近的DNS服务器查询[baidu.com]这个域名对应的IP地址，然后利用查询到的IP地址来登陆百度的网站，这个过程就叫域名解析。</p><p>DNS服务器同样是有IP地址的，有时候我们在Windows下配置IPv4协议时，输入首选和备用DNS服务器的地址，为的就是能够把域名正确解析到对应的IP地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个工科男，一直对互联网这个每天离不开的庞大计算机网络充满了好奇。但互联网的知识如此繁杂，想了解但却又无从下手。虽说之前也配置过家里的路由器，利用过shadowsocks进行科学上网，但是却使用只能照着教程一步一步来，对互联网还是一知半解。正好遇上了同样喜欢研究的&lt;a 
      
    
    </summary>
    
      <category term="Computer Network" scheme="http://yluo.name/categories/Computer-Network/"/>
    
    
      <category term="network" scheme="http://yluo.name/tags/network/"/>
    
      <category term="ip address" scheme="http://yluo.name/tags/ip-address/"/>
    
      <category term="dns" scheme="http://yluo.name/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记（一）：安装与配置</title>
    <link href="http://yluo.name/2018/08/30/ros_1/"/>
    <id>http://yluo.name/2018/08/30/ros_1/</id>
    <published>2018-08-30T03:42:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ros_org.png" alt=""></p><h1 id="什么是ROS？"><a href="#什么是ROS？" class="headerlink" title="什么是ROS？"></a>什么是ROS？</h1><p>ROS (Robot Operating System, 机器人操作系统)在其<a href="ros.org">官网ros.org</a>上是这么介绍的：</p><blockquote><p>ROS 提供一系列程序库和工具以帮助软件开发者创建机器人应用软件。它提供了硬件抽象、设备驱动、函数库、可视化工具、消息传递和软件包管理等诸多功能。ROS遵循BSD开源许可协议。</p></blockquote><p>听上去还是没有感觉到ROS的厉害之处，在我刚开始接触ROS的时候，以为ROS只是一些函数库，类似于各种应用程序开放的API一样，我只要调用相应的函数，就执行相应的功能。但是在后来的使用过程中，我才意识到ROS并不仅仅是一堆可供调用的函数而已。实际上ROS是一个机器人系统的开发框架，之所以可以称自己为“操作系统”，就是因为在这个框架之上，ROS为机器人的开发提供了一个平台，类似于一个操作系统一样，他帮你抽象好了硬件，设置好消息传递方式，让你可以更加方便快捷的实现你的想法，而不用从机器人硬件的底层开始编写程序，提高机器人系统的研发效率。</p><h1 id="ROS能做什么？"><a href="#ROS能做什么？" class="headerlink" title="ROS能做什么？"></a>ROS能做什么？</h1><p>作为一种标准化机器人软件框架，利用ROS中大量的示例代码和开源程序可以轻松地完成机器人编程和控制。ROS的设计目标之一便是提高代码的复用率，ROS在运行时松散耦合，各个子功能之间相互独立，利用发布与订阅消息进行通讯，因此极易扩展，并且ROS提供了大量的监视和调试工具，方便机器人控制程序的开发。</p><p>我认为ROS也有一定的缺点，即实时性差，以我对ROS的了解，在一台普通电脑上，ROS的控制频率很难超过20Hz。当然ROS设计的目的是快速的进行机器人系统的开发，提高控制频率也并不是ROS关注的方向。</p><h1 id="安装ROS"><a href="#安装ROS" class="headerlink" title="安装ROS"></a>安装ROS</h1><p>在ROS的官方网站<a href="http://ros.org" target="_blank" rel="external">ros.org</a>有详细的安装介绍，这里不再赘述，只简单介绍以下安装步骤。</p><h2 id="ROS版本与操作系统环境"><a href="#ROS版本与操作系统环境" class="headerlink" title="ROS版本与操作系统环境"></a>ROS版本与操作系统环境</h2><p>ROS在Ubuntu下有着完美的支持，因此对于像我这样的新手果断选择在Ubuntu下安装ROS。不同的Ubuntu版本对应着不同版本的ROS，必须按照官网上ROS版本所支持的Ubuntu版本来进行对应安装。由于我目前的版本为Ubuntu 18.04 LTS，因此我安装的是ROS Melodic Morenia，如果你使用的是Ubuntu 16.04 LTS,则需要对应安装ROS Kinetic Kame，这两个版本的ROS都是长期支持版，推荐使用。</p><h2 id="添加sources-list"><a href="#添加sources-list" class="headerlink" title="添加sources.list"></a>添加sources.list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos;</div></pre></td></tr></table></figure><h2 id="设置keys"><a href="#设置keys" class="headerlink" title="设置keys"></a>设置keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</div></pre></td></tr></table></figure><h2 id="更新库"><a href="#更新库" class="headerlink" title="更新库"></a>更新库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo apt-get update</div></pre></td></tr></table></figure><h2 id="安装ROS完整版"><a href="#安装ROS完整版" class="headerlink" title="安装ROS完整版"></a>安装ROS完整版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo apt-get install ros-melodic-desktop-full</div></pre></td></tr></table></figure><h2 id="安装rosdep"><a href="#安装rosdep" class="headerlink" title="安装rosdep"></a>安装rosdep</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$sudo rosdep init</div><div class="line">$rosdep update</div></pre></td></tr></table></figure><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</div><div class="line">$source ~/.bashrc</div></pre></td></tr></table></figure><h2 id="添加用于构建package的依赖"><a href="#添加用于构建package的依赖" class="headerlink" title="添加用于构建package的依赖"></a>添加用于构建package的依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</div></pre></td></tr></table></figure><p>到这里，ROS就已经安装完成，可运行如下指令来验证ROS环境是否已经配置完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$printenv | grep ROS</div></pre></td></tr></table></figure><p>如果显示如下内容则说明已经完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ROS_ETC_DIR=/opt/ros/melodic/etc/ros</div><div class="line">ROS_ROOT=/opt/ros/melodic/share/ros</div><div class="line">ROS_MASTER_URI=http://localhost:11311</div><div class="line">ROS_VERSION=1</div><div class="line">ROS_PYTHON_VERSION=2</div><div class="line">ROS_PACKAGE_PATH=/opt/ros/melodic/share</div><div class="line">ROSLISP_PACKAGE_DIRECTORIES=</div><div class="line">ROS_DISTRO=melodic</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/ros_org.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是ROS？&quot;&gt;&lt;a href=&quot;#什么是ROS？&quot; class=&quot;headerlink&quot; title=&quot;什么是ROS？&quot;&gt;&lt;/a&gt;什么是ROS？&lt;/h1&gt;&lt;p&gt;ROS 
      
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记（一）：安装与配置</title>
    <link href="http://yluo.name/2018/08/30/rospy_api/"/>
    <id>http://yluo.name/2018/08/30/rospy_api/</id>
    <published>2018-08-30T03:42:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Robot Operating System" scheme="http://yluo.name/categories/Robot-Operating-System/"/>
    
    
      <category term="ros" scheme="http://yluo.name/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>Git分布式版本控制系统使用心得</title>
    <link href="http://yluo.name/2018/04/14/Git_intro/"/>
    <id>http://yluo.name/2018/04/14/Git_intro/</id>
    <published>2018-04-14T12:32:00.000Z</published>
    <updated>2019-08-06T02:48:41.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Git对于经常写代码的码农同志们并不陌生，几乎是必备的工具之一。由于本人现在经常参与机器人相关的项目，需要管理大量的项目代码。之前一直在电脑保存各式各样的代码版本，时间一长根本记不住每个版本之间的区别和改动，这才入了Git的坑，在了解了Git的工作原理和基本操作之后，便一发不可收拾，真后悔没有早些了解这个神奇的工具。下面我就以我对Git的了解介绍一下什么是Git以及Git的基本使用方法。</p><h1 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h1><p>Git专业的叫法是：一种分布式版本控制系统。很多人不了解分布式版本控制系统的概念，没关系，我会用一种通俗的方式解释一下。</p><p>假设你现在要开发一个程序，你已经写好了一份代码，但是这份代码有很多BUG，而且功能也很不完善，你需要不断的修改这份代码，并且需要记录每次的改动，以便万一哪次改错了可以恢复之前的版本，如果没有Git，你会怎么做？</p><p>很简单，我可以把每次的代码文件名后面加一个版本号，假设是code1，code2，…..，code100 等等。如果我修改过100次，那么就需要在电脑上保留100份代码，怎么样？是不是很简单？而且很直观，我还可以在每次修改的代码文件里加入一些修改的描述，比如此次修改了什么什么之类的话。</p><p>似乎看上去已经很完美了，无非是多存一些文件而已嘛，怕什么？！老子硬盘4个TB！！好吧，那我们再考虑一些情况，很多时候一个项目代码需要几个人一起维护，那么怎么去协调每个人修改的部分呢？</p><p>这个稍微有一些麻烦了，不过没关系，我们可以让其中一个人先改，改完了将文件发给第二个人改，第二个人改完了发给第三个人，以此类推。当最后一个人改完了，将这个文件标记为最终版！！额。。。假设每个人都做过100次改动，有四个人来维护这个项目，那么产生的文件个数就是400个！这还只是一个项目而已，如果很多项目呢？对这些项目版本的管理会产生极其高昂的成本。</p><p>那么我们再假设一种情况，这个项目想新加入一个功能，但是不知道这个功能好不好，如果好就加到项目中去，如果不好就还是使用原来的项目。那么我们又该怎么管理这个项目的版本呢？</p><p>提出了以上问题，就是Git诞生的原因，最初就是为了方便管理Linux内核代码而设计的工具。在我看来，Git的用处在于可以记录每次的项目文件改动，而且可以方便的新建项目分支、合并项目分支。以我在Github上的<a href="github.com/thinkexist1989/CV">个人简历</a>为例，我的个人简历是用LaTeX写的，从写简历开始，每一次的修改都被Git记录了下来，而且由于我的简历分为中文版和英文版，我的项目里就新建了2个分支，一个叫en分支，是英文版简历，一个叫zh分支，是中文版简历。所有的这些在我的电脑里，仅仅有一份文件就足够了，这就是神奇的Git。</p><h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><p>如果你在Linux下，那么Git的使用将会是异常方便的。你只需要在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure><p>便可以使用Git了。当然，如果你不喜欢指令行形式的Git，你也可以使用一些GUI软件，个人比较推荐GitKraken，界面很漂亮，而且跨平台。</p><p>如果你在Windows下，你可以安装Git Bash，同样利用指令行来使用Git，或者使用GitKraken之类的GUI软件来管理你的项目版本。由于个人喜好，我喜欢直接利用指令来使用Git，这对于理解Git的工作原理也有很多好处，当然你也可以更直观的利用GUI来使用，下面我介绍的都是Git指令，理解了Git指令同样可以在GUI里游刃有余的使用Git。</p><h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><p>其实，Git只是一个记录文件改动的工具，因此完全可以独立在电脑上使用，并不一定非要将文件存放到网上。初始化Git很简单，新建一个你需要管理的项目文件夹，假设名为proj，进入文件夹，在终端里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git init</div></pre></td></tr></table></figure><p>你会发现，在文件夹里出现了一个隐藏的文件夹，名为.git，别小看了这个文件夹，今后你文件夹中所有的文件改动它都一清二楚地记录在里面，Git就是利用这个文件夹中的文件来进行版本控制的。</p><p>假设你的需要版本控制的文件名叫file.doc,那么你需要在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git add file.doc</div></pre></td></tr></table></figure><p>来告诉Git，我要跟踪file.doc这个文件的版本。或者如果文件夹下有很多文件，你全部需要跟踪，你可以输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git add .</div></pre></td></tr></table></figure><p>Git同时可以利用.gitignore文件控制需要忽略的文件，这个可以查看Git教程，这里不再赘述。下面你便可以对这个文件夹的文件进行修改，修改之后，在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git status</div></pre></td></tr></table></figure><p>你会发现，你所有的文件改动，包括修改，删除、新建的文件都没有逃过Git的法眼，但是根据Git的机制，Git目前还没有将这些改动暂存，如果你认为这一时刻的状态需要被Git记录下来，那么你就需要输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git commit -m &quot;这是我的修改&quot;</div></pre></td></tr></table></figure><p>这样你的这次改动就被Git存储了下来，今后不管到什么版本，你都可以随时恢复到这次暂存的这个版本。怎么样？很神奇吧。神奇的还在后面呢。假如你想新建项目的另一个版本，同时又不想影响当前的版本，你可以在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git checkout -b another</div></pre></td></tr></table></figure><p>这样，你会看到Git新建了一个分支，叫another分支，今后你所有的修改就会发生在another分支上，而对之前的分支（默认分支master）没有任何影响，如果你有一天想要回到之前的分支，继续之前的工作，那么简单，在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usr@proj $ git checkout master</div></pre></td></tr></table></figure><p>这样就轻松的切换回了主分支master，你会看到所有的文件都恢复到了master分支的状态。</p><p>这就是Git最基本的用法，当然了，版本回退、分支合并等操作也可以轻松实现，你也可以将代码push到GitHub或者Gitee等代码托管网站上，你也可以将别处的改动pull到本地，或是git clone网站上的代码到本地，这些在这里不在赘述，可以参考文献《Pro Git中文版》，里面有关于Git的详细用法。</p><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Git可以管理几乎你的任何文件，虽然不推荐使用Git来管理非文本类的文件，but anyway，这是你的自由，只要你想Git就可以做！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;Git对于经常写代码的码农同志们并不陌生，几乎是必备的工具之一。由于本人现在经常参与机器人相关的项目，需要管理大量的项目代码
      
    
    </summary>
    
      <category term="Software" scheme="http://yluo.name/categories/Software/"/>
    
    
      <category term="Git" scheme="http://yluo.name/tags/Git/"/>
    
  </entry>
  
</feed>
