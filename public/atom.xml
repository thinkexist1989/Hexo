<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DécouVerte</title>
  
  <subtitle>生命不息 折腾不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yluo.name/"/>
  <updated>2020-02-05T13:50:37.228Z</updated>
  <id>http://yluo.name/</id>
  
  <author>
    <name>Yang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows Powershell运行自定义脚本</title>
    <link href="http://yluo.name/2020/02/05/powershell-run-script/"/>
    <id>http://yluo.name/2020/02/05/powershell-run-script/</id>
    <published>2020-02-05T13:35:53.000Z</published>
    <updated>2020-02-05T13:50:37.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Windows Powershell为了防止恶意脚本的执行，设计了一个执行策略(Execution Policy)，若发现自定义的脚本无法运行，则需要更改执行策略。</p><p>执行策略包括6种类型：</p><ul><li>Restricted 受限制的，只能执行单个命令，不能执行脚本</li><li>AllSigned 允许执行有数字签名的脚本</li><li>RemoteSigned 本地脚本可以运行，网络下载的需要数字签名</li><li>Unrestricted 无限制，但从网络下载的会有安全提示</li><li>Bypass 不设任何限制，且没有安全提示</li><li>Undefined 未设置策略，使用继承或默认策略</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>利用管理员身份打开Powershell终端，输入以下命令将策略更改为<code>RemoteSigned</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ Set-ExecutionPolicy RemoteSigned</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;Windows Powershell为了防止恶意脚本的执行，设计了一个执行策略(Execution Policy)，若发现自
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Windows" scheme="http://yluo.name/tags/Windows/"/>
    
      <category term="Powershell" scheme="http://yluo.name/tags/Powershell/"/>
    
  </entry>
  
  <entry>
    <title>Git利用rebase压缩多次commit</title>
    <link href="http://yluo.name/2020/02/05/git-rebase/"/>
    <id>http://yluo.name/2020/02/05/git-rebase/</id>
    <published>2020-02-05T13:19:59.000Z</published>
    <updated>2020-02-05T13:34:33.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有时我们提交到GitHub等远程仓库上的commit太多，想将多次提交的commit合并成一个commit。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以利用rebase来压缩多次commit。</p><h3 id="1-首先查看本地提交历史"><a href="#1-首先查看本地提交历史" class="headerlink" title="1. 首先查看本地提交历史"></a>1. 首先查看本地提交历史</h3><p>输入以下命令查看master分支的提交历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log</div></pre></td></tr></table></figure><p>这里会显示master分支自创立以来的所有提交历史，现在假设要合并最近的4次提交。</p><h3 id="2-压缩最近4次提交"><a href="#2-压缩最近4次提交" class="headerlink" title="2. 压缩最近4次提交"></a>2. 压缩最近4次提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase -i HEAD~4</div></pre></td></tr></table></figure><p>该命令执行后，会弹出默认编辑器的编辑窗口，4次提交的信息会倒序排列，最新的提交在最下面。</p><p>我们需要将其中第2~4行的第一个单词<code>pick</code>修改为<code>squash</code>这意味着将最后三次提交压缩到倒数第4次提交。随后保存。</p><h3 id="3-处理冲突"><a href="#3-处理冲突" class="headerlink" title="3. 处理冲突"></a>3. 处理冲突</h3><p>若有冲突，则会提示需要修改，修改后输入以下命令保存此次压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git rebase --continue</div></pre></td></tr></table></figure><p>如果想要放弃此次压缩，则输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$git rebase --abort</div></pre></td></tr></table></figure><h3 id="4-修改描述信息"><a href="#4-修改描述信息" class="headerlink" title="4. 修改描述信息"></a>4. 修改描述信息</h3><p>若没有冲突处理，则会直接跳转到修改描述信息的位置，可以修改此次压缩后的commit描述。随后保存。</p><h3 id="5-提交到远程仓库"><a href="#5-提交到远程仓库" class="headerlink" title="5. 提交到远程仓库"></a>5. 提交到远程仓库</h3><p>修改完描述信息后便已经完成了提交，若想要推送的远程仓库，则需要覆盖之前的提交，需要强制推送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push -f</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;有时我们提交到GitHub等远程仓库上的commit太多，想将多次提交的commit合并成一个commit。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Git" scheme="http://yluo.name/tags/Git/"/>
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu蓝牙不可用</title>
    <link href="http://yluo.name/2020/02/03/ubuntu-bluetooth-disabled/"/>
    <id>http://yluo.name/2020/02/03/ubuntu-bluetooth-disabled/</id>
    <published>2020-02-03T02:43:10.000Z</published>
    <updated>2020-02-03T03:48:10.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>之前在Ubuntu下不小心删除了<code>/var/lib/bluetooth/</code>下的文件夹，导致蓝牙界面一直显示disabled。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在终端里输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rfkill unblock bluetooth</div></pre></td></tr></table></figure><p>随后重启系统并打开蓝牙，蓝牙便显示enabled了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;之前在Ubuntu下不小心删除了&lt;code&gt;/var/lib/bluetooth/&lt;/code&gt;下的文件夹，导致蓝牙界面一直
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Bluetooth" scheme="http://yluo.name/tags/Bluetooth/"/>
    
  </entry>
  
  <entry>
    <title>Windows无法进入睡眠</title>
    <link href="http://yluo.name/2020/02/03/windows-sleep/"/>
    <id>http://yluo.name/2020/02/03/windows-sleep/</id>
    <published>2020-02-03T02:28:25.000Z</published>
    <updated>2020-02-03T02:41:22.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>自己家的台式机在接通电源的情况下点击开始菜单-&gt;电源-&gt;睡眠，依然无法睡眠，会始终自动唤醒。这是由于Windows开启了<strong>离开模式</strong>(Away Mode)，一般来说能够改变到离开模式的软件主要有：</p><ul><li><strong>迅雷</strong>：离开模式下载；</li><li><strong>百度网盘</strong>：传输时不休眠。</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>按<code>WIN</code>+<code>R</code>打开<strong>运行</strong></li><li>输入<code>regedit</code>打开注册表编辑器</li><li>定位到<strong>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\Power</strong>，在右侧找到<code>AwayModeEnabled</code>，若其值为1时表示处于离开模式，无法正常睡眠，将其值改为0即可正常睡眠。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;自己家的台式机在接通电源的情况下点击开始菜单-&amp;gt;电源-&amp;gt;睡眠，依然无法睡眠，会始终自动唤醒。这是由于Window
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Windows" scheme="http://yluo.name/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Nvidia显卡驱动</title>
    <link href="http://yluo.name/2020/02/02/ubuntu-install-nvidia-driver/"/>
    <id>http://yluo.name/2020/02/02/ubuntu-install-nvidia-driver/</id>
    <published>2020-02-02T15:54:41.000Z</published>
    <updated>2020-02-02T16:20:37.579Z</updated>
    
    <content type="html"><![CDATA[<p>通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法：</p><h2 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h2><p>若显卡较老的话一般Ubuntu自己的源便会提供驱动，在系统的Additional Driver中选择相应的驱动安装即可，一般写着tested的驱动都是经过测试的，比较稳定。</p><h2 id="自行安装"><a href="#自行安装" class="headerlink" title="自行安装"></a>自行安装</h2><p>若显卡较新的话，Ubuntu自己的源很多时候没有相应的驱动，这时候就需要去Nvidia的官网下载对应的驱动包，比如我现在的电脑显卡是Quadra P1000，我要去Nvidia的官网上下载Linux的驱动安装包，命名通常为NVIDIA-Linux-x86_64-440.44.run，将文件下载到系统中，随后便开始安装</p><h3 id="1-禁用Nouveau"><a href="#1-禁用Nouveau" class="headerlink" title="1. 禁用Nouveau"></a>1. 禁用Nouveau</h3><p>在<code>/etc/modprobe.d/blacklist.conf</code>文件的最后一行加上一句话：<code>blacklist nouveau</code>，将Nouveau加入黑名单，保存后输入如下指令生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo update-initramfs -u</div></pre></td></tr></table></figure><h3 id="2-重启电脑进入命令行界面"><a href="#2-重启电脑进入命令行界面" class="headerlink" title="2. 重启电脑进入命令行界面"></a>2. 重启电脑进入命令行界面</h3><p>重启之后，可以在登录界面或者进入系统之后，按<code>ctrl</code>+<code>alt</code>+<code>F1</code>进入命令行界面</p><h3 id="3-关闭桌面服务"><a href="#3-关闭桌面服务" class="headerlink" title="3. 关闭桌面服务"></a>3. 关闭桌面服务</h3><p>在命令行界面下输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service lightdm stop</div></pre></td></tr></table></figure><h3 id="4-安装Nvidia驱动"><a href="#4-安装Nvidia驱动" class="headerlink" title="4. 安装Nvidia驱动"></a>4. 安装Nvidia驱动</h3><p>进入驱动安装包下载位置，首先赋予其执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x NVIDIA-Linux-x86_64-440.44.run</div></pre></td></tr></table></figure><p>随后运行并按照提示安装即可（通常用默认选项即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./NVIDIA-Linux-x86_64-440.44.run</div></pre></td></tr></table></figure><h3 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5.验证安装"></a>5.验证安装</h3><p>安装完成后输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo nvidia-smi</div></pre></td></tr></table></figure><p>若列出了GPU的信息列表则表示安装成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法：&lt;/p&gt;
&lt;h2 id=&quot;简单安装&quot;&gt;&lt;a href=&quot;#简单安装&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Nvidia" scheme="http://yluo.name/tags/Nvidia/"/>
    
  </entry>
  
  <entry>
    <title>thinkpad-p52-ubuntu-install.md</title>
    <link href="http://yluo.name/2020/02/02/thinkpad-p52-ubuntu-install/"/>
    <id>http://yluo.name/2020/02/02/thinkpad-p52-ubuntu-install/</id>
    <published>2020-02-02T15:45:09.000Z</published>
    <updated>2020-02-02T15:54:09.506Z</updated>
    
    <content type="html"><![CDATA[<p>最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这是由于Thinkpad的核显与独显冲突造成的，需要在主板BIOS里禁用核显。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>开机按<code>Enter</code>进入BIOS配置，随后按<code>F1</code>进入BIOS Setup，在Config菜单下选择Display菜单打开，第二项Graphic Device选项中，选择<code>Discrete Graphics</code>，随后保存退出，便实现了核显的禁用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：Gazebo的更新与配置</title>
    <link href="http://yluo.name/2020/02/02/gazebo-upgrade/"/>
    <id>http://yluo.name/2020/02/02/gazebo-upgrade/</id>
    <published>2020-02-02T14:04:25.000Z</published>
    <updated>2020-02-02T15:43:04.464Z</updated>
    
    <content type="html"><![CDATA[<p>由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。</p><h2 id="查看当前Gazebo版本"><a href="#查看当前Gazebo版本" class="headerlink" title="查看当前Gazebo版本"></a>查看当前Gazebo版本</h2><p>输入以下命令查看当前Gazebo版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gazebo -v</div></pre></td></tr></table></figure><h2 id="升级方法"><a href="#升级方法" class="headerlink" title="升级方法"></a>升级方法</h2><p>执行以下命令升级Gazebo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo sh -c &apos;echo &quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/gazebo-stable.list&apos;</div><div class="line">$ wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install gazebo7</div></pre></td></tr></table></figure><p>以Ubuntu 16.04 + ROS Kinetic为例，默认情况下Gazebo的版本为7.0.0，在更新完之后Gazebo的版本便成为7.16.0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。&lt;/p&gt;
&lt;h2 id=&quot;查看当前Gazebo版本&quot;&gt;&lt;a href=&quot;#查看当前Gazebo版本&quot; class=&quot;head
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu开机自动挂载硬盘</title>
    <link href="http://yluo.name/2020/01/20/ubuntu-mount/"/>
    <id>http://yluo.name/2020/01/20/ubuntu-mount/</id>
    <published>2020-01-20T01:11:36.000Z</published>
    <updated>2020-02-01T14:31:16.452Z</updated>
    
    <content type="html"><![CDATA[<p>平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-查看硬盘信息"><a href="#1-查看硬盘信息" class="headerlink" title="1.查看硬盘信息"></a>1.查看硬盘信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo fdisk -l</div></pre></td></tr></table></figure><p>其显示信息大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Device     Boot Start        End    Sectors  Size Id Type</div><div class="line">/dev/sda1        2048 1000212479 1000210432  477G  7 HPFS/NTFS/exFAT</div></pre></td></tr></table></figure><p>如果有多个设备，则会显示多个类似信息。</p><h3 id="2-创建需要挂载的目录"><a href="#2-创建需要挂载的目录" class="headerlink" title="2. 创建需要挂载的目录"></a>2. 创建需要挂载的目录</h3><p>我希望将硬盘挂载到用户目录下，因此在用户目录下建立<code>SSD/</code>文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir ~/SSD/</div></pre></td></tr></table></figure><h3 id="3-查看磁盘分区的UUID"><a href="#3-查看磁盘分区的UUID" class="headerlink" title="3. 查看磁盘分区的UUID"></a>3. 查看磁盘分区的UUID</h3><p>输入以下指令查看<code>/dev/sda1</code>的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo blkid</div></pre></td></tr></table></figure><p>其显示信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/sda1: LABEL=<span class="string">"SSD"</span> UUID=<span class="string">"C28070388070354F"</span> TYPE=<span class="string">"ntfs"</span> PARTUUID=<span class="string">"40ae352f-01"</span></div></pre></td></tr></table></figure><p>其中<code>UUID=&quot;C28070388070354F&quot;</code>便是挂载硬盘的UUID， 其文件系统格式为ntfs。</p><h3 id="4-配置开机自动挂载"><a href="#4-配置开机自动挂载" class="headerlink" title="4. 配置开机自动挂载"></a>4. 配置开机自动挂载</h3><p>在<code>/etc/fstab</code>文件中加入如下分区信息，让其开机自动挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UUID=C28070388070354F /home/think/SSD ntfs defaults 0 0</div></pre></td></tr></table></figure><p>说明：其格式为 <strong>&lt;分区定位&gt;</strong> + <strong>&lt;挂载点位置&gt;</strong> + <strong>&lt;挂载磁盘类型&gt;</strong> + <strong>&lt;挂载参数&gt;</strong> + <strong><dump备份></dump备份></strong> + <strong>&lt;磁盘检查&gt;</strong>，</p><ul><li><strong>分区定位</strong>，可以为UUID或LABEL；</li><li><strong>挂载点位置</strong>，想要挂载硬盘的位置；</li><li><strong>挂载磁盘类型</strong>，文件系统类型，<code>auto</code>, <code>ext4</code>, <code>ntfs</code>；</li><li><strong>挂载参数</strong>， 通常为<code>defaults</code>，还可设置为<code>auto</code>, <code>ro</code>, <code>rw</code>；</li><li><strong>dump备份</strong>，dump工具决定何时备份，0表示忽略，1表示备份。通常为0；</li><li><strong>磁盘检查</strong>，决定文件系统检查顺序， 0表示检查，1表示最高优先权， 2表示其他所有需要被检查的设备。</li></ul><h3 id="5-挂载硬盘"><a href="#5-挂载硬盘" class="headerlink" title="5. 挂载硬盘"></a>5. 挂载硬盘</h3><p>执行完之前的步骤已经可以在开机自动挂载了，若想手动挂载也很方便，只需要输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mount -a</div></pre></td></tr></table></figure><p>这样便可根据<code>/etc/fstab</code>文件中的顺序挂载所有设备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：echo指令</title>
    <link href="http://yluo.name/2020/01/19/shell-echo/"/>
    <id>http://yluo.name/2020/01/19/shell-echo/</id>
    <published>2020-01-19T15:57:54.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><code>echo</code>命令用于在终端打印一行文本，例如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> this is a <span class="built_in">test</span></div><div class="line">this is a <span class="built_in">test</span></div></pre></td></tr></table></figure><p>经常使用的参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-n</td><td style="text-align:left">不输出结尾换行符</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">启用反斜杠转义的解释</td></tr><tr><td style="text-align:left">-E</td><td style="text-align:left">不启用反斜杠转义的解释（默认）</td></tr></tbody></table></div><p>若采用<code>-e</code>， 则下列转义字符将被解释：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">\\</td><td style="text-align:left">不输出结尾换行符</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格 backspace</td></tr><tr><td style="text-align:left">\c</td><td style="text-align:left">不再输出后面内容</td></tr><tr><td style="text-align:left">\e</td><td style="text-align:left">退出 escape</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">退格 backspace</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平tab</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直tab</td></tr><tr><td style="text-align:left">\0NNN</td><td style="text-align:left">八进制NNN</td></tr><tr><td style="text-align:left">\xHH</td><td style="text-align:left">16进制HH</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令用于在终端打印一行文本，例如，&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cl
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：who指令</title>
    <link href="http://yluo.name/2020/01/19/shell-who/"/>
    <id>http://yluo.name/2020/01/19/shell-who/</id>
    <published>2020-01-19T15:37:36.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><code>who</code>命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><p>经常使用的参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-H, —heading</td><td style="text-align:left">显示各栏的列标题</td></tr><tr><td style="text-align:left">-b, —boot</td><td style="text-align:left">最后一次系统启动时间</td></tr><tr><td style="text-align:left">-d, —dead</td><td style="text-align:left">死进程</td></tr><tr><td style="text-align:left">-l, —login</td><td style="text-align:left">系统登陆进程</td></tr><tr><td style="text-align:left">-p, —process</td><td style="text-align:left">激活进程</td></tr><tr><td style="text-align:left">-r, —runlevel</td><td style="text-align:left">当前运行级别</td></tr><tr><td style="text-align:left">-t, —time</td><td style="text-align:left">显示最后一次系统时钟改动</td></tr><tr><td style="text-align:left">-T, -w, —mesg</td><td style="text-align:left">加入用户信息状态 + - ?</td></tr><tr><td style="text-align:left">-u, —user</td><td style="text-align:left">列出登陆用户</td></tr><tr><td style="text-align:left">-a 或 —all</td><td style="text-align:left">显示全部信息 -b -d -l -p -r -t -T -u</td></tr></tbody></table></div><h2 id="获取本人信息"><a href="#获取本人信息" class="headerlink" title="获取本人信息"></a>获取本人信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ who am i</div><div class="line">think    pts/18     2020-01-19 23:35 (:0)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;who&lt;/code&gt;命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。&lt;/p&gt;
&lt;p&gt;经常使用的参数如下：&lt;/p&gt;
&lt;div class=&quot;table-contain
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：date指令</title>
    <link href="http://yluo.name/2020/01/19/shell-date/"/>
    <id>http://yluo.name/2020/01/19/shell-date/</id>
    <published>2020-01-19T13:37:54.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><code>date</code>命令用于显示当前的日期及时间，直接运行可得到如下格式的显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date</div><div class="line">Sun Jan 19 21:42:52 CST 2020</div></pre></td></tr></table></figure><p>可以在命令后添加参数以设定输出格式(<code>date [OPTION]... [+FORMAT]</code>)，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date +%Y%m%d</div><div class="line">20200119</div></pre></td></tr></table></figure><p>常用的格式参数如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%H</td><td style="text-align:left">小时(00~23)</td></tr><tr><td style="text-align:left">%I</td><td style="text-align:left">小时(01~12)</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">分(00~59)</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">月(01~12)</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">显示AM或PM</td></tr><tr><td style="text-align:left">%r</td><td style="text-align:left">时间(hh:mm:ss)</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">秒(00~59)</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">从1970-01-01 00:00:00 UTC开始到现在的秒数</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">24小时制时间 %H:%M:%S</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">按照当前系统时间格式显示当前时间</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">按照当前系统日期格式显示当前日期</td></tr><tr><td style="text-align:left">%Z</td><td style="text-align:left">时区</td></tr><tr><td style="text-align:left">%a</td><td style="text-align:left">星期简称(Sun)</td></tr><tr><td style="text-align:left">%A</td><td style="text-align:left">星期全称(Sunday)</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">月的简称(Dec)</td></tr><tr><td style="text-align:left">%B</td><td style="text-align:left">月的全称(December)</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">日期和时间(Sun 19 Jan 2020 10:06:36 PM CST)</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">一个月的第几天(01~31)</td></tr><tr><td style="text-align:left">%D</td><td style="text-align:left">日期(mm/dd/yy)</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">一个星期的第几天(0代表Sunday)</td></tr><tr><td style="text-align:left">%W</td><td style="text-align:left">一年的第几个星期(01~53)，星期一为第一天</td></tr><tr><td style="text-align:left">%y</td><td style="text-align:left">年的最后两位(20)</td></tr><tr><td style="text-align:left">%Y</td><td style="text-align:left">年(2020)</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令用于显示当前的日期及时间，直接运行可得到如下格式的显示：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yluo.name/2020/01/18/regexp/"/>
    <id>http://yluo.name/2020/01/18/regexp/</id>
    <published>2020-01-18T06:11:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><h2 id="为什么使用正则表达式"><a href="#为什么使用正则表达式" class="headerlink" title="为什么使用正则表达式"></a>为什么使用正则表达式</h2><p>在Linux终端和Vim等文本编辑器中经常会使用到正则表达式来匹配期望的文本，通过使用正则表达式可以：</p><ul><li>测试字符串内的模式， 例如查看字符串内是否出现电话号码或信用卡号码等；</li><li>替换文本， 识别特定文本并进行相关操作；</li><li>基于模式匹配从字符串中提取子字符串，可以查找文档内或输入域内特定的文本。</li></ul><p>例如，可以使用<code>data(\w)?\.dat</code>可以匹配以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data.dat</div><div class="line">data1.dat</div><div class="line">datax.dat</div><div class="line">dataN.dat</div></pre></td></tr></table></figure><p><code>?</code>可以匹配文件名中的0个或1个字符，而<code>*</code>通配符匹配0个或多个字符。<code>data.*\.dat</code>可以匹配以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data.dat</div><div class="line">data2.dat</div><div class="line">data12.dat</div><div class="line">dataxYZ.dat</div></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>例如，</p><ul><li><p><code>runoo+b</code>，可以匹配 runoob、runooob、runoooooob 等，<code>+</code> 号代表前面的字符必须至少出现一次（1次或多次）。</p></li><li><p><code>runoo*b</code>，可以匹配 runob、runoob、runoooooob 等，<code>*</code> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p></li><li><p><code>colou?r</code> 可以匹配 color 或者 colour，<code>?</code> 问号代表前面的字符最多只可以出现一次（0次、或1次）。</p></li></ul><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有<em>大写</em>和<em>小写</em>字母、所有<em>数字</em>、所有<em>标点符号</em>和一些其他符号。</p><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>\cx</code></td><td style="text-align:left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符</td></tr><tr><td style="text-align:left"><code>\f</code></td><td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \c</td></tr><tr><td style="text-align:left"><code>\n</code></td><td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ</td></tr><tr><td style="text-align:left"><code>\r</code></td><td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM</td></tr><tr><td style="text-align:left"><code>\s</code></td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符</td></tr><tr><td style="text-align:left"><code>\S</code></td><td style="text-align:left">匹配任何非空白字符。等价于 <sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup></td></tr><tr><td style="text-align:left"><code>\t</code></td><td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI</td></tr><tr><td style="text-align:left"><code>\v</code></td><td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK</td></tr></tbody></table></div><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <code>runoo*b</code> 中的 <code>*</code>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 <code>\</code>: <code>runo\*ob</code> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<code>\</code>放在它们前面。下表列出了正则表达式中的特殊字符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $</td></tr><tr><td style="text-align:left"><code>()</code></td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code></td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式0次或多次。要匹配 <em> 字符，请使用 `\</em>`</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式1次或多次。要匹配 + 字符，请使用 <code>\+</code></td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配 . ，请使用 <code>\.</code></td></tr><tr><td style="text-align:left"><code>[</code></td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code></td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式0次或1次，或指明一个<strong>非贪婪</strong>限定符。要匹配 ? 字符，请使用 <code>\?</code></td></tr><tr><td style="text-align:left"><code>\</code></td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 n。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 \、，而 <code>\(</code> 则匹配 (</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code></td></tr><tr><td style="text-align:left"><code>{</code></td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用<code>\{</code></td></tr><tr><td style="text-align:left">&#124;</td><td style="text-align:left">指明两项之间的一个选择。要匹配 &#124;， 请使用 \&#124;</td></tr></tbody></table></div><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <code>*</code>或 <code>+</code> 或 <code>?</code> 或 <code>{n}</code> 或 <code>{n,}</code> 或 <code>{n,m}</code> 共6种。正则表达式的限定符有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式0次或多次。例如，<code>zo*</code> 能匹配 z 以及 zoo。<code>*</code> 等价于<code>{0,}</code></td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式1次或多次。例如，<code>zo+</code> 能匹配 zo 以及 zoo，但不能匹配 z。<code>+</code> 等价于 <code>{1,}</code></td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式0次或1次。例如，<code>do(es)?</code> 可以匹配 do 、 does 中的 does 、 doxy 中的 do 。<code>?</code> 等价于 <code>{0,1}</code></td></tr><tr><td style="text-align:left"><code>{n}</code></td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，<code>o{2}</code> 不能匹配 Bob 中的 o，但是能匹配 food 中的2个 o</td></tr><tr><td style="text-align:left"><code>{n,}</code></td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，<code>o{2,}</code> 不能匹配 Bob 中的 o，但能匹配 foooood 中的所有 o。<code>o{1,}</code> 等价于 <code>o+</code>。<code>o{0,}</code> 则等价于 <code>o*</code></td></tr><tr><td style="text-align:left"><code>{n,m}</code></td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<code>o{1,3}</code> 将匹配 fooooood 中的前三个 o。<code>o{0,1}</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr></tbody></table></div><p>以下正则表达式匹配一个正整数， <code>[1-9]</code>设置第一个数字不是0， <code>[0-9]*</code>表示任意多个数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[1-9][0-9]*/</div></pre></td></tr></table></figure><p>请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定1位但至多2位数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[0-9]&#123;1,2&#125;/</div></pre></td></tr></table></figure><p>上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。改进下，匹配 1~99 的正整数表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[1-9][0-9]?/</div></pre></td></tr></table></figure><p><code>*</code> 、<code>+</code> 限定符都是<strong>贪婪</strong>的，因为它们会<strong>尽可能多</strong>的匹配文字，只有在它们的后面加上一个 <code>?</code> 就可以实现<strong>非贪婪</strong>或<strong>最小匹配</strong>。</p><p>例如，您可能搜索 HTML 文档，以查找在 h1 标签内的内容。HTML 代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>RUNOOB-菜鸟教程<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;.*&gt;/</div></pre></td></tr></table></figure><p><strong>非贪婪</strong>：如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 \<h1\>。</h1\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;.*?&gt;/</div></pre></td></tr></table></figure><p>也可以使用以下正则表达式来匹配 h1 标签，表达式则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;\w+?&gt;/</div></pre></td></tr></table></figure><p>通过在 <code>*</code> 、<code>+</code> 或 <code>?</code> 限定符之后放置 <code>?</code>，该表达式从<strong>贪婪</strong>表达式转换为<strong>非贪婪</strong>表达式或者<strong>最小匹配</strong>。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。&lt;/p&gt;
&lt;h2 id=&quot;为什么使用正则表达式&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
      <category term="正则表达式" scheme="http://yluo.name/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Qt Creator无法输入中文问题</title>
    <link href="http://yluo.name/2020/01/17/qt_im/"/>
    <id>http://yluo.name/2020/01/17/qt_im/</id>
    <published>2020-01-17T06:20:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="1-确认安装fcitx-frontend-qt5"><a href="#1-确认安装fcitx-frontend-qt5" class="headerlink" title="1. 确认安装fcitx-frontend-qt5"></a>1. 确认安装fcitx-frontend-qt5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install fcitx-frontend-qt5</div></pre></td></tr></table></figure><h3 id="2-确认该路径下存在文件"><a href="#2-确认该路径下存在文件" class="headerlink" title="2. 确认该路径下存在文件"></a>2. 确认该路径下存在文件</h3><p>由于Sogou Linux输入法采用的是fcitx框架，因此，需要确认<code>libfcitxplatforminputcontextplugin.so</code>是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts</div><div class="line">ls | grep libfcitx</div></pre></td></tr></table></figure><h3 id="3-将此lib文件复制到Qt与Qt-Creator的对应路径下"><a href="#3-将此lib文件复制到Qt与Qt-Creator的对应路径下" class="headerlink" title="3. 将此lib文件复制到Qt与Qt Creator的对应路径下"></a>3. 将此lib文件复制到Qt与Qt Creator的对应路径下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/</div><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/5.12.2/gcc_64/plugins/platforminputcontexts/</div></pre></td></tr></table></figure><p>随后重启Qt Creator，便可以输入中文了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。&lt;/p&gt;
&lt;h2 id=&quot;解决步
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Qt" scheme="http://yluo.name/tags/Qt/"/>
    
      <category term="输入法" scheme="http://yluo.name/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu右上角状态指示栏顺序配置</title>
    <link href="http://yluo.name/2020/01/16/ubuntu-indicator/"/>
    <id>http://yluo.name/2020/01/16/ubuntu-indicator/</id>
    <published>2020-01-16T02:29:00.000Z</published>
    <updated>2020-02-01T14:31:16.452Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>在Ubuntu中存在一个表单，这个表单里固定了一部分indicator的顺序，这个文件保存在如下位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/share/indicator-application/ordering-override.keyfile</div></pre></td></tr></table></figure><p>若是针对个人用户的配置，可以将ordering-override.keyfile复制到用户目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /usr/share/indicator-application/ordering-override.keyfile ~/.<span class="built_in">local</span>/share/indicators/application/</div></pre></td></tr></table></figure><p>随后利用<code>vim ~/.local/share/indicators/application/ordering-override.keyfile</code>打开<code>.keyfile</code>文件，可以看到，文件里的内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Ordering Index Overrides]</div><div class="line">nm-applet=1</div><div class="line">My_Weather_Indicator=2</div><div class="line">lang_indicator=3</div><div class="line">bluetooth_manager=4</div><div class="line">transmission=6</div></pre></td></tr></table></figure><p>数字越大则越靠近左边，而数字越小则越靠近右边。若想要indicator放置在最左边，则可以使数值为-1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">indicator_sysmonitor=-1</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。&lt;/p&gt;
&lt;h2 id=&quot;设置方法&quot;&gt;&lt;a href=&quot;#设置方法&quot; class=&quot;headerlink&quot; title=&quot;设置方法&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 未知索引格式错误</title>
    <link href="http://yluo.name/2019/09/29/Git_fatal/"/>
    <id>http://yluo.name/2019/09/29/Git_fatal/</id>
    <published>2019-09-29T03:00:00.000Z</published>
    <updated>2020-02-05T13:34:38.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误说明"><a href="#错误说明" class="headerlink" title="错误说明"></a>错误说明</h1><p>运行<code>git status</code>时，提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal: Unknown index entry format xxxxx</div></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>进入仓库文件夹，输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm -f .git/index</div><div class="line">git reset</div></pre></td></tr></table></figure><p>大功告成，喜大普奔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误说明&quot;&gt;&lt;a href=&quot;#错误说明&quot; class=&quot;headerlink&quot; title=&quot;错误说明&quot;&gt;&lt;/a&gt;错误说明&lt;/h1&gt;&lt;p&gt;运行&lt;code&gt;git status&lt;/code&gt;时，提示&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Git" scheme="http://yluo.name/tags/Git/"/>
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：自定义消息类型</title>
    <link href="http://yluo.name/2019/08/06/ros_message/"/>
    <id>http://yluo.name/2019/08/06/ros_message/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2020-02-01T14:31:16.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS消息文件"><a href="#ROS消息文件" class="headerlink" title="ROS消息文件"></a>ROS消息文件</h2><p>ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下，可以被用来生成不同语言的源代码。</p><h2 id="消息数据类型"><a href="#消息数据类型" class="headerlink" title="消息数据类型"></a>消息数据类型</h2><p>ROS中的消息可使用的基本数据类型如下：</p><ul><li>int8, int16, int32, int64 (plus uint*)</li><li>float32, float64</li><li>string</li><li>time, duration</li><li>可变长度的数组，例如int8[]，以及固定长度的数组，例如float32[10]</li></ul><p>ROS消息中还有一个特殊的数据类型：Header， 其含有时间戳和坐标系信息。通常在很多msg文件的第一行有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Header header</div></pre></td></tr></table></figure><p>个人理解（不一定准确），Header类型通常包含在频繁发送的消息中，这样订阅节点可以根据Header中的时间戳信息等做信息同步处理。</p><p>同时，msg文件中还可以包括其他消息文件类型，例如在下面xxx.msg文件中，使用了Header, string以及另外两个消息类型。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Header header</div><div class="line"><span class="built_in">string</span> child_frame_id</div><div class="line">geometry_msgs/PoseWithCovariance pose</div><div class="line">geometry_msgs/TwistWithCovariance twist</div></pre></td></tr></table></figure><h2 id="使用消息"><a href="#使用消息" class="headerlink" title="使用消息"></a>使用消息</h2><p>为了使用消息，需要在package.xml中添加编译依赖和执行依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</div></pre></td></tr></table></figure><p>并且在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</div><div class="line">    ...</div><div class="line">    message_generation</div><div class="line">)</div></pre></td></tr></table></figure><p>同时，利用catkin_package函数设置运行依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catkin_package(</div><div class="line">    ...</div><div class="line">    CATKIN_DEPENDS message_runtime ...</div><div class="line">)</div></pre></td></tr></table></figure><p>并添加需要参与编译的msg文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">add_message_files(</div><div class="line">    FILES</div><div class="line">    xxx.msg</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure><p>确保CMake知道在消息文件更改后重新编译msg文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">generate_messages(</div><div class="line">    DEPENDENCIES</div><div class="line">    std_msgs</div><div class="line">)</div></pre></td></tr></table></figure><p>随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rosmsg命令查看自定义的消息类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosmsg show xxx</div></pre></td></tr></table></figure><h2 id="消息相关命令"><a href="#消息相关命令" class="headerlink" title="消息相关命令"></a>消息相关命令</h2><ul><li>rosmsg show xxx: 查看消息xxx类型，可以不指定功能包名。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ROS消息文件&quot;&gt;&lt;a href=&quot;#ROS消息文件&quot; class=&quot;headerlink&quot; title=&quot;ROS消息文件&quot;&gt;&lt;/a&gt;ROS消息文件&lt;/h2&gt;&lt;p&gt;ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：ROS命名空间及重映射</title>
    <link href="http://yluo.name/2019/08/06/ros_namespace/"/>
    <id>http://yluo.name/2019/08/06/ros_namespace/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2020-02-01T14:31:16.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS的命名"><a href="#ROS的命名" class="headerlink" title="ROS的命名"></a>ROS的命名</h2><p>命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为camera，并且相机可以输出一个话题image，同时读取一个frame_rate的参数来控制发送图像的频率。一个有效的命名具备以下特点：</p><ul><li>首字符为字母（[a-z|A-Z]）、波浪线（～）或左斜杠（/）。（不可以为下划线_）</li><li>后续字符可以是字母或数字（[0-9|a-z|A-Z]）、下划线（_）或者左斜杠（/）</li></ul><p>当一个机器人上存在两个相机时，由于相机的功能几乎完全一样，我们没有必要为两个相机分别编写一个程序，同时，也不想让两个相机的话题都发布在image话题上，这样会导致两个相机的画面交替出现。更一般地，命名的冲突在机器人系统中非常容易发生，这是因为机器人上常常包含相同的硬件或软件来简化工作量，例如相同的左右机械臂、相同的相机以及相同的多个轮子。为了避免命名上的冲突，ROS中采用两种机制来处理这种情况：命名空间和重映射。</p><h2 id="命名空间-Namespace"><a href="#命名空间-Namespace" class="headerlink" title="命名空间 Namespace"></a>命名空间 Namespace</h2><p>命名空间是计算机科学中的一个基本概念。根据UNIX路径和网络URI的规范，ROS使用斜杠（/）来分隔命名空间。ROS可以在不同的命名空间中启动同一个节点来避免命名冲突。</p><p>例如，具有两个相机的机器人可以在不同的命名空间<code>left</code>和<code>right</code>中启动两个相机的节点，最终会有两路图像流，分别为<code>left/image</code>和<code>right/image</code>。</p><h2 id="重映射-Remap"><a href="#重映射-Remap" class="headerlink" title="重映射 Remap"></a>重映射 Remap</h2><p>命名空间避免了命名的冲突，以相机为例，左相机发布的图像流话题为<code>left/image</code>，而在ROS中存在另一个节点nodex，专门接收<code>image</code>话题，由于两个话题在不同的命名空间之下，因此无法接收到左相机的图像信息。为了解决这个问题，一种方法是在同一个命名空间下启动这个节点，即在<code>left</code>命名空间下启动节点nodex，于是节点变为<code>left/nodex</code>，此时接收的image话题也将变为<code>left/image</code>。但是在复杂的程序当中，有可能节点需要“深入”不止一个命名空间之中，十分不方便。因此ROS中还可以用重映射（remap）的方式来解决这个问题。</p><p>在ROS中，程序中任何一个用于命名的字符串都可以在运行时重映射。例如，ROS中的一个常用程序image_view将image主题实时渲染在窗口上。使用重映射，可以使image_view接收<code>left/image</code>或者<code>right/image</code>，而无需修改image_view的代码。</p><h2 id="命名空间和重映射的使用"><a href="#命名空间和重映射的使用" class="headerlink" title="命名空间和重映射的使用"></a>命名空间和重映射的使用</h2><h3 id="在命令行中使用"><a href="#在命令行中使用" class="headerlink" title="在命令行中使用"></a>在命令行中使用</h3><p>由于ROS的设计模式鼓励软件的重用，重命名在开发和部署ROS软件的时候非常普遍。为了简化操作，ROS在命令行启动节点时提供了标准语法来重命名。</p><ul><li><p>将<code>image</code>话题重映射到<code>right/image</code>可以利用重映射语法来完成：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package image_view image:=right/image</div></pre></td></tr></table></figure></li><li><p>把节点放置到命名空间中可以利用<code>__ns</code>命名空间重映射语法来完成：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package camera __ns:=right</div></pre></td></tr></table></figure></li><li><p>修改节点的名字可以利用<code>__name</code>重命名语法来完成：  </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package camera __name:=camera2</div></pre></td></tr></table></figure></li></ul><h3 id="在launch文件中使用"><a href="#在launch文件中使用" class="headerlink" title="在launch文件中使用"></a>在launch文件中使用</h3><ul><li><p>通过设置name参数来确定节点的名字：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;node name=&quot;turtlesim_node2&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot;/&gt;</div></pre></td></tr></table></figure></li><li><p>通过设置ns参数来确定默认命名空间：    </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;node name=&quot;turtlesim_node&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot; ns=&quot;sim1&quot; /&gt;</div></pre></td></tr></table></figure></li><li><p>通过remap标签设置重映射：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;remap from=&quot;image&quot; to=&quot;right/image&quot;/&gt;</div></pre></td></tr></table></figure></li></ul><h3 id="在ROS程序终端中使用"><a href="#在ROS程序终端中使用" class="headerlink" title="在ROS程序终端中使用"></a>在ROS程序终端中使用</h3><p>可以利用环境变量设置默认命名空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> ROS_NAMESPACE=default-namespace</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ROS的命名&quot;&gt;&lt;a href=&quot;#ROS的命名&quot; class=&quot;headerlink&quot; title=&quot;ROS的命名&quot;&gt;&lt;/a&gt;ROS的命名&lt;/h2&gt;&lt;p&gt;命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为cam
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：自定义服务</title>
    <link href="http://yluo.name/2019/08/06/ros_service/"/>
    <id>http://yluo.name/2019/08/06/ros_service/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS中的服务"><a href="#ROS中的服务" class="headerlink" title="ROS中的服务"></a>ROS中的服务</h1><p>服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（Request），由服务端（Server）节点处理后反馈应答（Response）。</p><h1 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h1><p>ROS中的服务可以通过srv文件夹下的xxx.srv文件进行语言无关的接口定义。文件包括请求与应答两个数据域，使用“—-”进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int64 a</div><div class="line">int64 b</div><div class="line">---</div><div class="line">int64 sum</div></pre></td></tr></table></figure><h1 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h1><p>首先需要在package.xml文件表明对消息生成系统的依赖，即构建依赖项message_generation和运行依赖项message_runtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;build_depend&gt;rospy&lt;/build_depend&gt;</div><div class="line">&lt;run_depend&gt;rospy&lt;/run_depend&gt;</div><div class="line"></div><div class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;</div></pre></td></tr></table></figure><p>随后在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find_package(catkin REQUIRED COMPONENTS</div><div class="line">    ...</div><div class="line">    message_generation</div><div class="line">)</div></pre></td></tr></table></figure></p><p>同时，利用catkin_package函数设置运行依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catkin_package(</div><div class="line">    ...</div><div class="line">    CATKIN_DEPENDS message_runtime ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>并添加需要参与编译的srv文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">add_service_files(</div><div class="line">    FILES</div><div class="line">    xxx.srv</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>确保CMake知道在消息文件更改后重新编译msg文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">generate_messages(</div><div class="line">    DEPENDENCIES</div><div class="line">    std_msgs</div><div class="line">)</div></pre></td></tr></table></figure></p><p>随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rossrv命令检验服务的定义是否和我们想的一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rossrv show xxx</div></pre></td></tr></table></figure></p><p>还可以使用rossrv list来查看所有可用的服务，使用rossrv packages来查看所有提供了服务的包，使用rossrv package xxx来查看xxx功能包提供的服务。</p><p>注意，ROS中还有一个命令rosservice，这个命令是用来在ROS运行时和启动的服务进行交互的命令，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice call /spawn 8.0 8.0 0.0 &apos;turtle2&apos;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS中的服务&quot;&gt;&lt;a href=&quot;#ROS中的服务&quot; class=&quot;headerlink&quot; title=&quot;ROS中的服务&quot;&gt;&lt;/a&gt;ROS中的服务&lt;/h1&gt;&lt;p&gt;服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（R
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：CMakeLists.txt文件</title>
    <link href="http://yluo.name/2019/08/06/ros_cmakelist/"/>
    <id>http://yluo.name/2019/08/06/ros_cmakelist/</id>
    <published>2019-08-06T06:17:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><p>ROS中使用的编译器catkin是对cmake的一种封装，因此编译规则使用的也是CMakeLists.txt文件，关于CMakeLists.txt文件的规则之前在博客中已经提及过，不再赘述。</p><h1 id="编译规则"><a href="#编译规则" class="headerlink" title="编译规则"></a>编译规则</h1><p>在ROS功能包中的CMakeLists文件主要包括以下配置项：</p><ul><li>project(PROJ_NAME): 项目名称，一般情况下使用catkin_create_pkg命令会自动生成；</li><li>find_package(catkin REQUIRED COMPONTS rospy roscpp …): 寻找相关的功能包；</li><li>include_directories(include ${catkin_INCLUDE_DIRES}): 设置头文件的相对路径，通常在功能包下将相关的头文件都放置在include文件夹下；</li><li>add_executable(node_name src/xxx.cpp): 设置需要编译的代码和生成的可执行文件；</li><li>target_link_libraries(node_name ${catkin_LIBRARIES}): 设置链接库；</li><li>add_dependencies(node_name ${PROJECT_NAME}_generate_messages_cpp): 设置依赖，一般情况下自定义了消息类型的话便需要添加依赖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CMakeLists-txt&quot;&gt;&lt;a href=&quot;#CMakeLists-txt&quot; class=&quot;headerlink&quot; title=&quot;CMakeLists.txt&quot;&gt;&lt;/a&gt;CMakeLists.txt&lt;/h1&gt;&lt;p&gt;ROS中使用的编译器catkin是对cmak
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：package清单文件</title>
    <link href="http://yluo.name/2019/08/06/ros_package_xml/"/>
    <id>http://yluo.name/2019/08/06/ros_package_xml/</id>
    <published>2019-08-06T06:00:00.000Z</published>
    <updated>2020-02-02T14:11:00.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="package清单文件"><a href="#package清单文件" class="headerlink" title="package清单文件"></a>package清单文件</h1><p>每一个ROS的功能包都包含一个package.xml的功能包清单文件，用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p><h1 id="package-xml规则"><a href="#package-xml规则" class="headerlink" title="package.xml规则"></a>package.xml规则</h1><p>package.xml文件采用xml标记语言来编写，其中的主要信息包括一下几种：</p><ul><li>name: 功能包的名称；</li><li>version: 功能包的版本；</li><li>description: 功能包的描述；</li><li>maintainer: 功能包的维护者信息；</li><li>license: 许可信息，MIT，BSD，GPL等；</li></ul><p>除此之外，package.xml中还包含了功能包所需的各种依赖项，主要包括：</p><ul><li>buildtool_depend: 编译工具依赖项，通常为catkin；</li><li>build_depend: 功能包代码编译所需的依赖项，例如roscpp，rospy，geometry_msgs，message_generation等；</li><li>run_depend: 功能包运行过程中所需的依赖项，例如roscpp，rospy，std_msgs，message_runtime等；</li></ul><p>如果是元功能包，则还需包含一个引用标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;export&gt;</div><div class="line">   &lt;metapackage/&gt;</div><div class="line">&lt;/export&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;package清单文件&quot;&gt;&lt;a href=&quot;#package清单文件&quot; class=&quot;headerlink&quot; title=&quot;package清单文件&quot;&gt;&lt;/a&gt;package清单文件&lt;/h1&gt;&lt;p&gt;每一个ROS的功能包都包含一个package.xml的功能包清单文件
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
</feed>
