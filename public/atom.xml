<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DécouVerte</title>
  
  <subtitle>生命不息 折腾不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yluo.name/"/>
  <updated>2020-03-19T08:43:50.812Z</updated>
  <id>http://yluo.name/</id>
  
  <author>
    <name>Yang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：launch启动文件</title>
    <link href="http://yluo.name/2020/03/19/ros-launch/"/>
    <id>http://yluo.name/2020/03/19/ros-launch/</id>
    <published>2020-03-19T05:39:13.000Z</published>
    <updated>2020-03-19T08:43:50.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="launch文件作用"><a href="#launch文件作用" class="headerlink" title="launch文件作用"></a>launch文件作用</h2><p>通过XML文件实现多节点的配置和启动。还可以自动启动ROS Master节点管理器（roscore），并可以实现每个节点的各种配置，为多个节点的操作提供便利。</p><h2 id="launch文件格式"><a href="#launch文件格式" class="headerlink" title="launch文件格式"></a>launch文件格式</h2><p>XML是一种可扩展标记语言（EXtensible Markup Language），靠一个个元素的嵌套构成。被设计为传输和存储数据，焦点是数据的内容。</p><h3 id="lt-launch-gt-标签"><a href="#lt-launch-gt-标签" class="headerlink" title="&lt;launch&gt;标签"></a><code>&lt;launch&gt;</code>标签</h3><p>XML文件必须包含一个根标签，launch文件的根标签采用<code>&lt;launch&gt;</code>，其他内容均包含在此标签中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="lt-node-gt-标签"><a href="#lt-node-gt-标签" class="headerlink" title="&lt;node&gt;标签"></a><code>&lt;node&gt;</code>标签</h3><p><code>&lt;node&gt;</code>用来启动ROS节点，相当于在终端执行<code>rosrun</code>，其语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"node-name"</span> <span class="attr">pkg</span>=<span class="string">"package-name"</span> <span class="attr">type</span>=<span class="string">"executable-name"</span> /&gt;</span></div></pre></td></tr></table></figure><p><code>name</code>属性定义节点运行的名称，将覆盖节点中<code>init()</code>赋予节点的名称；<code>pkg</code>定义节点所在功能包名称；<code>type</code>定义节点的可执行文件名称。</p><p>还有一些额外的属性：</p><ul><li><code>output=&quot;screen&quot;</code>:将节点标准输出打印到终端屏幕，默认输出为日志文档(log);</li><li><code>respawn=&quot;true&quot;</code>:复位属性，节点停止会自动重启，默认为<code>false</code>;</li><li><code>required=&quot;true&quot;</code>:必要节点，当该节点终止时，launch中其他节点也终止;</li><li><code>ns=&quot;namespace&quot;</code>:命名空间，为节点相对名称添加命名空间前缀;</li><li><code>args=&quot;arguments&quot;</code>:节点需要的输入参数，<strong>注意是<code>args</code>不是<code>arg</code>，<code>args</code>是node属性，<code>arg</code>是标签</strong>。</li></ul><h3 id="lt-arg-gt-标签"><a href="#lt-arg-gt-标签" class="headerlink" title="&lt;arg&gt;标签"></a><code>&lt;arg&gt;</code>标签</h3><p><code>&lt;arg&gt;</code>用于定义launch文件中的局部变量，仅可以在当前的launch中使用，便于launch文件重构。其语法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"arg-name&gt;"</span> <span class="attr">default</span>=<span class="string">"arg-value"</span> /&gt;</span></div></pre></td></tr></table></figure><p><code>default</code>属性未给<code>&lt;arg&gt;</code>赋值时的默认值，launch文件需要<code>&lt;arg&gt;</code>定义的参数时，可以使用<code>$(arg arg-name)</code>的方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"$(arg arg-name)"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">"node"</span> <span class="attr">pkg</span>=<span class="string">"pkg"</span> <span class="attr">type</span>=<span class="string">"type"</span> <span class="attr">args</span>=<span class="string">"$(arg arg-name)"</span> /&gt;</span></div></pre></td></tr></table></figure><h3 id="lt-param-gt-标签"><a href="#lt-param-gt-标签" class="headerlink" title="&lt;param&gt;标签"></a><code>&lt;param&gt;</code>标签</h3><p><code>&lt;param&gt;</code>使运行时存储在ROS参数服务器中的参数，相当于全局变量，在launch文件执行后便加载到ROS参数服务器中。任何节点都可以通过<code>ros::param::get()</code>接口来获取paramter的值，也可以在终端通过<code>rosparam</code>指令来获取参数的值。其使用方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param-name"</span> <span class="attr">value</span>=<span class="string">"param-value"</span> /&gt;</span></div></pre></td></tr></table></figure><p>运行之后在参数服务器中便会加载一个<code>param-name</code>的参数，其值被设置为<code>param-value</code>。为了解决很多参数同时加载的问题，ROS还同时提供了<code>&lt;rosparam&gt;</code>标签，可以一次性加载多个参数，其使用方法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">"/path/to/package/config/params.yaml"</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">ns</span>=<span class="string">"namespace"</span> /&gt;</span></div></pre></td></tr></table></figure><p><code>&lt;rosparam&gt;</code>将<code>params.yaml</code>文件中存储的参数全部加载到ROS的参数服务器中，需要设置<code>command</code>属性设置为<code>load</code>，而且可以设置命名空间，设置后，参数名称前缀会变为<code>/namespace/</code>。</p><h3 id="lt-remap-gt-标签"><a href="#lt-remap-gt-标签" class="headerlink" title="&lt;remap&gt;标签"></a><code>&lt;remap&gt;</code>标签</h3><p><code>&lt;remap&gt;</code>标签的目的是提供一种重映射机制，相当于给变量取别名。当在网上下载了一个功能包时，无法保证其接口和自己设计的接口一致，这时采用<code>&lt;remap&gt;</code>标签，可以不改动别人功能包接口的情况下，完成和自身功能包接口的通讯。</p><p>比如turtlebot的控制节点发布的速度指令话题是<code>/turtlebot/cmd_vel</code>，但我们自己设计的机器人订阅的速度控制话题是<code>myrobot/cmd_vel</code>，则可以在加载turtlebot速度控制节点时，利用<code>&lt;remap&gt;</code>标签将话题从<code>/turtlebot/cmd_vel</code>重映射到<code>myrobot/cmd_vel</code>，便可以让自己的机器人接收速度指令了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">"/turtlebot/cmd_vel"</span> <span class="attr">to</span>=<span class="string">"/cmd_vel"</span> /&gt;</span></div></pre></td></tr></table></figure><p><strong>注意：ROS中重映射方式很多，使用也很广泛，也可以直接在终端进行重映射。</strong></p><h3 id="lt-include-gt-标签"><a href="#lt-include-gt-标签" class="headerlink" title="&lt;include&gt;标签"></a><code>&lt;include&gt;</code>标签</h3><p>在复杂系统中存在多个launch文件，互相之间也存在依赖。<code>&lt;include&gt;</code>标签可以包含其他launch文件，复用其中的内容，相当于C语言中include头文件。其使用方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"/path/to/file/other.launch"</span> /&gt;</span></div></pre></td></tr></table></figure><p>若在other.launch文件中存在需要赋值的<code>&lt;arg&gt;</code>标签等，则也可以如下调用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"/path/to/file/other.launch"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"other-arg-name"</span> <span class="attr">value</span>=<span class="string">"$(arg arg-name)"</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更多roslaunch的用法和标签元素可以通过访问<a href="https://wiki.ros.org/roslaunch" target="_blank" rel="external">https://wiki.ros.org/roslaunch</a>来学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;launch文件作用&quot;&gt;&lt;a href=&quot;#launch文件作用&quot; class=&quot;headerlink&quot; title=&quot;launch文件作用&quot;&gt;&lt;/a&gt;launch文件作用&lt;/h2&gt;&lt;p&gt;通过XML文件实现多节点的配置和启动。还可以自动启动ROS Master节点
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Linux目录树</title>
    <link href="http://yluo.name/2020/02/21/linux-dir/"/>
    <id>http://yluo.name/2020/02/21/linux-dir/</id>
    <published>2020-02-21T15:26:18.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>在Linux下，所有文件与目录都是由根目录开始，然后一个个的分支下来，如树枝状。因此把这种目录配置方式称为<strong>目录树（Directory Tree）</strong>。Linux目录树主要有以下特征：</p><ul><li>目录树的起始点为根目录（/）；</li><li>每一个目录不只能使用本地端文件系统，也可以使用网络上的文件系统。可以利用Network File System（NFS）服务器挂载特定目录；</li><li>每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。</li></ul><h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h2><p>因为Linux有各式各样的版本，如果每个版本都采用不同的目录结构，则会对使用者造成很大的困扰。为了解决这个问题，提出了Filesystem Hierarchy Standard（FHS）标准，目前几乎所有的Linux版本目录配置均遵循FHS标准。</p><p>FHS标准其实就是规范了每个特定目录下应该放置什么样子的数据，这样使得不同的Linux系统保持目录架构基本一致，同时又可以根据有一些灵活配置。而使用者在不同Linux系统下切换更加容易。</p><h2 id="各个目录的功能"><a href="#各个目录的功能" class="headerlink" title="各个目录的功能"></a>各个目录的功能</h2><p>为了能够简单明了的表示各个目录的功能，做了一个目录树的图。从根目录开始，各个目录均存放对应类型的数据。</p><p> <img src="/images/linux_dir.svg" alt="Linux Directory Tree"></p><p>多说一句，除了FHS之外，还有一个Linux Standard Base（LSB）标准可以遵循。可以使用<code>lsb_release -a</code>查询目前的Linux发行版是否支持LSB标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录树&quot;&gt;&lt;a href=&quot;#目录树&quot; class=&quot;headerlink&quot; title=&quot;目录树&quot;&gt;&lt;/a&gt;目录树&lt;/h2&gt;&lt;p&gt;在Linux下，所有文件与目录都是由根目录开始，然后一个个的分支下来，如树枝状。因此把这种目录配置方式称为&lt;strong&gt;目录树（D
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="目录树" scheme="http://yluo.name/tags/%E7%9B%AE%E5%BD%95%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件权限</title>
    <link href="http://yluo.name/2020/02/18/linux-permission/"/>
    <id>http://yluo.name/2020/02/18/linux-permission/</id>
    <published>2020-02-18T14:08:18.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><p>在Linux终端下输入<code>ls -al</code>，可以看到当前文件夹下文件的详细信息，其通常的形式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rwxr--r-- 1 root  root  1864 May 4 18:00 initial-setup.cfg</div></pre></td></tr></table></figure><p>其中前10个字符<code>-rwxr--r--</code>便代表着文件类型与权限。</p><ul><li><p>第1个字符代表文件类型，<code>-</code>为文件，<code>d</code>为目录，<code>l</code>为链接，<code>b</code>表示设备文件中的可随机存取装置（U盘、硬盘等），<code>c</code>表示设备文件中的串行端口设备（鼠标、键盘等一次性读取装置）。</p></li><li><p>接下来的9个字符，每3个为一组，均为<code>rwx</code>的组合。<code>r</code>表示可读，<code>w</code>表示可写，<code>x</code>表示可执行，如果没有对应的权限，则对应位置为<code>-</code>。</p></li></ul><p>之所以会存在3组，是因为在Linux下文件的权限可分为<strong>文件拥有者的权限</strong>、<strong>文件所属群组的权限</strong>与<strong>其他人的权限</strong>。由于Linux系统是针对多用户设计的，这种分别是为了保证多用户场景下的数据安全。比如文件拥有者是小明，而小明是三年二班这个群组的班长，小明发布了一份公告文件，小明希望这份文件他自己可以查看和修改，所有班级成员都可以查看，但是其他班级的人不能够看到，则可以设置这个文件的权限为<code>rw- r-- ---</code>，这样的话，便满足了要求。</p><h2 id="文件权限修改"><a href="#文件权限修改" class="headerlink" title="文件权限修改"></a>文件权限修改</h2><p>Linux下的文件权限是与使用者、群组相关的，系统提供了三个用来修改文件权限的命令：</p><ul><li><code>chgrp</code>：改变文件所属群组；</li><li><code>chown</code>：改变文件拥有者；</li><li><code>chmod</code>：改变文件的读、写、执行权限。</li></ul><h3 id="改变群组chgrp"><a href="#改变群组chgrp" class="headerlink" title="改变群组chgrp"></a>改变群组chgrp</h3><p>用法：<code>chgrp [-R] FILE_OR_DIR</code>，其中<code>-R</code>为进行递归变更，常用在变更目录内所有文件权限。</p><h3 id="改变拥有者chown"><a href="#改变拥有者chown" class="headerlink" title="改变拥有者chown"></a>改变拥有者chown</h3><p>用法与<code>chgrp</code>类似：<code>chown [-R] USER:GROUP FILE_OR_DIR</code>，可以同时修改拥有者和群组，比较方便。</p><h3 id="改变权限chmod"><a href="#改变权限chmod" class="headerlink" title="改变权限chmod"></a>改变权限chmod</h3><p>权限的使用有两种方法，一种是利用数字类型改变文件权限，一种是利用符号类型改变文件权限。</p><p>对于数字类型改变权限，<code>rwx</code>三者对应的数值为<code>421</code>，因此3组权限可以用对应数值累加来计算权限，比如<code>rwxr-xr--</code>便可以用数字表示为<code>754</code>，因此设置权限为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod [-R] 754 FILE_OR_DIR</div></pre></td></tr></table></figure><p>对于符号类型改变权限，3组权限可由<code>ugo</code>分别代表user，group，others三种身份，此外<code>a</code>代表全部身份；而<code>rwx</code>则代表读写权限，因此设置权限为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod [-R] [ugoa] [+-=] [rwx] FILE_OR_DIR</div></pre></td></tr></table></figure><p>例如要设置一个文件权限为<code>-rwxr-xr-x</code>，则可以为<code>chmod u=rwx,go=rx FILE_OR_DIR</code>。此外，若不知道原先文件属性，只想增加每个人均可以写入的权限，则可以为<code>chmod a+w FILE_OR_DIR</code>。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>对于文件来说，<code>w</code>权限代表可以编辑、新增或修改文件内容，但是不可以修改文件。</p></li><li><p>对于目录来说，<code>w</code>权限代表可以新建、删除、重命名目录与文件（与该目录下的文件名异动有关）；<code>x</code>代表可以进入目录成为工作目录，若目录权限中只有<code>r</code>而没有<code>x</code>，则无法进入该目录。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux文件权限&quot;&gt;&lt;a href=&quot;#Linux文件权限&quot; class=&quot;headerlink&quot; title=&quot;Linux文件权限&quot;&gt;&lt;/a&gt;Linux文件权限&lt;/h2&gt;&lt;p&gt;在Linux终端下输入&lt;code&gt;ls -al&lt;/code&gt;，可以看到当前文件夹下文
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="文件权限" scheme="http://yluo.name/tags/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>对科学问题的一点理解</title>
    <link href="http://yluo.name/2020/02/15/scientific-problem/"/>
    <id>http://yluo.name/2020/02/15/scientific-problem/</id>
    <published>2020-02-15T04:36:13.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是科学问题"><a href="#什么是科学问题" class="headerlink" title="什么是科学问题"></a>什么是科学问题</h2><p>在写基金或写论文的时候，我经常会纠结于<strong>什么是科学问题？</strong>，<strong>什么是工程问题？</strong>。我相信很多科研人员都会有这种困惑：到底什么才是科学问题？我谈一谈自己对科学问题的理解吧。</p><h2 id="科学问题的启发"><a href="#科学问题的启发" class="headerlink" title="科学问题的启发"></a>科学问题的启发</h2><p>有一天参加所里的学术会议，主任讲了一个很有意思的事，他有一次和机器人行业大佬孙立宁教授在酒席上，曾听孙教授说过一个关于<strong>科学问题</strong>的比喻：</p><blockquote><p>我说我要研究“人如何用筷子？”，这不是一个科学问题；</p><p>可是我要说“多自由度冗余关节的双刚体协同运动控制”，这就是一个科学问题。</p></blockquote><h2 id="我对科学问题的理解"><a href="#我对科学问题的理解" class="headerlink" title="我对科学问题的理解"></a>我对科学问题的理解</h2><p>这个事给了我很大的启发，让我自己对科学问题有了很直观的理解。在我的理解中，科学问题是：</p><blockquote><p>能够揭示规律、原理，同时具有抽象、泛化意义，能够对一类的事物都具有应用价值。</p></blockquote><p>可能我的总结不准确，但我想表达的是，科学问题并不是对现实世界的直观描述，需要看透现象本质，找寻背后的规律原理，通过总结提炼，才可以称之为<strong>科学问题</strong>。</p><p>就以孙立宁教授的例子为例，“人如何用筷子？”之所以不是科学问题，是因为这只是现实世界的直观描述，并没有深入现象本质。如何定义人？人有什么特点？筷子又是什么？有什么特点？人和筷子只是特定事物的名字而已。人用筷子，对人来说，可以抽象成多自由度冗余关节，因为在用筷子这件事中，<strong>人</strong>对外的表现就是<strong>多自由度冗余关节</strong>，而<strong>筷子</strong>就是<strong>双刚体</strong>，<strong>用筷子</strong>就是对双刚体的<strong>协同运动控制</strong>。</p><p>于是经过提炼，可以从现象表面发现现象本质，对<strong>多自由度冗余关节的双刚体协同运动控制</strong>进行研究，是可以推广到很多其他领域，比如多机械臂协同作业等，是具有很强的泛化抽象意义的。这种问题当然就是<strong>科学问题</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是科学问题&quot;&gt;&lt;a href=&quot;#什么是科学问题&quot; class=&quot;headerlink&quot; title=&quot;什么是科学问题&quot;&gt;&lt;/a&gt;什么是科学问题&lt;/h2&gt;&lt;p&gt;在写基金或写论文的时候，我经常会纠结于&lt;strong&gt;什么是科学问题？&lt;/strong&gt;，&lt;stro
      
    
    </summary>
    
      <category term="学术天地" scheme="http://yluo.name/categories/%E5%AD%A6%E6%9C%AF%E5%A4%A9%E5%9C%B0/"/>
    
    
      <category term="基金" scheme="http://yluo.name/tags/%E5%9F%BA%E9%87%91/"/>
    
      <category term="科学问题" scheme="http://yluo.name/tags/%E7%A7%91%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Bash下的快捷键</title>
    <link href="http://yluo.name/2020/02/14/bash-shortcuts/"/>
    <id>http://yluo.name/2020/02/14/bash-shortcuts/</id>
    <published>2020-02-14T15:12:46.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<p>使用Linux终端的一个重要的原则就是：不要让你的手指离开<strong>本位行</strong>，这对于一个程序员来说是十分重要的，之前由于不知道Bash下的快捷键，导致经常需要去利用方向键来调整命令输入，比如：已经输入了很长一段指令，结果发现必须要用管理员来运行，没办法，只能靠方向键一直将光标移至命令开头，然后敲上<code>sudo</code>，是不是很麻烦？于是乎，Bash下的快捷键就可以快速地帮助你，当你按下<code>&lt;C-a&gt;</code>或者<code>&lt;C-xx&gt;</code>时，便自动移动到了行首，随后便可以潇洒地输入<code>sudo</code>，飘逸地一个回车，把B装到了极致。</p><p>下面是一些终端命令快捷键的总结：</p><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;C-a&gt;</code>或<code>Home</code></td><td style="text-align:left">移动到行首</td></tr><tr><td style="text-align:left"><code>&lt;C-e&gt;</code>或<code>End</code></td><td style="text-align:left">移动到行尾</td></tr><tr><td style="text-align:left"><code>&lt;ALT-b&gt;</code></td><td style="text-align:left">后移一个单词</td></tr><tr><td style="text-align:left"><code>&lt;C-b&gt;</code></td><td style="text-align:left">后移一个字符</td></tr><tr><td style="text-align:left"><code>&lt;ALT-f&gt;</code></td><td style="text-align:left">前移一个单词</td></tr><tr><td style="text-align:left"><code>&lt;C-f&gt;</code></td><td style="text-align:left">前移一个字符</td></tr><tr><td style="text-align:left"><code>&lt;C-xx&gt;</code></td><td style="text-align:left">当前和行首位置切换</td></tr></tbody></table></div><h2 id="剪切删除"><a href="#剪切删除" class="headerlink" title="剪切删除"></a>剪切删除</h2><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;C-w&gt;</code></td><td style="text-align:left">剪切光标前单词</td></tr><tr><td style="text-align:left"><code>&lt;C-k&gt;</code></td><td style="text-align:left">剪切光标后内容移动到行尾</td></tr><tr><td style="text-align:left"><code>&lt;C-u&gt;</code></td><td style="text-align:left">剪切光标前内容</td></tr><tr><td style="text-align:left"><code>&lt;C-y&gt;</code></td><td style="text-align:left">粘贴剪切板内容</td></tr><tr><td style="text-align:left"><code>&lt;C-d&gt;</code></td><td style="text-align:left">删除当前字符</td></tr><tr><td style="text-align:left"><code>&lt;ALT-d&gt;</code></td><td style="text-align:left">删除光标后所有字符</td></tr><tr><td style="text-align:left"><code>&lt;C-h&gt;</code></td><td style="text-align:left">删除前一字符</td></tr></tbody></table></div><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;C-c&gt;</code></td><td style="text-align:left">终止当前进程</td></tr><tr><td style="text-align:left"><code>&lt;C-z&gt;</code></td><td style="text-align:left">挂起当前进程，可用<code>fg</code>恢复</td></tr><tr><td style="text-align:left"><code>&lt;C-d&gt;</code></td><td style="text-align:left">关闭shell，同<code>exit</code></td></tr></tbody></table></div><h2 id="屏幕控制"><a href="#屏幕控制" class="headerlink" title="屏幕控制"></a>屏幕控制</h2><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;C-l&gt;</code></td><td style="text-align:left">清屏，同<code>clear</code></td></tr><tr><td style="text-align:left"><code>&lt;C-s&gt;</code></td><td style="text-align:left">停止屏幕输出</td></tr><tr><td style="text-align:left"><code>&lt;C-q&gt;</code></td><td style="text-align:left">恢复屏幕输出</td></tr></tbody></table></div><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;ALT-u&gt;</code></td><td style="text-align:left">大写光标位置到单词尾间的字母</td></tr><tr><td style="text-align:left"><code>&lt;ALT-l&gt;</code></td><td style="text-align:left">小写光标位置到单词尾间的字母</td></tr><tr><td style="text-align:left"><code>&lt;ALT-c&gt;</code></td><td style="text-align:left">大写当前单词</td></tr></tbody></table></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><div class="table-container"><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;ALT-T&gt;</code></td><td style="text-align:left">当前单词和前一单词互换</td></tr><tr><td style="text-align:left"><code>&lt;C-T&gt;</code></td><td style="text-align:left">互换光标前两单词位置</td></tr><tr><td style="text-align:left"><code>&lt;C-_&gt;</code></td><td style="text-align:left">撤销</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Linux终端的一个重要的原则就是：不要让你的手指离开&lt;strong&gt;本位行&lt;/strong&gt;，这对于一个程序员来说是十分重要的，之前由于不知道Bash下的快捷键，导致经常需要去利用方向键来调整命令输入，比如：已经输入了很长一段指令，结果发现必须要用管理员来运行，没办法
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Bash" scheme="http://yluo.name/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>用Microsoft To Do做待办管理</title>
    <link href="http://yluo.name/2020/02/08/todo-intro/"/>
    <id>http://yluo.name/2020/02/08/todo-intro/</id>
    <published>2020-02-08T05:55:45.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<p>强烈安利一款软件：Microsoft To Do，用来实现待办事项管理。可以实现PC端、手机端的同步，实时管理和查看，十分方便。</p><h2 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h2><p>在Microsoft Store中下载即可。</p><h2 id="手机端安装"><a href="#手机端安装" class="headerlink" title="手机端安装"></a>手机端安装</h2><p>在应用市场下载</p><h2 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h2><p>Linux下没有To Do的安装包，但是有一个开源软件Ao可以下载，在Github上可以下载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;强烈安利一款软件：Microsoft To Do，用来实现待办事项管理。可以实现PC端、手机端的同步，实时管理和查看，十分方便。&lt;/p&gt;
&lt;h2 id=&quot;Windows下安装&quot;&gt;&lt;a href=&quot;#Windows下安装&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="To Do" scheme="http://yluo.name/tags/To-Do/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04下Terminator支持256色</title>
    <link href="http://yluo.name/2020/02/07/terminator-256color/"/>
    <id>http://yluo.name/2020/02/07/terminator-256color/</id>
    <published>2020-02-07T11:56:31.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Ubuntu 16.04下利用<code>apt install terminator</code>安装Terminator后，其版本为0.98。而0.98版本的Terminator默认不支持256色，导致终端下无法显示很多颜色，看上去很难受。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>打开Terminator，在<code>Preferences</code>中选择<code>Profiles</code>；</li><li>在<code>Command</code>选项卡中，将<code>Run a custom command instead of my shell</code>选中；</li><li>在<code>Custom command</code> 中输入<code>TERM=xterm-256color bash -l</code></li></ol><p>随后重启Terminator，便可以看到已经支持256色，终端里显示出了更多的颜色，来区分不同的项目了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在Ubuntu 16.04下利用&lt;code&gt;apt install terminator&lt;/code&gt;安装Terminato
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Terminator" scheme="http://yluo.name/tags/Terminator/"/>
    
  </entry>
  
  <entry>
    <title>Windows Powershell运行自定义脚本</title>
    <link href="http://yluo.name/2020/02/05/powershell-run-script/"/>
    <id>http://yluo.name/2020/02/05/powershell-run-script/</id>
    <published>2020-02-05T13:35:53.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Windows Powershell为了防止恶意脚本的执行，设计了一个执行策略(Execution Policy)，若发现自定义的脚本无法运行，则需要更改执行策略。</p><p>执行策略包括6种类型：</p><ul><li>Restricted 受限制的，只能执行单个命令，不能执行脚本</li><li>AllSigned 允许执行有数字签名的脚本</li><li>RemoteSigned 本地脚本可以运行，网络下载的需要数字签名</li><li>Unrestricted 无限制，但从网络下载的会有安全提示</li><li>Bypass 不设任何限制，且没有安全提示</li><li>Undefined 未设置策略，使用继承或默认策略</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>利用管理员身份打开Powershell终端，输入以下命令将策略更改为<code>RemoteSigned</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ Set-ExecutionPolicy RemoteSigned</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;Windows Powershell为了防止恶意脚本的执行，设计了一个执行策略(Execution Policy)，若发现自
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Windows" scheme="http://yluo.name/tags/Windows/"/>
    
      <category term="Powershell" scheme="http://yluo.name/tags/Powershell/"/>
    
  </entry>
  
  <entry>
    <title>Git利用rebase压缩多次commit</title>
    <link href="http://yluo.name/2020/02/05/git-rebase/"/>
    <id>http://yluo.name/2020/02/05/git-rebase/</id>
    <published>2020-02-05T13:19:59.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有时我们提交到GitHub等远程仓库上的commit太多，想将多次提交的commit合并成一个commit。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以利用rebase来压缩多次commit。</p><h3 id="1-首先查看本地提交历史"><a href="#1-首先查看本地提交历史" class="headerlink" title="1. 首先查看本地提交历史"></a>1. 首先查看本地提交历史</h3><p>输入以下命令查看master分支的提交历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log</div></pre></td></tr></table></figure><p>这里会显示master分支自创立以来的所有提交历史，现在假设要合并最近的4次提交。</p><h3 id="2-压缩最近4次提交"><a href="#2-压缩最近4次提交" class="headerlink" title="2. 压缩最近4次提交"></a>2. 压缩最近4次提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase -i HEAD~4</div></pre></td></tr></table></figure><p>该命令执行后，会弹出默认编辑器的编辑窗口，4次提交的信息会倒序排列，最新的提交在最下面。</p><p>我们需要将其中第2~4行的第一个单词<code>pick</code>修改为<code>squash</code>这意味着将最后三次提交压缩到倒数第4次提交。随后保存。</p><h3 id="3-处理冲突"><a href="#3-处理冲突" class="headerlink" title="3. 处理冲突"></a>3. 处理冲突</h3><p>若有冲突，则会提示需要修改，修改后输入以下命令保存此次压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git rebase --continue</div></pre></td></tr></table></figure><p>如果想要放弃此次压缩，则输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$git rebase --abort</div></pre></td></tr></table></figure><h3 id="4-修改描述信息"><a href="#4-修改描述信息" class="headerlink" title="4. 修改描述信息"></a>4. 修改描述信息</h3><p>若没有冲突处理，则会直接跳转到修改描述信息的位置，可以修改此次压缩后的commit描述。随后保存。</p><h3 id="5-提交到远程仓库"><a href="#5-提交到远程仓库" class="headerlink" title="5. 提交到远程仓库"></a>5. 提交到远程仓库</h3><p>修改完描述信息后便已经完成了提交，若想要推送的远程仓库，则需要覆盖之前的提交，需要强制推送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push -f</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;有时我们提交到GitHub等远程仓库上的commit太多，想将多次提交的commit合并成一个commit。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Git" scheme="http://yluo.name/tags/Git/"/>
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu蓝牙不可用</title>
    <link href="http://yluo.name/2020/02/03/ubuntu-bluetooth-disabled/"/>
    <id>http://yluo.name/2020/02/03/ubuntu-bluetooth-disabled/</id>
    <published>2020-02-03T02:43:10.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>之前在Ubuntu下不小心删除了<code>/var/lib/bluetooth/</code>下的文件夹，导致蓝牙界面一直显示disabled。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在终端里输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rfkill unblock bluetooth</div></pre></td></tr></table></figure><p>随后重启系统并打开蓝牙，蓝牙便显示enabled了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;之前在Ubuntu下不小心删除了&lt;code&gt;/var/lib/bluetooth/&lt;/code&gt;下的文件夹，导致蓝牙界面一直
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Bluetooth" scheme="http://yluo.name/tags/Bluetooth/"/>
    
  </entry>
  
  <entry>
    <title>Windows无法进入睡眠</title>
    <link href="http://yluo.name/2020/02/03/windows-sleep/"/>
    <id>http://yluo.name/2020/02/03/windows-sleep/</id>
    <published>2020-02-03T02:28:25.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>自己家的台式机在接通电源的情况下点击开始菜单-&gt;电源-&gt;睡眠，依然无法睡眠，会始终自动唤醒。这是由于Windows开启了<strong>离开模式</strong>(Away Mode)，一般来说能够改变到离开模式的软件主要有：</p><ul><li><strong>迅雷</strong>：离开模式下载；</li><li><strong>百度网盘</strong>：传输时不休眠。</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>按<code>WIN</code>+<code>R</code>打开<strong>运行</strong></li><li>输入<code>regedit</code>打开注册表编辑器</li><li>定位到<strong>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\Power</strong>，在右侧找到<code>AwayModeEnabled</code>，若其值为1时表示处于离开模式，无法正常睡眠，将其值改为0即可正常睡眠。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;自己家的台式机在接通电源的情况下点击开始菜单-&amp;gt;电源-&amp;gt;睡眠，依然无法睡眠，会始终自动唤醒。这是由于Window
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Windows" scheme="http://yluo.name/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Nvidia显卡驱动</title>
    <link href="http://yluo.name/2020/02/02/ubuntu-install-nvidia-driver/"/>
    <id>http://yluo.name/2020/02/02/ubuntu-install-nvidia-driver/</id>
    <published>2020-02-02T15:54:41.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<p>通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法：</p><h2 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h2><p>若显卡较老的话一般Ubuntu自己的源便会提供驱动，在系统的Additional Driver中选择相应的驱动安装即可，一般写着tested的驱动都是经过测试的，比较稳定。</p><h2 id="自行安装"><a href="#自行安装" class="headerlink" title="自行安装"></a>自行安装</h2><p>若显卡较新的话，Ubuntu自己的源很多时候没有相应的驱动，这时候就需要去Nvidia的官网下载对应的驱动包，比如我现在的电脑显卡是Quadra P1000，我要去Nvidia的官网上下载Linux的驱动安装包，命名通常为NVIDIA-Linux-x86_64-440.44.run，将文件下载到系统中，随后便开始安装</p><h3 id="1-禁用Nouveau"><a href="#1-禁用Nouveau" class="headerlink" title="1. 禁用Nouveau"></a>1. 禁用Nouveau</h3><p>在<code>/etc/modprobe.d/blacklist.conf</code>文件的最后一行加上一句话：<code>blacklist nouveau</code>，将Nouveau加入黑名单，保存后输入如下指令生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo update-initramfs -u</div></pre></td></tr></table></figure><h3 id="2-重启电脑进入命令行界面"><a href="#2-重启电脑进入命令行界面" class="headerlink" title="2. 重启电脑进入命令行界面"></a>2. 重启电脑进入命令行界面</h3><p>重启之后，可以在登录界面或者进入系统之后，按<code>ctrl</code>+<code>alt</code>+<code>F1</code>进入命令行界面</p><h3 id="3-关闭桌面服务"><a href="#3-关闭桌面服务" class="headerlink" title="3. 关闭桌面服务"></a>3. 关闭桌面服务</h3><p>在命令行界面下输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service lightdm stop</div></pre></td></tr></table></figure><h3 id="4-安装Nvidia驱动"><a href="#4-安装Nvidia驱动" class="headerlink" title="4. 安装Nvidia驱动"></a>4. 安装Nvidia驱动</h3><p>进入驱动安装包下载位置，首先赋予其执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x NVIDIA-Linux-x86_64-440.44.run</div></pre></td></tr></table></figure><p>随后运行并按照提示安装即可（通常用默认选项即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./NVIDIA-Linux-x86_64-440.44.run</div></pre></td></tr></table></figure><h3 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5.验证安装"></a>5.验证安装</h3><p>安装完成后输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo nvidia-smi</div></pre></td></tr></table></figure><p>若列出了GPU的信息列表则表示安装成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法：&lt;/p&gt;
&lt;h2 id=&quot;简单安装&quot;&gt;&lt;a href=&quot;#简单安装&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Nvidia" scheme="http://yluo.name/tags/Nvidia/"/>
    
  </entry>
  
  <entry>
    <title>thinkpad-p52-ubuntu-install.md</title>
    <link href="http://yluo.name/2020/02/02/thinkpad-p52-ubuntu-install/"/>
    <id>http://yluo.name/2020/02/02/thinkpad-p52-ubuntu-install/</id>
    <published>2020-02-02T15:45:09.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<p>最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这是由于Thinkpad的核显与独显冲突造成的，需要在主板BIOS里禁用核显。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>开机按<code>Enter</code>进入BIOS配置，随后按<code>F1</code>进入BIOS Setup，在Config菜单下选择Display菜单打开，第二项Graphic Device选项中，选择<code>Discrete Graphics</code>，随后保存退出，便实现了核显的禁用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：Gazebo的更新与配置</title>
    <link href="http://yluo.name/2020/02/02/gazebo-upgrade/"/>
    <id>http://yluo.name/2020/02/02/gazebo-upgrade/</id>
    <published>2020-02-02T14:04:25.000Z</published>
    <updated>2020-03-19T05:28:59.241Z</updated>
    
    <content type="html"><![CDATA[<p>由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。</p><h2 id="查看当前Gazebo版本"><a href="#查看当前Gazebo版本" class="headerlink" title="查看当前Gazebo版本"></a>查看当前Gazebo版本</h2><p>输入以下命令查看当前Gazebo版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gazebo -v</div></pre></td></tr></table></figure><h2 id="升级方法"><a href="#升级方法" class="headerlink" title="升级方法"></a>升级方法</h2><p>执行以下命令升级Gazebo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo sh -c &apos;echo &quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/gazebo-stable.list&apos;</div><div class="line">$ wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install gazebo7</div></pre></td></tr></table></figure><p>以Ubuntu 16.04 + ROS Kinetic为例，默认情况下Gazebo的版本为7.0.0，在更新完之后Gazebo的版本便成为7.16.0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。&lt;/p&gt;
&lt;h2 id=&quot;查看当前Gazebo版本&quot;&gt;&lt;a href=&quot;#查看当前Gazebo版本&quot; class=&quot;head
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu开机自动挂载硬盘</title>
    <link href="http://yluo.name/2020/01/20/ubuntu-mount/"/>
    <id>http://yluo.name/2020/01/20/ubuntu-mount/</id>
    <published>2020-01-20T01:11:36.000Z</published>
    <updated>2020-01-20T01:46:51.954Z</updated>
    
    <content type="html"><![CDATA[<p>平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-查看硬盘信息"><a href="#1-查看硬盘信息" class="headerlink" title="1.查看硬盘信息"></a>1.查看硬盘信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo fdisk -l</div></pre></td></tr></table></figure><p>其显示信息大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Device     Boot Start        End    Sectors  Size Id Type</div><div class="line">/dev/sda1        2048 1000212479 1000210432  477G  7 HPFS/NTFS/exFAT</div></pre></td></tr></table></figure><p>如果有多个设备，则会显示多个类似信息。</p><h3 id="2-创建需要挂载的目录"><a href="#2-创建需要挂载的目录" class="headerlink" title="2. 创建需要挂载的目录"></a>2. 创建需要挂载的目录</h3><p>我希望将硬盘挂载到用户目录下，因此在用户目录下建立<code>SSD/</code>文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir ~/SSD/</div></pre></td></tr></table></figure><h3 id="3-查看磁盘分区的UUID"><a href="#3-查看磁盘分区的UUID" class="headerlink" title="3. 查看磁盘分区的UUID"></a>3. 查看磁盘分区的UUID</h3><p>输入以下指令查看<code>/dev/sda1</code>的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo blkid</div></pre></td></tr></table></figure><p>其显示信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/sda1: LABEL=<span class="string">"SSD"</span> UUID=<span class="string">"C28070388070354F"</span> TYPE=<span class="string">"ntfs"</span> PARTUUID=<span class="string">"40ae352f-01"</span></div></pre></td></tr></table></figure><p>其中<code>UUID=&quot;C28070388070354F&quot;</code>便是挂载硬盘的UUID， 其文件系统格式为ntfs。</p><h3 id="4-配置开机自动挂载"><a href="#4-配置开机自动挂载" class="headerlink" title="4. 配置开机自动挂载"></a>4. 配置开机自动挂载</h3><p>在<code>/etc/fstab</code>文件中加入如下分区信息，让其开机自动挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UUID=C28070388070354F /home/think/SSD ntfs defaults 0 0</div></pre></td></tr></table></figure><p>说明：其格式为 <strong>&lt;分区定位&gt;</strong> + <strong>&lt;挂载点位置&gt;</strong> + <strong>&lt;挂载磁盘类型&gt;</strong> + <strong>&lt;挂载参数&gt;</strong> + <strong><dump备份></dump备份></strong> + <strong>&lt;磁盘检查&gt;</strong>，</p><ul><li><strong>分区定位</strong>，可以为UUID或LABEL；</li><li><strong>挂载点位置</strong>，想要挂载硬盘的位置；</li><li><strong>挂载磁盘类型</strong>，文件系统类型，<code>auto</code>, <code>ext4</code>, <code>ntfs</code>；</li><li><strong>挂载参数</strong>， 通常为<code>defaults</code>，还可设置为<code>auto</code>, <code>ro</code>, <code>rw</code>；</li><li><strong>dump备份</strong>，dump工具决定何时备份，0表示忽略，1表示备份。通常为0；</li><li><strong>磁盘检查</strong>，决定文件系统检查顺序， 0表示检查，1表示最高优先权， 2表示其他所有需要被检查的设备。</li></ul><h3 id="5-挂载硬盘"><a href="#5-挂载硬盘" class="headerlink" title="5. 挂载硬盘"></a>5. 挂载硬盘</h3><p>执行完之前的步骤已经可以在开机自动挂载了，若想手动挂载也很方便，只需要输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mount -a</div></pre></td></tr></table></figure><p>这样便可根据<code>/etc/fstab</code>文件中的顺序挂载所有设备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：echo指令</title>
    <link href="http://yluo.name/2020/01/19/shell-echo/"/>
    <id>http://yluo.name/2020/01/19/shell-echo/</id>
    <published>2020-01-19T15:57:54.000Z</published>
    <updated>2020-01-20T00:57:58.176Z</updated>
    
    <content type="html"><![CDATA[<p><code>echo</code>命令用于在终端打印一行文本，例如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> this is a <span class="built_in">test</span></div><div class="line">this is a <span class="built_in">test</span></div></pre></td></tr></table></figure><p>经常使用的参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-n</td><td style="text-align:left">不输出结尾换行符</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">启用反斜杠转义的解释</td></tr><tr><td style="text-align:left">-E</td><td style="text-align:left">不启用反斜杠转义的解释（默认）</td></tr></tbody></table></div><p>若采用<code>-e</code>， 则下列转义字符将被解释：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">\\</td><td style="text-align:left">不输出结尾换行符</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格 backspace</td></tr><tr><td style="text-align:left">\c</td><td style="text-align:left">不再输出后面内容</td></tr><tr><td style="text-align:left">\e</td><td style="text-align:left">退出 escape</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">退格 backspace</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平tab</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直tab</td></tr><tr><td style="text-align:left">\0NNN</td><td style="text-align:left">八进制NNN</td></tr><tr><td style="text-align:left">\xHH</td><td style="text-align:left">16进制HH</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令用于在终端打印一行文本，例如，&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cl
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：who指令</title>
    <link href="http://yluo.name/2020/01/19/shell-who/"/>
    <id>http://yluo.name/2020/01/19/shell-who/</id>
    <published>2020-01-19T15:37:36.000Z</published>
    <updated>2020-01-20T00:57:58.176Z</updated>
    
    <content type="html"><![CDATA[<p><code>who</code>命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><p>经常使用的参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-H, —heading</td><td style="text-align:left">显示各栏的列标题</td></tr><tr><td style="text-align:left">-b, —boot</td><td style="text-align:left">最后一次系统启动时间</td></tr><tr><td style="text-align:left">-d, —dead</td><td style="text-align:left">死进程</td></tr><tr><td style="text-align:left">-l, —login</td><td style="text-align:left">系统登陆进程</td></tr><tr><td style="text-align:left">-p, —process</td><td style="text-align:left">激活进程</td></tr><tr><td style="text-align:left">-r, —runlevel</td><td style="text-align:left">当前运行级别</td></tr><tr><td style="text-align:left">-t, —time</td><td style="text-align:left">显示最后一次系统时钟改动</td></tr><tr><td style="text-align:left">-T, -w, —mesg</td><td style="text-align:left">加入用户信息状态 + - ?</td></tr><tr><td style="text-align:left">-u, —user</td><td style="text-align:left">列出登陆用户</td></tr><tr><td style="text-align:left">-a 或 —all</td><td style="text-align:left">显示全部信息 -b -d -l -p -r -t -T -u</td></tr></tbody></table></div><h2 id="获取本人信息"><a href="#获取本人信息" class="headerlink" title="获取本人信息"></a>获取本人信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ who am i</div><div class="line">think    pts/18     2020-01-19 23:35 (:0)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;who&lt;/code&gt;命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。&lt;/p&gt;
&lt;p&gt;经常使用的参数如下：&lt;/p&gt;
&lt;div class=&quot;table-contain
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：date指令</title>
    <link href="http://yluo.name/2020/01/19/shell-date/"/>
    <id>http://yluo.name/2020/01/19/shell-date/</id>
    <published>2020-01-19T13:37:54.000Z</published>
    <updated>2020-01-20T01:21:26.529Z</updated>
    
    <content type="html"><![CDATA[<p><code>date</code>命令用于显示当前的日期及时间，直接运行可得到如下格式的显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date</div><div class="line">Sun Jan 19 21:42:52 CST 2020</div></pre></td></tr></table></figure><p>可以在命令后添加参数以设定输出格式(<code>date [OPTION]... [+FORMAT]</code>)，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date +%Y%m%d</div><div class="line">20200119</div></pre></td></tr></table></figure><p>常用的格式参数如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%H</td><td style="text-align:left">小时(00~23)</td></tr><tr><td style="text-align:left">%I</td><td style="text-align:left">小时(01~12)</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">分(00~59)</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">月(01~12)</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">显示AM或PM</td></tr><tr><td style="text-align:left">%r</td><td style="text-align:left">时间(hh:mm:ss)</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">秒(00~59)</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">从1970-01-01 00:00:00 UTC开始到现在的秒数</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">24小时制时间 %H:%M:%S</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">按照当前系统时间格式显示当前时间</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">按照当前系统日期格式显示当前日期</td></tr><tr><td style="text-align:left">%Z</td><td style="text-align:left">时区</td></tr><tr><td style="text-align:left">%a</td><td style="text-align:left">星期简称(Sun)</td></tr><tr><td style="text-align:left">%A</td><td style="text-align:left">星期全称(Sunday)</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">月的简称(Dec)</td></tr><tr><td style="text-align:left">%B</td><td style="text-align:left">月的全称(December)</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">日期和时间(Sun 19 Jan 2020 10:06:36 PM CST)</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">一个月的第几天(01~31)</td></tr><tr><td style="text-align:left">%D</td><td style="text-align:left">日期(mm/dd/yy)</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">一个星期的第几天(0代表Sunday)</td></tr><tr><td style="text-align:left">%W</td><td style="text-align:left">一年的第几个星期(01~53)，星期一为第一天</td></tr><tr><td style="text-align:left">%y</td><td style="text-align:left">年的最后两位(20)</td></tr><tr><td style="text-align:left">%Y</td><td style="text-align:left">年(2020)</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令用于显示当前的日期及时间，直接运行可得到如下格式的显示：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yluo.name/2020/01/18/regexp/"/>
    <id>http://yluo.name/2020/01/18/regexp/</id>
    <published>2020-01-18T06:11:00.000Z</published>
    <updated>2020-01-20T01:10:16.956Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><h2 id="为什么使用正则表达式"><a href="#为什么使用正则表达式" class="headerlink" title="为什么使用正则表达式"></a>为什么使用正则表达式</h2><p>在Linux终端和Vim等文本编辑器中经常会使用到正则表达式来匹配期望的文本，通过使用正则表达式可以：</p><ul><li>测试字符串内的模式， 例如查看字符串内是否出现电话号码或信用卡号码等；</li><li>替换文本， 识别特定文本并进行相关操作；</li><li>基于模式匹配从字符串中提取子字符串，可以查找文档内或输入域内特定的文本。</li></ul><p>例如，可以使用<code>data(\w)?\.dat</code>可以匹配以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data.dat</div><div class="line">data1.dat</div><div class="line">datax.dat</div><div class="line">dataN.dat</div></pre></td></tr></table></figure><p><code>?</code>可以匹配文件名中的0个或1个字符，而<code>*</code>通配符匹配0个或多个字符。<code>data.*\.dat</code>可以匹配以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data.dat</div><div class="line">data2.dat</div><div class="line">data12.dat</div><div class="line">dataxYZ.dat</div></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>例如，</p><ul><li><p><code>runoo+b</code>，可以匹配 runoob、runooob、runoooooob 等，<code>+</code> 号代表前面的字符必须至少出现一次（1次或多次）。</p></li><li><p><code>runoo*b</code>，可以匹配 runob、runoob、runoooooob 等，<code>*</code> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p></li><li><p><code>colou?r</code> 可以匹配 color 或者 colour，<code>?</code> 问号代表前面的字符最多只可以出现一次（0次、或1次）。</p></li></ul><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有<em>大写</em>和<em>小写</em>字母、所有<em>数字</em>、所有<em>标点符号</em>和一些其他符号。</p><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>\cx</code></td><td style="text-align:left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符</td></tr><tr><td style="text-align:left"><code>\f</code></td><td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \c</td></tr><tr><td style="text-align:left"><code>\n</code></td><td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ</td></tr><tr><td style="text-align:left"><code>\r</code></td><td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM</td></tr><tr><td style="text-align:left"><code>\s</code></td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符</td></tr><tr><td style="text-align:left"><code>\S</code></td><td style="text-align:left">匹配任何非空白字符。等价于 <sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup></td></tr><tr><td style="text-align:left"><code>\t</code></td><td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI</td></tr><tr><td style="text-align:left"><code>\v</code></td><td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK</td></tr></tbody></table></div><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <code>runoo*b</code> 中的 <code>*</code>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 <code>\</code>: <code>runo\*ob</code> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<code>\</code>放在它们前面。下表列出了正则表达式中的特殊字符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $</td></tr><tr><td style="text-align:left"><code>()</code></td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code></td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式0次或多次。要匹配 <em> 字符，请使用 `\</em>`</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式1次或多次。要匹配 + 字符，请使用 <code>\+</code></td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配 . ，请使用 <code>\.</code></td></tr><tr><td style="text-align:left"><code>[</code></td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code></td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式0次或1次，或指明一个<strong>非贪婪</strong>限定符。要匹配 ? 字符，请使用 <code>\?</code></td></tr><tr><td style="text-align:left"><code>\</code></td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 n。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 \、，而 <code>\(</code> 则匹配 (</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code></td></tr><tr><td style="text-align:left"><code>{</code></td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用<code>\{</code></td></tr><tr><td style="text-align:left">&#124;</td><td style="text-align:left">指明两项之间的一个选择。要匹配 &#124;， 请使用 \&#124;</td></tr></tbody></table></div><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <code>*</code>或 <code>+</code> 或 <code>?</code> 或 <code>{n}</code> 或 <code>{n,}</code> 或 <code>{n,m}</code> 共6种。正则表达式的限定符有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式0次或多次。例如，<code>zo*</code> 能匹配 z 以及 zoo。<code>*</code> 等价于<code>{0,}</code></td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式1次或多次。例如，<code>zo+</code> 能匹配 zo 以及 zoo，但不能匹配 z。<code>+</code> 等价于 <code>{1,}</code></td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式0次或1次。例如，<code>do(es)?</code> 可以匹配 do 、 does 中的 does 、 doxy 中的 do 。<code>?</code> 等价于 <code>{0,1}</code></td></tr><tr><td style="text-align:left"><code>{n}</code></td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，<code>o{2}</code> 不能匹配 Bob 中的 o，但是能匹配 food 中的2个 o</td></tr><tr><td style="text-align:left"><code>{n,}</code></td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，<code>o{2,}</code> 不能匹配 Bob 中的 o，但能匹配 foooood 中的所有 o。<code>o{1,}</code> 等价于 <code>o+</code>。<code>o{0,}</code> 则等价于 <code>o*</code></td></tr><tr><td style="text-align:left"><code>{n,m}</code></td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<code>o{1,3}</code> 将匹配 fooooood 中的前三个 o。<code>o{0,1}</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr></tbody></table></div><p>以下正则表达式匹配一个正整数， <code>[1-9]</code>设置第一个数字不是0， <code>[0-9]*</code>表示任意多个数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[1-9][0-9]*/</div></pre></td></tr></table></figure><p>请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定1位但至多2位数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[0-9]&#123;1,2&#125;/</div></pre></td></tr></table></figure><p>上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。改进下，匹配 1~99 的正整数表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[1-9][0-9]?/</div></pre></td></tr></table></figure><p><code>*</code> 、<code>+</code> 限定符都是<strong>贪婪</strong>的，因为它们会<strong>尽可能多</strong>的匹配文字，只有在它们的后面加上一个 <code>?</code> 就可以实现<strong>非贪婪</strong>或<strong>最小匹配</strong>。</p><p>例如，您可能搜索 HTML 文档，以查找在 h1 标签内的内容。HTML 代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>RUNOOB-菜鸟教程<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;.*&gt;/</div></pre></td></tr></table></figure><p><strong>非贪婪</strong>：如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 \<h1\>。</h1\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;.*?&gt;/</div></pre></td></tr></table></figure><p>也可以使用以下正则表达式来匹配 h1 标签，表达式则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;\w+?&gt;/</div></pre></td></tr></table></figure><p>通过在 <code>*</code> 、<code>+</code> 或 <code>?</code> 限定符之后放置 <code>?</code>，该表达式从<strong>贪婪</strong>表达式转换为<strong>非贪婪</strong>表达式或者<strong>最小匹配</strong>。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。&lt;/p&gt;
&lt;h2 id=&quot;为什么使用正则表达式&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
      <category term="正则表达式" scheme="http://yluo.name/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Qt Creator无法输入中文问题</title>
    <link href="http://yluo.name/2020/01/17/qt_im/"/>
    <id>http://yluo.name/2020/01/17/qt_im/</id>
    <published>2020-01-17T06:20:00.000Z</published>
    <updated>2020-01-20T00:57:58.172Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="1-确认安装fcitx-frontend-qt5"><a href="#1-确认安装fcitx-frontend-qt5" class="headerlink" title="1. 确认安装fcitx-frontend-qt5"></a>1. 确认安装fcitx-frontend-qt5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install fcitx-frontend-qt5</div></pre></td></tr></table></figure><h3 id="2-确认该路径下存在文件"><a href="#2-确认该路径下存在文件" class="headerlink" title="2. 确认该路径下存在文件"></a>2. 确认该路径下存在文件</h3><p>由于Sogou Linux输入法采用的是fcitx框架，因此，需要确认<code>libfcitxplatforminputcontextplugin.so</code>是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts</div><div class="line">ls | grep libfcitx</div></pre></td></tr></table></figure><h3 id="3-将此lib文件复制到Qt与Qt-Creator的对应路径下"><a href="#3-将此lib文件复制到Qt与Qt-Creator的对应路径下" class="headerlink" title="3. 将此lib文件复制到Qt与Qt Creator的对应路径下"></a>3. 将此lib文件复制到Qt与Qt Creator的对应路径下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/</div><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/5.12.2/gcc_64/plugins/platforminputcontexts/</div></pre></td></tr></table></figure><p>随后重启Qt Creator，便可以输入中文了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。&lt;/p&gt;
&lt;h2 id=&quot;解决步
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Qt" scheme="http://yluo.name/tags/Qt/"/>
    
      <category term="输入法" scheme="http://yluo.name/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
</feed>
