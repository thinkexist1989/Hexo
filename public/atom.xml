<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DécouVerte</title>
  
  <subtitle>生命不息 折腾不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yluo.name/"/>
  <updated>2020-02-02T16:20:37.579Z</updated>
  <id>http://yluo.name/</id>
  
  <author>
    <name>Yang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu安装Nvidia显卡驱动</title>
    <link href="http://yluo.name/2020/02/02/ubuntu-install-nvidia-driver/"/>
    <id>http://yluo.name/2020/02/02/ubuntu-install-nvidia-driver/</id>
    <published>2020-02-02T15:54:41.000Z</published>
    <updated>2020-02-02T16:20:37.579Z</updated>
    
    <content type="html"><![CDATA[<p>通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法：</p><h2 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h2><p>若显卡较老的话一般Ubuntu自己的源便会提供驱动，在系统的Additional Driver中选择相应的驱动安装即可，一般写着tested的驱动都是经过测试的，比较稳定。</p><h2 id="自行安装"><a href="#自行安装" class="headerlink" title="自行安装"></a>自行安装</h2><p>若显卡较新的话，Ubuntu自己的源很多时候没有相应的驱动，这时候就需要去Nvidia的官网下载对应的驱动包，比如我现在的电脑显卡是Quadra P1000，我要去Nvidia的官网上下载Linux的驱动安装包，命名通常为NVIDIA-Linux-x86_64-440.44.run，将文件下载到系统中，随后便开始安装</p><h3 id="1-禁用Nouveau"><a href="#1-禁用Nouveau" class="headerlink" title="1. 禁用Nouveau"></a>1. 禁用Nouveau</h3><p>在<code>/etc/modprobe.d/blacklist.conf</code>文件的最后一行加上一句话：<code>blacklist nouveau</code>，将Nouveau加入黑名单，保存后输入如下指令生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo update-initramfs -u</div></pre></td></tr></table></figure><h3 id="2-重启电脑进入命令行界面"><a href="#2-重启电脑进入命令行界面" class="headerlink" title="2. 重启电脑进入命令行界面"></a>2. 重启电脑进入命令行界面</h3><p>重启之后，可以在登录界面或者进入系统之后，按<code>ctrl</code>+<code>alt</code>+<code>F1</code>进入命令行界面</p><h3 id="3-关闭桌面服务"><a href="#3-关闭桌面服务" class="headerlink" title="3. 关闭桌面服务"></a>3. 关闭桌面服务</h3><p>在命令行界面下输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service lightdm stop</div></pre></td></tr></table></figure><h3 id="4-安装Nvidia驱动"><a href="#4-安装Nvidia驱动" class="headerlink" title="4. 安装Nvidia驱动"></a>4. 安装Nvidia驱动</h3><p>进入驱动安装包下载位置，首先赋予其执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x NVIDIA-Linux-x86_64-440.44.run</div></pre></td></tr></table></figure><p>随后运行并按照提示安装即可（通常用默认选项即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./NVIDIA-Linux-x86_64-440.44.run</div></pre></td></tr></table></figure><h3 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5.验证安装"></a>5.验证安装</h3><p>安装完成后输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo nvidia-smi</div></pre></td></tr></table></figure><p>若列出了GPU的信息列表则表示安装成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法：&lt;/p&gt;
&lt;h2 id=&quot;简单安装&quot;&gt;&lt;a href=&quot;#简单安装&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Nvidia" scheme="http://yluo.name/tags/Nvidia/"/>
    
  </entry>
  
  <entry>
    <title>thinkpad-p52-ubuntu-install.md</title>
    <link href="http://yluo.name/2020/02/02/thinkpad-p52-ubuntu-install/"/>
    <id>http://yluo.name/2020/02/02/thinkpad-p52-ubuntu-install/</id>
    <published>2020-02-02T15:45:09.000Z</published>
    <updated>2020-02-02T15:54:09.506Z</updated>
    
    <content type="html"><![CDATA[<p>最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这是由于Thinkpad的核显与独显冲突造成的，需要在主板BIOS里禁用核显。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>开机按<code>Enter</code>进入BIOS配置，随后按<code>F1</code>进入BIOS Setup，在Config菜单下选择Display菜单打开，第二项Graphic Device选项中，选择<code>Discrete Graphics</code>，随后保存退出，便实现了核显的禁用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：Gazebo的更新与配置</title>
    <link href="http://yluo.name/2020/02/02/gazebo-upgrade/"/>
    <id>http://yluo.name/2020/02/02/gazebo-upgrade/</id>
    <published>2020-02-02T14:04:25.000Z</published>
    <updated>2020-02-02T15:43:04.464Z</updated>
    
    <content type="html"><![CDATA[<p>由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。</p><h2 id="查看当前Gazebo版本"><a href="#查看当前Gazebo版本" class="headerlink" title="查看当前Gazebo版本"></a>查看当前Gazebo版本</h2><p>输入以下命令查看当前Gazebo版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gazebo -v</div></pre></td></tr></table></figure><h2 id="升级方法"><a href="#升级方法" class="headerlink" title="升级方法"></a>升级方法</h2><p>执行以下命令升级Gazebo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo sh -c &apos;echo &quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/gazebo-stable.list&apos;</div><div class="line">$ wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install gazebo7</div></pre></td></tr></table></figure><p>以Ubuntu 16.04 + ROS Kinetic为例，默认情况下Gazebo的版本为7.0.0，在更新完之后Gazebo的版本便成为7.16.0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。&lt;/p&gt;
&lt;h2 id=&quot;查看当前Gazebo版本&quot;&gt;&lt;a href=&quot;#查看当前Gazebo版本&quot; class=&quot;head
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu开机自动挂载硬盘</title>
    <link href="http://yluo.name/2020/01/20/ubuntu-mount/"/>
    <id>http://yluo.name/2020/01/20/ubuntu-mount/</id>
    <published>2020-01-20T01:11:36.000Z</published>
    <updated>2020-02-01T14:31:16.452Z</updated>
    
    <content type="html"><![CDATA[<p>平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-查看硬盘信息"><a href="#1-查看硬盘信息" class="headerlink" title="1.查看硬盘信息"></a>1.查看硬盘信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo fdisk -l</div></pre></td></tr></table></figure><p>其显示信息大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Device     Boot Start        End    Sectors  Size Id Type</div><div class="line">/dev/sda1        2048 1000212479 1000210432  477G  7 HPFS/NTFS/exFAT</div></pre></td></tr></table></figure><p>如果有多个设备，则会显示多个类似信息。</p><h3 id="2-创建需要挂载的目录"><a href="#2-创建需要挂载的目录" class="headerlink" title="2. 创建需要挂载的目录"></a>2. 创建需要挂载的目录</h3><p>我希望将硬盘挂载到用户目录下，因此在用户目录下建立<code>SSD/</code>文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir ~/SSD/</div></pre></td></tr></table></figure><h3 id="3-查看磁盘分区的UUID"><a href="#3-查看磁盘分区的UUID" class="headerlink" title="3. 查看磁盘分区的UUID"></a>3. 查看磁盘分区的UUID</h3><p>输入以下指令查看<code>/dev/sda1</code>的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo blkid</div></pre></td></tr></table></figure><p>其显示信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/sda1: LABEL=<span class="string">"SSD"</span> UUID=<span class="string">"C28070388070354F"</span> TYPE=<span class="string">"ntfs"</span> PARTUUID=<span class="string">"40ae352f-01"</span></div></pre></td></tr></table></figure><p>其中<code>UUID=&quot;C28070388070354F&quot;</code>便是挂载硬盘的UUID， 其文件系统格式为ntfs。</p><h3 id="4-配置开机自动挂载"><a href="#4-配置开机自动挂载" class="headerlink" title="4. 配置开机自动挂载"></a>4. 配置开机自动挂载</h3><p>在<code>/etc/fstab</code>文件中加入如下分区信息，让其开机自动挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UUID=C28070388070354F /home/think/SSD ntfs defaults 0 0</div></pre></td></tr></table></figure><p>说明：其格式为 <strong>&lt;分区定位&gt;</strong> + <strong>&lt;挂载点位置&gt;</strong> + <strong>&lt;挂载磁盘类型&gt;</strong> + <strong>&lt;挂载参数&gt;</strong> + <strong><dump备份></dump备份></strong> + <strong>&lt;磁盘检查&gt;</strong>，</p><ul><li><strong>分区定位</strong>，可以为UUID或LABEL；</li><li><strong>挂载点位置</strong>，想要挂载硬盘的位置；</li><li><strong>挂载磁盘类型</strong>，文件系统类型，<code>auto</code>, <code>ext4</code>, <code>ntfs</code>；</li><li><strong>挂载参数</strong>， 通常为<code>defaults</code>，还可设置为<code>auto</code>, <code>ro</code>, <code>rw</code>；</li><li><strong>dump备份</strong>，dump工具决定何时备份，0表示忽略，1表示备份。通常为0；</li><li><strong>磁盘检查</strong>，决定文件系统检查顺序， 0表示检查，1表示最高优先权， 2表示其他所有需要被检查的设备。</li></ul><h3 id="5-挂载硬盘"><a href="#5-挂载硬盘" class="headerlink" title="5. 挂载硬盘"></a>5. 挂载硬盘</h3><p>执行完之前的步骤已经可以在开机自动挂载了，若想手动挂载也很方便，只需要输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mount -a</div></pre></td></tr></table></figure><p>这样便可根据<code>/etc/fstab</code>文件中的顺序挂载所有设备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：echo指令</title>
    <link href="http://yluo.name/2020/01/19/shell-echo/"/>
    <id>http://yluo.name/2020/01/19/shell-echo/</id>
    <published>2020-01-19T15:57:54.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><code>echo</code>命令用于在终端打印一行文本，例如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> this is a <span class="built_in">test</span></div><div class="line">this is a <span class="built_in">test</span></div></pre></td></tr></table></figure><p>经常使用的参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-n</td><td style="text-align:left">不输出结尾换行符</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">启用反斜杠转义的解释</td></tr><tr><td style="text-align:left">-E</td><td style="text-align:left">不启用反斜杠转义的解释（默认）</td></tr></tbody></table></div><p>若采用<code>-e</code>， 则下列转义字符将被解释：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">\\</td><td style="text-align:left">不输出结尾换行符</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格 backspace</td></tr><tr><td style="text-align:left">\c</td><td style="text-align:left">不再输出后面内容</td></tr><tr><td style="text-align:left">\e</td><td style="text-align:left">退出 escape</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">退格 backspace</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平tab</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直tab</td></tr><tr><td style="text-align:left">\0NNN</td><td style="text-align:left">八进制NNN</td></tr><tr><td style="text-align:left">\xHH</td><td style="text-align:left">16进制HH</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;echo&lt;/code&gt;命令用于在终端打印一行文本，例如，&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cl
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：who指令</title>
    <link href="http://yluo.name/2020/01/19/shell-who/"/>
    <id>http://yluo.name/2020/01/19/shell-who/</id>
    <published>2020-01-19T15:37:36.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><code>who</code>命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><p>经常使用的参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-H, —heading</td><td style="text-align:left">显示各栏的列标题</td></tr><tr><td style="text-align:left">-b, —boot</td><td style="text-align:left">最后一次系统启动时间</td></tr><tr><td style="text-align:left">-d, —dead</td><td style="text-align:left">死进程</td></tr><tr><td style="text-align:left">-l, —login</td><td style="text-align:left">系统登陆进程</td></tr><tr><td style="text-align:left">-p, —process</td><td style="text-align:left">激活进程</td></tr><tr><td style="text-align:left">-r, —runlevel</td><td style="text-align:left">当前运行级别</td></tr><tr><td style="text-align:left">-t, —time</td><td style="text-align:left">显示最后一次系统时钟改动</td></tr><tr><td style="text-align:left">-T, -w, —mesg</td><td style="text-align:left">加入用户信息状态 + - ?</td></tr><tr><td style="text-align:left">-u, —user</td><td style="text-align:left">列出登陆用户</td></tr><tr><td style="text-align:left">-a 或 —all</td><td style="text-align:left">显示全部信息 -b -d -l -p -r -t -T -u</td></tr></tbody></table></div><h2 id="获取本人信息"><a href="#获取本人信息" class="headerlink" title="获取本人信息"></a>获取本人信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ who am i</div><div class="line">think    pts/18     2020-01-19 23:35 (:0)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;who&lt;/code&gt;命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。&lt;/p&gt;
&lt;p&gt;经常使用的参数如下：&lt;/p&gt;
&lt;div class=&quot;table-contain
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程：date指令</title>
    <link href="http://yluo.name/2020/01/19/shell-date/"/>
    <id>http://yluo.name/2020/01/19/shell-date/</id>
    <published>2020-01-19T13:37:54.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><code>date</code>命令用于显示当前的日期及时间，直接运行可得到如下格式的显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date</div><div class="line">Sun Jan 19 21:42:52 CST 2020</div></pre></td></tr></table></figure><p>可以在命令后添加参数以设定输出格式(<code>date [OPTION]... [+FORMAT]</code>)，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ date +%Y%m%d</div><div class="line">20200119</div></pre></td></tr></table></figure><p>常用的格式参数如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">%H</td><td style="text-align:left">小时(00~23)</td></tr><tr><td style="text-align:left">%I</td><td style="text-align:left">小时(01~12)</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">分(00~59)</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">月(01~12)</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">显示AM或PM</td></tr><tr><td style="text-align:left">%r</td><td style="text-align:left">时间(hh:mm:ss)</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">秒(00~59)</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">从1970-01-01 00:00:00 UTC开始到现在的秒数</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">24小时制时间 %H:%M:%S</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">按照当前系统时间格式显示当前时间</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">按照当前系统日期格式显示当前日期</td></tr><tr><td style="text-align:left">%Z</td><td style="text-align:left">时区</td></tr><tr><td style="text-align:left">%a</td><td style="text-align:left">星期简称(Sun)</td></tr><tr><td style="text-align:left">%A</td><td style="text-align:left">星期全称(Sunday)</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">月的简称(Dec)</td></tr><tr><td style="text-align:left">%B</td><td style="text-align:left">月的全称(December)</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:left">日期和时间(Sun 19 Jan 2020 10:06:36 PM CST)</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">一个月的第几天(01~31)</td></tr><tr><td style="text-align:left">%D</td><td style="text-align:left">日期(mm/dd/yy)</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">一个星期的第几天(0代表Sunday)</td></tr><tr><td style="text-align:left">%W</td><td style="text-align:left">一年的第几个星期(01~53)，星期一为第一天</td></tr><tr><td style="text-align:left">%y</td><td style="text-align:left">年的最后两位(20)</td></tr><tr><td style="text-align:left">%Y</td><td style="text-align:left">年(2020)</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令用于显示当前的日期及时间，直接运行可得到如下格式的显示：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yluo.name/2020/01/18/regexp/"/>
    <id>http://yluo.name/2020/01/18/regexp/</id>
    <published>2020-01-18T06:11:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><h2 id="为什么使用正则表达式"><a href="#为什么使用正则表达式" class="headerlink" title="为什么使用正则表达式"></a>为什么使用正则表达式</h2><p>在Linux终端和Vim等文本编辑器中经常会使用到正则表达式来匹配期望的文本，通过使用正则表达式可以：</p><ul><li>测试字符串内的模式， 例如查看字符串内是否出现电话号码或信用卡号码等；</li><li>替换文本， 识别特定文本并进行相关操作；</li><li>基于模式匹配从字符串中提取子字符串，可以查找文档内或输入域内特定的文本。</li></ul><p>例如，可以使用<code>data(\w)?\.dat</code>可以匹配以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data.dat</div><div class="line">data1.dat</div><div class="line">datax.dat</div><div class="line">dataN.dat</div></pre></td></tr></table></figure><p><code>?</code>可以匹配文件名中的0个或1个字符，而<code>*</code>通配符匹配0个或多个字符。<code>data.*\.dat</code>可以匹配以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data.dat</div><div class="line">data2.dat</div><div class="line">data12.dat</div><div class="line">dataxYZ.dat</div></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>例如，</p><ul><li><p><code>runoo+b</code>，可以匹配 runoob、runooob、runoooooob 等，<code>+</code> 号代表前面的字符必须至少出现一次（1次或多次）。</p></li><li><p><code>runoo*b</code>，可以匹配 runob、runoob、runoooooob 等，<code>*</code> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p></li><li><p><code>colou?r</code> 可以匹配 color 或者 colour，<code>?</code> 问号代表前面的字符最多只可以出现一次（0次、或1次）。</p></li></ul><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有<em>大写</em>和<em>小写</em>字母、所有<em>数字</em>、所有<em>标点符号</em>和一些其他符号。</p><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>\cx</code></td><td style="text-align:left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符</td></tr><tr><td style="text-align:left"><code>\f</code></td><td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \c</td></tr><tr><td style="text-align:left"><code>\n</code></td><td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ</td></tr><tr><td style="text-align:left"><code>\r</code></td><td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM</td></tr><tr><td style="text-align:left"><code>\s</code></td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符</td></tr><tr><td style="text-align:left"><code>\S</code></td><td style="text-align:left">匹配任何非空白字符。等价于 <sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup></td></tr><tr><td style="text-align:left"><code>\t</code></td><td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI</td></tr><tr><td style="text-align:left"><code>\v</code></td><td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK</td></tr></tbody></table></div><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <code>runoo*b</code> 中的 <code>*</code>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 <code>\</code>: <code>runo\*ob</code> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<code>\</code>放在它们前面。下表列出了正则表达式中的特殊字符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$</code></td><td style="text-align:left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $</td></tr><tr><td style="text-align:left"><code>()</code></td><td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code></td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式0次或多次。要匹配 <em> 字符，请使用 `\</em>`</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式1次或多次。要匹配 + 字符，请使用 <code>\+</code></td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配 . ，请使用 <code>\.</code></td></tr><tr><td style="text-align:left"><code>[</code></td><td style="text-align:left">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\[</code></td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式0次或1次，或指明一个<strong>非贪婪</strong>限定符。要匹配 ? 字符，请使用 <code>\?</code></td></tr><tr><td style="text-align:left"><code>\</code></td><td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 n。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 \、，而 <code>\(</code> 则匹配 (</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 <code>\^</code></td></tr><tr><td style="text-align:left"><code>{</code></td><td style="text-align:left">标记限定符表达式的开始。要匹配 {，请使用<code>\{</code></td></tr><tr><td style="text-align:left">&#124;</td><td style="text-align:left">指明两项之间的一个选择。要匹配 &#124;， 请使用 \&#124;</td></tr></tbody></table></div><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <code>*</code>或 <code>+</code> 或 <code>?</code> 或 <code>{n}</code> 或 <code>{n,}</code> 或 <code>{n,m}</code> 共6种。正则表达式的限定符有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配前面的子表达式0次或多次。例如，<code>zo*</code> 能匹配 z 以及 zoo。<code>*</code> 等价于<code>{0,}</code></td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">匹配前面的子表达式1次或多次。例如，<code>zo+</code> 能匹配 zo 以及 zoo，但不能匹配 z。<code>+</code> 等价于 <code>{1,}</code></td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配前面的子表达式0次或1次。例如，<code>do(es)?</code> 可以匹配 do 、 does 中的 does 、 doxy 中的 do 。<code>?</code> 等价于 <code>{0,1}</code></td></tr><tr><td style="text-align:left"><code>{n}</code></td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，<code>o{2}</code> 不能匹配 Bob 中的 o，但是能匹配 food 中的2个 o</td></tr><tr><td style="text-align:left"><code>{n,}</code></td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，<code>o{2,}</code> 不能匹配 Bob 中的 o，但能匹配 foooood 中的所有 o。<code>o{1,}</code> 等价于 <code>o+</code>。<code>o{0,}</code> 则等价于 <code>o*</code></td></tr><tr><td style="text-align:left"><code>{n,m}</code></td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<code>o{1,3}</code> 将匹配 fooooood 中的前三个 o。<code>o{0,1}</code> 等价于 <code>o?</code>。请注意在逗号和两个数之间不能有空格</td></tr></tbody></table></div><p>以下正则表达式匹配一个正整数， <code>[1-9]</code>设置第一个数字不是0， <code>[0-9]*</code>表示任意多个数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[1-9][0-9]*/</div></pre></td></tr></table></figure><p>请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定1位但至多2位数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[0-9]&#123;1,2&#125;/</div></pre></td></tr></table></figure><p>上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。改进下，匹配 1~99 的正整数表达式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/[1-9][0-9]?/</div></pre></td></tr></table></figure><p><code>*</code> 、<code>+</code> 限定符都是<strong>贪婪</strong>的，因为它们会<strong>尽可能多</strong>的匹配文字，只有在它们的后面加上一个 <code>?</code> 就可以实现<strong>非贪婪</strong>或<strong>最小匹配</strong>。</p><p>例如，您可能搜索 HTML 文档，以查找在 h1 标签内的内容。HTML 代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>RUNOOB-菜鸟教程<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;.*&gt;/</div></pre></td></tr></table></figure><p><strong>非贪婪</strong>：如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 \<h1\>。</h1\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;.*?&gt;/</div></pre></td></tr></table></figure><p>也可以使用以下正则表达式来匹配 h1 标签，表达式则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/&lt;\w+?&gt;/</div></pre></td></tr></table></figure><p>通过在 <code>*</code> 、<code>+</code> 或 <code>?</code> 限定符之后放置 <code>?</code>，该表达式从<strong>贪婪</strong>表达式转换为<strong>非贪婪</strong>表达式或者<strong>最小匹配</strong>。</p><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。&lt;/p&gt;
&lt;h2 id=&quot;为什么使用正则表达式&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yluo.name/tags/Shell/"/>
    
      <category term="正则表达式" scheme="http://yluo.name/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Qt Creator无法输入中文问题</title>
    <link href="http://yluo.name/2020/01/17/qt_im/"/>
    <id>http://yluo.name/2020/01/17/qt_im/</id>
    <published>2020-01-17T06:20:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="1-确认安装fcitx-frontend-qt5"><a href="#1-确认安装fcitx-frontend-qt5" class="headerlink" title="1. 确认安装fcitx-frontend-qt5"></a>1. 确认安装fcitx-frontend-qt5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install fcitx-frontend-qt5</div></pre></td></tr></table></figure><h3 id="2-确认该路径下存在文件"><a href="#2-确认该路径下存在文件" class="headerlink" title="2. 确认该路径下存在文件"></a>2. 确认该路径下存在文件</h3><p>由于Sogou Linux输入法采用的是fcitx框架，因此，需要确认<code>libfcitxplatforminputcontextplugin.so</code>是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts</div><div class="line">ls | grep libfcitx</div></pre></td></tr></table></figure><h3 id="3-将此lib文件复制到Qt与Qt-Creator的对应路径下"><a href="#3-将此lib文件复制到Qt与Qt-Creator的对应路径下" class="headerlink" title="3. 将此lib文件复制到Qt与Qt Creator的对应路径下"></a>3. 将此lib文件复制到Qt与Qt Creator的对应路径下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/</div><div class="line">sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/5.12.2/gcc_64/plugins/platforminputcontexts/</div></pre></td></tr></table></figure><p>随后重启Qt Creator，便可以输入中文了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。&lt;/p&gt;
&lt;h2 id=&quot;解决步
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Qt" scheme="http://yluo.name/tags/Qt/"/>
    
      <category term="输入法" scheme="http://yluo.name/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu右上角状态指示栏顺序配置</title>
    <link href="http://yluo.name/2020/01/16/ubuntu-indicator/"/>
    <id>http://yluo.name/2020/01/16/ubuntu-indicator/</id>
    <published>2020-01-16T02:29:00.000Z</published>
    <updated>2020-02-01T14:31:16.452Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>在Ubuntu中存在一个表单，这个表单里固定了一部分indicator的顺序，这个文件保存在如下位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/share/indicator-application/ordering-override.keyfile</div></pre></td></tr></table></figure><p>若是针对个人用户的配置，可以将ordering-override.keyfile复制到用户目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /usr/share/indicator-application/ordering-override.keyfile ~/.<span class="built_in">local</span>/share/indicators/application/</div></pre></td></tr></table></figure><p>随后利用<code>vim ~/.local/share/indicators/application/ordering-override.keyfile</code>打开<code>.keyfile</code>文件，可以看到，文件里的内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[Ordering Index Overrides]</div><div class="line">nm-applet=1</div><div class="line">My_Weather_Indicator=2</div><div class="line">lang_indicator=3</div><div class="line">bluetooth_manager=4</div><div class="line">transmission=6</div></pre></td></tr></table></figure><p>数字越大则越靠近左边，而数字越小则越靠近右边。若想要indicator放置在最左边，则可以使数值为-1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">indicator_sysmonitor=-1</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。&lt;/p&gt;
&lt;h2 id=&quot;设置方法&quot;&gt;&lt;a href=&quot;#设置方法&quot; class=&quot;headerlink&quot; title=&quot;设置方法&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 未知索引格式错误</title>
    <link href="http://yluo.name/2019/09/29/Git_fatal/"/>
    <id>http://yluo.name/2019/09/29/Git_fatal/</id>
    <published>2019-09-29T03:00:00.000Z</published>
    <updated>2020-01-20T12:52:36.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误说明"><a href="#错误说明" class="headerlink" title="错误说明"></a>错误说明</h1><p>运行<code>git status</code>时，提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal: Unknown index entry format xxxxx</div></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>进入仓库文件夹，输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm -f .git/index</div><div class="line">git reset</div></pre></td></tr></table></figure><p>大功告成，喜大普奔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误说明&quot;&gt;&lt;a href=&quot;#错误说明&quot; class=&quot;headerlink&quot; title=&quot;错误说明&quot;&gt;&lt;/a&gt;错误说明&lt;/h1&gt;&lt;p&gt;运行&lt;code&gt;git status&lt;/code&gt;时，提示&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Git" scheme="http://yluo.name/tags/Git/"/>
    
      <category term="小技巧" scheme="http://yluo.name/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：自定义消息类型</title>
    <link href="http://yluo.name/2019/08/06/ros_message/"/>
    <id>http://yluo.name/2019/08/06/ros_message/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2020-02-01T14:31:16.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS消息文件"><a href="#ROS消息文件" class="headerlink" title="ROS消息文件"></a>ROS消息文件</h2><p>ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下，可以被用来生成不同语言的源代码。</p><h2 id="消息数据类型"><a href="#消息数据类型" class="headerlink" title="消息数据类型"></a>消息数据类型</h2><p>ROS中的消息可使用的基本数据类型如下：</p><ul><li>int8, int16, int32, int64 (plus uint*)</li><li>float32, float64</li><li>string</li><li>time, duration</li><li>可变长度的数组，例如int8[]，以及固定长度的数组，例如float32[10]</li></ul><p>ROS消息中还有一个特殊的数据类型：Header， 其含有时间戳和坐标系信息。通常在很多msg文件的第一行有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Header header</div></pre></td></tr></table></figure><p>个人理解（不一定准确），Header类型通常包含在频繁发送的消息中，这样订阅节点可以根据Header中的时间戳信息等做信息同步处理。</p><p>同时，msg文件中还可以包括其他消息文件类型，例如在下面xxx.msg文件中，使用了Header, string以及另外两个消息类型。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Header header</div><div class="line"><span class="built_in">string</span> child_frame_id</div><div class="line">geometry_msgs/PoseWithCovariance pose</div><div class="line">geometry_msgs/TwistWithCovariance twist</div></pre></td></tr></table></figure><h2 id="使用消息"><a href="#使用消息" class="headerlink" title="使用消息"></a>使用消息</h2><p>为了使用消息，需要在package.xml中添加编译依赖和执行依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</div></pre></td></tr></table></figure><p>并且在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</div><div class="line">    ...</div><div class="line">    message_generation</div><div class="line">)</div></pre></td></tr></table></figure><p>同时，利用catkin_package函数设置运行依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catkin_package(</div><div class="line">    ...</div><div class="line">    CATKIN_DEPENDS message_runtime ...</div><div class="line">)</div></pre></td></tr></table></figure><p>并添加需要参与编译的msg文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">add_message_files(</div><div class="line">    FILES</div><div class="line">    xxx.msg</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure><p>确保CMake知道在消息文件更改后重新编译msg文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">generate_messages(</div><div class="line">    DEPENDENCIES</div><div class="line">    std_msgs</div><div class="line">)</div></pre></td></tr></table></figure><p>随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rosmsg命令查看自定义的消息类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosmsg show xxx</div></pre></td></tr></table></figure><h2 id="消息相关命令"><a href="#消息相关命令" class="headerlink" title="消息相关命令"></a>消息相关命令</h2><ul><li>rosmsg show xxx: 查看消息xxx类型，可以不指定功能包名。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ROS消息文件&quot;&gt;&lt;a href=&quot;#ROS消息文件&quot; class=&quot;headerlink&quot; title=&quot;ROS消息文件&quot;&gt;&lt;/a&gt;ROS消息文件&lt;/h2&gt;&lt;p&gt;ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：ROS命名空间及重映射</title>
    <link href="http://yluo.name/2019/08/06/ros_namespace/"/>
    <id>http://yluo.name/2019/08/06/ros_namespace/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2020-02-01T14:31:16.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS的命名"><a href="#ROS的命名" class="headerlink" title="ROS的命名"></a>ROS的命名</h2><p>命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为camera，并且相机可以输出一个话题image，同时读取一个frame_rate的参数来控制发送图像的频率。一个有效的命名具备以下特点：</p><ul><li>首字符为字母（[a-z|A-Z]）、波浪线（～）或左斜杠（/）。（不可以为下划线_）</li><li>后续字符可以是字母或数字（[0-9|a-z|A-Z]）、下划线（_）或者左斜杠（/）</li></ul><p>当一个机器人上存在两个相机时，由于相机的功能几乎完全一样，我们没有必要为两个相机分别编写一个程序，同时，也不想让两个相机的话题都发布在image话题上，这样会导致两个相机的画面交替出现。更一般地，命名的冲突在机器人系统中非常容易发生，这是因为机器人上常常包含相同的硬件或软件来简化工作量，例如相同的左右机械臂、相同的相机以及相同的多个轮子。为了避免命名上的冲突，ROS中采用两种机制来处理这种情况：命名空间和重映射。</p><h2 id="命名空间-Namespace"><a href="#命名空间-Namespace" class="headerlink" title="命名空间 Namespace"></a>命名空间 Namespace</h2><p>命名空间是计算机科学中的一个基本概念。根据UNIX路径和网络URI的规范，ROS使用斜杠（/）来分隔命名空间。ROS可以在不同的命名空间中启动同一个节点来避免命名冲突。</p><p>例如，具有两个相机的机器人可以在不同的命名空间<code>left</code>和<code>right</code>中启动两个相机的节点，最终会有两路图像流，分别为<code>left/image</code>和<code>right/image</code>。</p><h2 id="重映射-Remap"><a href="#重映射-Remap" class="headerlink" title="重映射 Remap"></a>重映射 Remap</h2><p>命名空间避免了命名的冲突，以相机为例，左相机发布的图像流话题为<code>left/image</code>，而在ROS中存在另一个节点nodex，专门接收<code>image</code>话题，由于两个话题在不同的命名空间之下，因此无法接收到左相机的图像信息。为了解决这个问题，一种方法是在同一个命名空间下启动这个节点，即在<code>left</code>命名空间下启动节点nodex，于是节点变为<code>left/nodex</code>，此时接收的image话题也将变为<code>left/image</code>。但是在复杂的程序当中，有可能节点需要“深入”不止一个命名空间之中，十分不方便。因此ROS中还可以用重映射（remap）的方式来解决这个问题。</p><p>在ROS中，程序中任何一个用于命名的字符串都可以在运行时重映射。例如，ROS中的一个常用程序image_view将image主题实时渲染在窗口上。使用重映射，可以使image_view接收<code>left/image</code>或者<code>right/image</code>，而无需修改image_view的代码。</p><h2 id="命名空间和重映射的使用"><a href="#命名空间和重映射的使用" class="headerlink" title="命名空间和重映射的使用"></a>命名空间和重映射的使用</h2><h3 id="在命令行中使用"><a href="#在命令行中使用" class="headerlink" title="在命令行中使用"></a>在命令行中使用</h3><p>由于ROS的设计模式鼓励软件的重用，重命名在开发和部署ROS软件的时候非常普遍。为了简化操作，ROS在命令行启动节点时提供了标准语法来重命名。</p><ul><li><p>将<code>image</code>话题重映射到<code>right/image</code>可以利用重映射语法来完成：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package image_view image:=right/image</div></pre></td></tr></table></figure></li><li><p>把节点放置到命名空间中可以利用<code>__ns</code>命名空间重映射语法来完成：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package camera __ns:=right</div></pre></td></tr></table></figure></li><li><p>修改节点的名字可以利用<code>__name</code>重命名语法来完成：  </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun package camera __name:=camera2</div></pre></td></tr></table></figure></li></ul><h3 id="在launch文件中使用"><a href="#在launch文件中使用" class="headerlink" title="在launch文件中使用"></a>在launch文件中使用</h3><ul><li><p>通过设置name参数来确定节点的名字：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;node name=&quot;turtlesim_node2&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot;/&gt;</div></pre></td></tr></table></figure></li><li><p>通过设置ns参数来确定默认命名空间：    </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;node name=&quot;turtlesim_node&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot; ns=&quot;sim1&quot; /&gt;</div></pre></td></tr></table></figure></li><li><p>通过remap标签设置重映射：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;remap from=&quot;image&quot; to=&quot;right/image&quot;/&gt;</div></pre></td></tr></table></figure></li></ul><h3 id="在ROS程序终端中使用"><a href="#在ROS程序终端中使用" class="headerlink" title="在ROS程序终端中使用"></a>在ROS程序终端中使用</h3><p>可以利用环境变量设置默认命名空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> ROS_NAMESPACE=default-namespace</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ROS的命名&quot;&gt;&lt;a href=&quot;#ROS的命名&quot; class=&quot;headerlink&quot; title=&quot;ROS的命名&quot;&gt;&lt;/a&gt;ROS的命名&lt;/h2&gt;&lt;p&gt;命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为cam
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：自定义服务</title>
    <link href="http://yluo.name/2019/08/06/ros_service/"/>
    <id>http://yluo.name/2019/08/06/ros_service/</id>
    <published>2019-08-06T07:00:00.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS中的服务"><a href="#ROS中的服务" class="headerlink" title="ROS中的服务"></a>ROS中的服务</h1><p>服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（Request），由服务端（Server）节点处理后反馈应答（Response）。</p><h1 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h1><p>ROS中的服务可以通过srv文件夹下的xxx.srv文件进行语言无关的接口定义。文件包括请求与应答两个数据域，使用“—-”进行分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int64 a</div><div class="line">int64 b</div><div class="line">---</div><div class="line">int64 sum</div></pre></td></tr></table></figure><h1 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h1><p>首先需要在package.xml文件表明对消息生成系统的依赖，即构建依赖项message_generation和运行依赖项message_runtime：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;build_depend&gt;rospy&lt;/build_depend&gt;</div><div class="line">&lt;run_depend&gt;rospy&lt;/run_depend&gt;</div><div class="line"></div><div class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</div><div class="line">&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;</div></pre></td></tr></table></figure><p>随后在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find_package(catkin REQUIRED COMPONENTS</div><div class="line">    ...</div><div class="line">    message_generation</div><div class="line">)</div></pre></td></tr></table></figure></p><p>同时，利用catkin_package函数设置运行依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catkin_package(</div><div class="line">    ...</div><div class="line">    CATKIN_DEPENDS message_runtime ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>并添加需要参与编译的srv文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">add_service_files(</div><div class="line">    FILES</div><div class="line">    xxx.srv</div><div class="line">    ...</div><div class="line">)</div></pre></td></tr></table></figure></p><p>确保CMake知道在消息文件更改后重新编译msg文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">generate_messages(</div><div class="line">    DEPENDENCIES</div><div class="line">    std_msgs</div><div class="line">)</div></pre></td></tr></table></figure></p><p>随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rossrv命令检验服务的定义是否和我们想的一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rossrv show xxx</div></pre></td></tr></table></figure></p><p>还可以使用rossrv list来查看所有可用的服务，使用rossrv packages来查看所有提供了服务的包，使用rossrv package xxx来查看xxx功能包提供的服务。</p><p>注意，ROS中还有一个命令rosservice，这个命令是用来在ROS运行时和启动的服务进行交互的命令，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice call /spawn 8.0 8.0 0.0 &apos;turtle2&apos;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS中的服务&quot;&gt;&lt;a href=&quot;#ROS中的服务&quot; class=&quot;headerlink&quot; title=&quot;ROS中的服务&quot;&gt;&lt;/a&gt;ROS中的服务&lt;/h1&gt;&lt;p&gt;服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（R
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：CMakeLists.txt文件</title>
    <link href="http://yluo.name/2019/08/06/ros_cmakelist/"/>
    <id>http://yluo.name/2019/08/06/ros_cmakelist/</id>
    <published>2019-08-06T06:17:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><p>ROS中使用的编译器catkin是对cmake的一种封装，因此编译规则使用的也是CMakeLists.txt文件，关于CMakeLists.txt文件的规则之前在博客中已经提及过，不再赘述。</p><h1 id="编译规则"><a href="#编译规则" class="headerlink" title="编译规则"></a>编译规则</h1><p>在ROS功能包中的CMakeLists文件主要包括以下配置项：</p><ul><li>project(PROJ_NAME): 项目名称，一般情况下使用catkin_create_pkg命令会自动生成；</li><li>find_package(catkin REQUIRED COMPONTS rospy roscpp …): 寻找相关的功能包；</li><li>include_directories(include ${catkin_INCLUDE_DIRES}): 设置头文件的相对路径，通常在功能包下将相关的头文件都放置在include文件夹下；</li><li>add_executable(node_name src/xxx.cpp): 设置需要编译的代码和生成的可执行文件；</li><li>target_link_libraries(node_name ${catkin_LIBRARIES}): 设置链接库；</li><li>add_dependencies(node_name ${PROJECT_NAME}_generate_messages_cpp): 设置依赖，一般情况下自定义了消息类型的话便需要添加依赖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CMakeLists-txt&quot;&gt;&lt;a href=&quot;#CMakeLists-txt&quot; class=&quot;headerlink&quot; title=&quot;CMakeLists.txt&quot;&gt;&lt;/a&gt;CMakeLists.txt&lt;/h1&gt;&lt;p&gt;ROS中使用的编译器catkin是对cmak
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="cmake" scheme="http://yluo.name/tags/cmake/"/>
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：package清单文件</title>
    <link href="http://yluo.name/2019/08/06/ros_package_xml/"/>
    <id>http://yluo.name/2019/08/06/ros_package_xml/</id>
    <published>2019-08-06T06:00:00.000Z</published>
    <updated>2020-02-02T14:11:00.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="package清单文件"><a href="#package清单文件" class="headerlink" title="package清单文件"></a>package清单文件</h1><p>每一个ROS的功能包都包含一个package.xml的功能包清单文件，用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。</p><h1 id="package-xml规则"><a href="#package-xml规则" class="headerlink" title="package.xml规则"></a>package.xml规则</h1><p>package.xml文件采用xml标记语言来编写，其中的主要信息包括一下几种：</p><ul><li>name: 功能包的名称；</li><li>version: 功能包的版本；</li><li>description: 功能包的描述；</li><li>maintainer: 功能包的维护者信息；</li><li>license: 许可信息，MIT，BSD，GPL等；</li></ul><p>除此之外，package.xml中还包含了功能包所需的各种依赖项，主要包括：</p><ul><li>buildtool_depend: 编译工具依赖项，通常为catkin；</li><li>build_depend: 功能包代码编译所需的依赖项，例如roscpp，rospy，geometry_msgs，message_generation等；</li><li>run_depend: 功能包运行过程中所需的依赖项，例如roscpp，rospy，std_msgs，message_runtime等；</li></ul><p>如果是元功能包，则还需包含一个引用标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;export&gt;</div><div class="line">   &lt;metapackage/&gt;</div><div class="line">&lt;/export&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;package清单文件&quot;&gt;&lt;a href=&quot;#package清单文件&quot; class=&quot;headerlink&quot; title=&quot;package清单文件&quot;&gt;&lt;/a&gt;package清单文件&lt;/h1&gt;&lt;p&gt;每一个ROS的功能包都包含一个package.xml的功能包清单文件
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>机器人操作系统ROS学习笔记：功能包package文件结构</title>
    <link href="http://yluo.name/2019/08/06/ros_package_struct/"/>
    <id>http://yluo.name/2019/08/06/ros_package_struct/</id>
    <published>2019-08-06T05:14:00.000Z</published>
    <updated>2020-02-02T14:31:48.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROS功能包package"><a href="#ROS功能包package" class="headerlink" title="ROS功能包package"></a>ROS功能包package</h1><p>在ROS下，所有的文件按照功能包（package）的形式进行组织，是ROS软件中的基本单元。其中包括ROS节点、库、配置文件等。</p><h1 id="package的典型文件结构"><a href="#package的典型文件结构" class="headerlink" title="package的典型文件结构"></a>package的典型文件结构</h1><p>ROS package的典型结构包含一下文件及文件夹：</p><ul><li>config（文件夹）：放置功能包中的配置文件，由用户创建，文件名可以不同。</li><li>include（文件夹）：放置功能包中需要用到的头文件。</li><li>scripts（文件夹）：放置可以直接运行的Python脚本。</li><li>src（文件夹）：放置需要编译的C++代码。</li><li>launch（文件夹）：放置功能包中的所有启动文件。</li><li>msg（文件夹）：放置功能包自定义的消息类型。</li><li>srv（文件夹）：放置功能包自定义的服务类型。</li><li>action（文件夹）：放置功能包自定义的动作指令。</li><li>CMakeLists.txt（文件）：编译器编译功能包的规则（cmake的规则文件）。</li><li>package.xml（文件）：功能包清单，这个文件可以显示包信息，并注明依赖项，之后可以利用rosdep来安装依赖。</li></ul><h1 id="元功能包meta-package"><a href="#元功能包meta-package" class="headerlink" title="元功能包meta package"></a>元功能包meta package</h1><p>元功能包是一种特殊的功能包，只包含一个package.xml元功能包清单文件，其主要功能是将多个功能包整合成一个逻辑上的独立功能包，类似于功能包集的概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROS功能包package&quot;&gt;&lt;a href=&quot;#ROS功能包package&quot; class=&quot;headerlink&quot; title=&quot;ROS功能包package&quot;&gt;&lt;/a&gt;ROS功能包package&lt;/h1&gt;&lt;p&gt;在ROS下，所有的文件按照功能包（package）的
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="ROS" scheme="http://yluo.name/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu与Windows双系统时间设置问题</title>
    <link href="http://yluo.name/2019/08/01/ubuntu-time/"/>
    <id>http://yluo.name/2019/08/01/ubuntu-time/</id>
    <published>2019-08-01T07:38:00.000Z</published>
    <updated>2020-02-01T14:31:16.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h2><p>现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常时间快8个小时，要么比正常时间慢8个小时。即使利用网络同步时间之后，当切换过系统之后还是会出现时间差的问题。</p><p>这种现象是由于Windows与Ubuntu默认对时间的管理方式不同造成的。我们知道电脑的BIOS里记录着一串时间数据，操作系统就是根据这个数据得到当前时间的。Ubuntu系统使用的是UTC时间（世界协调时），系统会把BIOS里记录的时间看成GMT+0时间，即世界标准时。在Ubuntu系统中有一个设置，是配置当前所在时区的，在中国就会配置为东八区（GMT+8），所以Ubuntu会把BIOS中得到的时间加上8个小时显示出来，随后在系统关机的时候，将当前显示的时间减去8个小时后存入BIOS中。</p><p>而在Windows中，会将BIOS中的时间看做本地时间，直接显示出来，因此，当从Ubuntu切换到Windows时，会出现时间差8个小时的情况。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>最简单的方法就是将Ubuntu下的UTC时间关闭，采用和Window一样的时间管理方式。只需要在Ubuntu终端下运行一行代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo timedatectrl <span class="built_in">set</span>-local-utc 1</div></pre></td></tr></table></figure><p>这样便可以使Windows和Ubuntu下的时间同步了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题缘由&quot;&gt;&lt;a href=&quot;#问题缘由&quot; class=&quot;headerlink&quot; title=&quot;问题缘由&quot;&gt;&lt;/a&gt;问题缘由&lt;/h2&gt;&lt;p&gt;现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Windows" scheme="http://yluo.name/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>分屏终端Terminator上手</title>
    <link href="http://yluo.name/2019/04/06/terminator_intro/"/>
    <id>http://yluo.name/2019/04/06/terminator_intro/</id>
    <published>2019-04-05T16:18:00.000Z</published>
    <updated>2020-02-01T14:31:16.451Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来<a href="https://github.com/ljjhome" target="_blank" rel="external">佳神</a>给推荐了一款老外经常使用的终端Terminator，上手了几天的确感觉很方便，尤其是分屏功能，可以在一个终端上像Vim一样分成多个终端，在使用ROS这种需要同时运行多个终端的软件时尤为便利。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>Terminator可以在同一个窗口上分割多个子窗口，每个小窗口运行独立的命令程序。一个父窗口管理多个子窗口，清晰明了知道每个子窗口的运行情况。可以快速自由切换子窗口，并且对子窗口进行最大化和全屏状态。除此之外还有自定义窗口标题、激活标签等等。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu软件源可以直接安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install terminator</div></pre></td></tr></table></figure></p><p>若想要安装最新版，则需要手动添加ppa<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:gnome-terminator</div><div class="line">sudo apt update</div><div class="line">sudo apt install terminator</div></pre></td></tr></table></figure></p><p>安装后，按终端的快捷键<code>Ctrl+Alt+T</code>便可呼出Terminator终端</p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>设置看个人喜好，配色方案什么的可以在设置菜单终端首选项里自由发挥，对于我来说，我一般配置两个：</p><ul><li>背景配置成80%透明，这样在抄写各种东西的时候很方便，可以透过终端看到终端后面的东西。</li><li>在配置文件里添加对256色的支持，这个在18.04下是迷人支持的，但是在14.04下是不支持的，需要手动开启一下，否则像Vim的插件airline之类的颜色是无法显示的。</li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>水平分屏<code>Ctrl+Shift+O</code></li><li>垂直分屏<code>Ctrl+Shift+E</code></li><li>搜索<code>Ctrl+Shift+F</code> </li><li>复制<code>Ctrl+Shift+C</code></li><li>粘贴<code>Ctrl+Shift+V</code></li><li>关闭当前终端<code>Ctrl+Shift+W</code></li><li>退出当前窗口<code>Ctrl+Shift+Q</code></li><li>切换显示当前窗口<code>Ctrl+Shift+X</code></li><li>全屏状态<code>F11</code></li><li>Clear屏幕<code>Ctrl+Shift+G</code></li><li>移动分隔条<code>Ctrl+Shift+方向键</code></li><li>隐藏/显示滚动条<code>Ctrl+Shift+S</code></li></ul><h1 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a>添加右键菜单</h1><p>若想把Terminator添加到右键菜单方便使用，有2种方案：</p><ul><li><code>nautilus-actions</code>工具，貌似在18.04上不好使</li><li><code>fma-config-tool</code>工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来&lt;a href=&quot;https://github.com/ljjhome&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Linux" scheme="http://yluo.name/tags/Linux/"/>
    
      <category term="Terminator" scheme="http://yluo.name/tags/Terminator/"/>
    
  </entry>
  
  <entry>
    <title>Qt的ui编译机制浅析</title>
    <link href="http://yluo.name/2019/03/17/qt_uic/"/>
    <id>http://yluo.name/2019/03/17/qt_uic/</id>
    <published>2019-03-17T15:15:00.000Z</published>
    <updated>2020-02-01T14:31:16.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt的ui编译机制"><a href="#Qt的ui编译机制" class="headerlink" title="Qt的ui编译机制"></a>Qt的ui编译机制</h1><p>利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用ui文件来编写界面，在cpp中编写界面没有在ui文件中利用拖拽的形式来编写界面来更直观。但是Qt是如何将ui文件转换成C++代码却很令我困惑，因此我特意了解了一下Qt的ui编译机制，加深对Qt的理解。</p><h1 id="利用uic来编译-ui文件"><a href="#利用uic来编译-ui文件" class="headerlink" title="利用uic来编译.ui文件"></a>利用uic来编译.ui文件</h1><p>Qt的.ui文件通过Qt Designer设计好以后，利用uic程序将.ui文件中的xml语法转换为c++的类文件，假设ui文件名为<code>mainwindow.ui</code>，在命令行中输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uic mainwindow.ui -o ui_mainwindow.h</div></pre></td></tr></table></figure></p><blockquote><p>注意：若存在多个Qt版本，则可能需要指定相应uic执行路径</p></blockquote><p>通过uic会生成<code>mainwindow.ui</code>文件对应的头文件<code>ui_mainwindow.h</code>，这个<code>ui_mainwindow.h</code>文件的内容大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">/********************************************************************************</div><div class="line">** Form generated from reading UI file &apos;mainwindow.ui&apos;</div><div class="line">**</div><div class="line">** Created by: Qt User Interface Compiler version 5.9.5</div><div class="line">**</div><div class="line">** WARNING! All changes made in this file will be lost when recompiling UI file!</div><div class="line">********************************************************************************/</div><div class="line"></div><div class="line">#ifndef UI_MAINWINDOW_H</div><div class="line">#define UI_MAINWINDOW_H</div><div class="line"></div><div class="line">#include &lt;QtCore/QVariant&gt;</div><div class="line">#include &lt;QtWidgets/QAction&gt;</div><div class="line">#include &lt;QtWidgets/QApplication&gt;</div><div class="line">#include &lt;QtWidgets/QButtonGroup&gt;</div><div class="line">#include &lt;QtWidgets/QHeaderView&gt;</div><div class="line">#include &lt;QtWidgets/QMainWindow&gt;</div><div class="line">#include &lt;QtWidgets/QMenuBar&gt;</div><div class="line">#include &lt;QtWidgets/QStatusBar&gt;</div><div class="line">#include &lt;QtWidgets/QToolBar&gt;</div><div class="line">#include &lt;QtWidgets/QWidget&gt;</div><div class="line"></div><div class="line">QT_BEGIN_NAMESPACE</div><div class="line"></div><div class="line">class Ui_MainWindow</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    QMenuBar *menuBar;</div><div class="line">    QToolBar *mainToolBar;</div><div class="line">    QWidget *centralWidget;</div><div class="line">    QStatusBar *statusBar;</div><div class="line"></div><div class="line">    void setupUi(QMainWindow *MainWindow)</div><div class="line">    &#123;</div><div class="line">        if (MainWindow-&gt;objectName().isEmpty())</div><div class="line">            MainWindow-&gt;setObjectName(QStringLiteral(&quot;MainWindow&quot;));</div><div class="line">        MainWindow-&gt;resize(400, 300);</div><div class="line">        menuBar = new QMenuBar(MainWindow);</div><div class="line">        menuBar-&gt;setObjectName(QStringLiteral(&quot;menuBar&quot;));</div><div class="line">        MainWindow-&gt;setMenuBar(menuBar);</div><div class="line">        mainToolBar = new QToolBar(MainWindow);</div><div class="line">        mainToolBar-&gt;setObjectName(QStringLiteral(&quot;mainToolBar&quot;));</div><div class="line">        MainWindow-&gt;addToolBar(mainToolBar);</div><div class="line">        centralWidget = new QWidget(MainWindow);</div><div class="line">        centralWidget-&gt;setObjectName(QStringLiteral(&quot;centralWidget&quot;));</div><div class="line">        MainWindow-&gt;setCentralWidget(centralWidget);</div><div class="line">        statusBar = new QStatusBar(MainWindow);</div><div class="line">        statusBar-&gt;setObjectName(QStringLiteral(&quot;statusBar&quot;));</div><div class="line">        MainWindow-&gt;setStatusBar(statusBar);</div><div class="line"></div><div class="line">        retranslateUi(MainWindow);</div><div class="line"></div><div class="line">        QMetaObject::connectSlotsByName(MainWindow);</div><div class="line">    &#125; // setupUi</div><div class="line"></div><div class="line">    void retranslateUi(QMainWindow *MainWindow)</div><div class="line">    &#123;</div><div class="line">        MainWindow-&gt;setWindowTitle(QApplication::translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, Q_NULLPTR));</div><div class="line">    &#125; // retranslateUi</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">namespace Ui &#123;</div><div class="line">    class MainWindow: public Ui_MainWindow &#123;&#125;;</div><div class="line">&#125; // namespace Ui</div><div class="line"></div><div class="line">QT_END_NAMESPACE</div><div class="line"></div><div class="line">#endif // UI_MAINWINDOW_H</div></pre></td></tr></table></figure></p><p>这个文件就是将.ui文件转换为C++可以看得懂的代码，之后参与Qt源代码的编译，可以看到这个文件中定义了一个<code>Ui_MainWindow</code>类，里面包含了在.ui文件中创建的各种窗口部件的实现，文件最后还定义了一个命名空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace Ui &#123;</div><div class="line">    class MainWindow: public Ui_MainWindow &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个命名空间Ui中包含了一个新类<code>MainWindow</code>，而这个新类继承自<code>Ui_MainWindow</code>类，之后我们便可以在别的文件中利用<code>Ui::MainWindow</code>调用这个ui类，或者直接调用<code>Ui_MainWindow</code>也可以。</p><h1 id="Ui调用"><a href="#Ui调用" class="headerlink" title="Ui调用"></a>Ui调用</h1><p>在Qt项目中，在<code>mainwindow.h</code>中添加Ui命名空间的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">namespace Ui &#123;</div><div class="line">class MainWindow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之后在继承<code>QMainWindow</code>类的对象声明中添加成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Ui::MainWindow *ui;</div></pre></td></tr></table></figure></p><p>在<code>mainwindow.cpp</code>的类构造函数中，初始化ui成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ui = new Ui::MainWindow;</div><div class="line">ui-&gt;setupUi(this);</div></pre></td></tr></table></figure></p><p>在类的析构函数中释放ui指针指向的内存空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete ui;</div></pre></td></tr></table></figure></p><p>这样便实现了ui的调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Qt的ui编译机制&quot;&gt;&lt;a href=&quot;#Qt的ui编译机制&quot; class=&quot;headerlink&quot; title=&quot;Qt的ui编译机制&quot;&gt;&lt;/a&gt;Qt的ui编译机制&lt;/h1&gt;&lt;p&gt;利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用
      
    
    </summary>
    
      <category term="技术探索" scheme="http://yluo.name/categories/%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Qt" scheme="http://yluo.name/tags/Qt/"/>
    
      <category term="uic" scheme="http://yluo.name/tags/uic/"/>
    
  </entry>
  
</feed>
