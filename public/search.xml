<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bash下的快捷键]]></title>
    <url>%2F2020%2F02%2F14%2Fbash-shortcuts%2F</url>
    <content type="text"><![CDATA[使用Linux终端的一个重要的原则就是：不要让你的手指离开本位行，这对于一个程序员来说是十分重要的，之前由于不知道Bash下的快捷键，导致经常需要去利用方向键来调整命令输入，比如：已经输入了很长一段指令，结果发现必须要用管理员来运行，没办法，只能靠方向键一直将光标移至命令开头，然后敲上sudo，是不是很麻烦？于是乎，Bash下的快捷键就可以快速地帮助你，当你按下&lt;C-a&gt;或者&lt;C-xx&gt;时，便自动移动到了行首，随后便可以潇洒地输入sudo，飘逸地一个回车，把B装到了极致。 下面是一些终端命令快捷键的总结： 光标移动 快捷键 用途 &lt;C-a&gt;或Home 移动到行首 &lt;C-e&gt;或End 移动到行尾 &lt;ALT-b&gt; 后移一个单词 &lt;C-b&gt; 后移一个字符 &lt;ALT-f&gt; 前移一个单词 &lt;C-f&gt; 前移一个字符 &lt;C-xx&gt; 当前和行首位置切换 剪切删除 快捷键 用途 &lt;C-w&gt; 剪切光标前单词 &lt;C-k&gt; 剪切光标后内容移动到行尾 &lt;C-u&gt; 剪切光标前内容 &lt;C-y&gt; 粘贴剪切板内容 &lt;C-d&gt; 删除当前字符 &lt;ALT-d&gt; 删除光标后所有字符 &lt;C-h&gt; 删除前一字符 进程控制 快捷键 用途 &lt;C-c&gt; 终止当前进程 &lt;C-z&gt; 挂起当前进程，可用fg恢复 &lt;C-d&gt; 关闭shell，同exit 屏幕控制 快捷键 用途 &lt;C-l&gt; 清屏，同clear &lt;C-s&gt; 停止屏幕输出 &lt;C-q&gt; 恢复屏幕输出 大小写 快捷键 用途 &lt;ALT-u&gt; 大写光标位置到单词尾间的字母 &lt;ALT-l&gt; 小写光标位置到单词尾间的字母 &lt;ALT-c&gt; 大写当前单词 其他 快捷键 用途 &lt;ALT-T&gt; 当前单词和前一单词互换 &lt;C-T&gt; 互换光标前两单词位置 &lt;C-_&gt; 撤销]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Microsoft To Do做待办管理]]></title>
    <url>%2F2020%2F02%2F08%2Ftodo-intro%2F</url>
    <content type="text"><![CDATA[强烈安利一款软件：Microsoft To Do，用来实现待办事项管理。可以实现PC端、手机端的同步，实时管理和查看，十分方便。 Windows下安装在Microsoft Store中下载即可。 手机端安装在应用市场下载 Linux下安装Linux下没有To Do的安装包，但是有一个开源软件Ao可以下载，在Github上可以下载。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>To Do</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04下Terminator支持256色]]></title>
    <url>%2F2020%2F02%2F07%2Fterminator-256color%2F</url>
    <content type="text"><![CDATA[问题描述在Ubuntu 16.04下利用apt install terminator安装Terminator后，其版本为0.98。而0.98版本的Terminator默认不支持256色，导致终端下无法显示很多颜色，看上去很难受。 解决方法 打开Terminator，在Preferences中选择Profiles； 在Command选项卡中，将Run a custom command instead of my shell选中； 在Custom command 中输入TERM=xterm-256color bash -l 随后重启Terminator，便可以看到已经支持256色，终端里显示出了更多的颜色，来区分不同的项目了。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Terminator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Powershell运行自定义脚本]]></title>
    <url>%2F2020%2F02%2F05%2Fpowershell-run-script%2F</url>
    <content type="text"><![CDATA[问题描述Windows Powershell为了防止恶意脚本的执行，设计了一个执行策略(Execution Policy)，若发现自定义的脚本无法运行，则需要更改执行策略。 执行策略包括6种类型： Restricted 受限制的，只能执行单个命令，不能执行脚本 AllSigned 允许执行有数字签名的脚本 RemoteSigned 本地脚本可以运行，网络下载的需要数字签名 Unrestricted 无限制，但从网络下载的会有安全提示 Bypass 不设任何限制，且没有安全提示 Undefined 未设置策略，使用继承或默认策略 解决方法利用管理员身份打开Powershell终端，输入以下命令将策略更改为RemoteSigned： 1$ Set-ExecutionPolicy RemoteSigned]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git利用rebase压缩多次commit]]></title>
    <url>%2F2020%2F02%2F05%2Fgit-rebase%2F</url>
    <content type="text"><![CDATA[问题描述有时我们提交到GitHub等远程仓库上的commit太多，想将多次提交的commit合并成一个commit。 解决方法可以利用rebase来压缩多次commit。 1. 首先查看本地提交历史输入以下命令查看master分支的提交历史： 1$ git log 这里会显示master分支自创立以来的所有提交历史，现在假设要合并最近的4次提交。 2. 压缩最近4次提交1$ git rebase -i HEAD~4 该命令执行后，会弹出默认编辑器的编辑窗口，4次提交的信息会倒序排列，最新的提交在最下面。 我们需要将其中第2~4行的第一个单词pick修改为squash这意味着将最后三次提交压缩到倒数第4次提交。随后保存。 3. 处理冲突若有冲突，则会提示需要修改，修改后输入以下命令保存此次压缩： 12$ git add .$ git rebase --continue 如果想要放弃此次压缩，则输入： 1$git rebase --abort 4. 修改描述信息若没有冲突处理，则会直接跳转到修改描述信息的位置，可以修改此次压缩后的commit描述。随后保存。 5. 提交到远程仓库修改完描述信息后便已经完成了提交，若想要推送的远程仓库，则需要覆盖之前的提交，需要强制推送： 1$ git push -f]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu蓝牙不可用]]></title>
    <url>%2F2020%2F02%2F03%2Fubuntu-bluetooth-disabled%2F</url>
    <content type="text"><![CDATA[问题描述之前在Ubuntu下不小心删除了/var/lib/bluetooth/下的文件夹，导致蓝牙界面一直显示disabled。 解决方法在终端里输入以下命令： 1rfkill unblock bluetooth 随后重启系统并打开蓝牙，蓝牙便显示enabled了。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows无法进入睡眠]]></title>
    <url>%2F2020%2F02%2F03%2Fwindows-sleep%2F</url>
    <content type="text"><![CDATA[问题描述自己家的台式机在接通电源的情况下点击开始菜单-&gt;电源-&gt;睡眠，依然无法睡眠，会始终自动唤醒。这是由于Windows开启了离开模式(Away Mode)，一般来说能够改变到离开模式的软件主要有： 迅雷：离开模式下载； 百度网盘：传输时不休眠。 解决方法 按WIN+R打开运行 输入regedit打开注册表编辑器 定位到计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\Power，在右侧找到AwayModeEnabled，若其值为1时表示处于离开模式，无法正常睡眠，将其值改为0即可正常睡眠。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装Nvidia显卡驱动]]></title>
    <url>%2F2020%2F02%2F02%2Fubuntu-install-nvidia-driver%2F</url>
    <content type="text"><![CDATA[通常Ubuntu默认安装的显卡驱动是Nouveau，而为了发挥显卡的最大性能，或者为了给Nvidia显卡安装cuda驱动，都需要将显卡驱动更换为Nvidia的官方驱动。有两种方法： 简单安装若显卡较老的话一般Ubuntu自己的源便会提供驱动，在系统的Additional Driver中选择相应的驱动安装即可，一般写着tested的驱动都是经过测试的，比较稳定。 自行安装若显卡较新的话，Ubuntu自己的源很多时候没有相应的驱动，这时候就需要去Nvidia的官网下载对应的驱动包，比如我现在的电脑显卡是Quadra P1000，我要去Nvidia的官网上下载Linux的驱动安装包，命名通常为NVIDIA-Linux-x86_64-440.44.run，将文件下载到系统中，随后便开始安装 1. 禁用Nouveau在/etc/modprobe.d/blacklist.conf文件的最后一行加上一句话：blacklist nouveau，将Nouveau加入黑名单，保存后输入如下指令生效： 1$ sudo update-initramfs -u 2. 重启电脑进入命令行界面重启之后，可以在登录界面或者进入系统之后，按ctrl+alt+F1进入命令行界面 3. 关闭桌面服务在命令行界面下输入以下命令： 1$ sudo service lightdm stop 4. 安装Nvidia驱动进入驱动安装包下载位置，首先赋予其执行权限： 1$ chmod +x NVIDIA-Linux-x86_64-440.44.run 随后运行并按照提示安装即可（通常用默认选项即可） 1$ sudo ./NVIDIA-Linux-x86_64-440.44.run 5.验证安装安装完成后输入以下指令： 1$ sudo nvidia-smi 若列出了GPU的信息列表则表示安装成功。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkpad-p52-ubuntu-install.md]]></title>
    <url>%2F2020%2F02%2F02%2Fthinkpad-p52-ubuntu-install%2F</url>
    <content type="text"><![CDATA[最近弄了一台Thinkpad P52移动工作站，想在上面安装Windows 10和Ubuntu 16.04作为双系统，但是安装Ubuntu时会出现一个提示：”The system is in low graphic mode”，之后便卡住了，无法安装。后来一顿尝试才发现，这是由于Thinkpad的核显与独显冲突造成的，需要在主板BIOS里禁用核显。 解决方法开机按Enter进入BIOS配置，随后按F1进入BIOS Setup，在Config菜单下选择Display菜单打开，第二项Graphic Device选项中，选择Discrete Graphics，随后保存退出，便实现了核显的禁用。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：Gazebo的更新与配置]]></title>
    <url>%2F2020%2F02%2F02%2Fgazebo-upgrade%2F</url>
    <content type="text"><![CDATA[由于Gazebo随ROS一起安装的版本通常不是当前ROS版本下最新的，因此可以通过手动升级的方式来将Gazebo更新为当前ROS版本下对应的最新版本。 查看当前Gazebo版本输入以下命令查看当前Gazebo版本： 1$ gazebo -v 升级方法执行以下命令升级Gazebo： 1234$ sudo sh -c &apos;echo &quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/gazebo-stable.list&apos;$ wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -$ sudo apt-get update$ sudo apt-get install gazebo7 以Ubuntu 16.04 + ROS Kinetic为例，默认情况下Gazebo的版本为7.0.0，在更新完之后Gazebo的版本便成为7.16.0。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu开机自动挂载硬盘]]></title>
    <url>%2F2020%2F01%2F20%2Fubuntu-mount%2F</url>
    <content type="text"><![CDATA[平时我使用Windows和Linux作为主力双系统，额外采用一块固态硬盘作为数据盘，为了在Linux下使用方便，需要开机自动便将硬盘挂在到/home目录下。 步骤1.查看硬盘信息1$ sudo fdisk -l 其显示信息大致如下： 12Device Boot Start End Sectors Size Id Type/dev/sda1 2048 1000212479 1000210432 477G 7 HPFS/NTFS/exFAT 如果有多个设备，则会显示多个类似信息。 2. 创建需要挂载的目录我希望将硬盘挂载到用户目录下，因此在用户目录下建立SSD/文件夹。 1$ sudo mkdir ~/SSD/ 3. 查看磁盘分区的UUID输入以下指令查看/dev/sda1的信息 1$ sudo blkid 其显示信息如下： 1/dev/sda1: LABEL="SSD" UUID="C28070388070354F" TYPE="ntfs" PARTUUID="40ae352f-01" 其中UUID=&quot;C28070388070354F&quot;便是挂载硬盘的UUID， 其文件系统格式为ntfs。 4. 配置开机自动挂载在/etc/fstab文件中加入如下分区信息，让其开机自动挂载： 1UUID=C28070388070354F /home/think/SSD ntfs defaults 0 0 说明：其格式为 &lt;分区定位&gt; + &lt;挂载点位置&gt; + &lt;挂载磁盘类型&gt; + &lt;挂载参数&gt; + + &lt;磁盘检查&gt;， 分区定位，可以为UUID或LABEL； 挂载点位置，想要挂载硬盘的位置； 挂载磁盘类型，文件系统类型，auto, ext4, ntfs； 挂载参数， 通常为defaults，还可设置为auto, ro, rw； dump备份，dump工具决定何时备份，0表示忽略，1表示备份。通常为0； 磁盘检查，决定文件系统检查顺序， 0表示检查，1表示最高优先权， 2表示其他所有需要被检查的设备。 5. 挂载硬盘执行完之前的步骤已经可以在开机自动挂载了，若想手动挂载也很方便，只需要输入如下命令： 1$ sudo mount -a 这样便可根据/etc/fstab文件中的顺序挂载所有设备。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程：echo指令]]></title>
    <url>%2F2020%2F01%2F19%2Fshell-echo%2F</url>
    <content type="text"><![CDATA[echo命令用于在终端打印一行文本，例如， 12$ echo this is a testthis is a test 经常使用的参数如下： 参数 说明 -n 不输出结尾换行符 -e 启用反斜杠转义的解释 -E 不启用反斜杠转义的解释（默认） 若采用-e， 则下列转义字符将被解释： 参数 说明 \\ 不输出结尾换行符 \b 退格 backspace \c 不再输出后面内容 \e 退出 escape \f 退格 backspace \n 换行 \r 回车 \t 水平tab \v 垂直tab \0NNN 八进制NNN \xHH 16进制HH]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程：who指令]]></title>
    <url>%2F2020%2F01%2F19%2Fshell-who%2F</url>
    <content type="text"><![CDATA[who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。 经常使用的参数如下： 参数 说明 -H, —heading 显示各栏的列标题 -b, —boot 最后一次系统启动时间 -d, —dead 死进程 -l, —login 系统登陆进程 -p, —process 激活进程 -r, —runlevel 当前运行级别 -t, —time 显示最后一次系统时钟改动 -T, -w, —mesg 加入用户信息状态 + - ? -u, —user 列出登陆用户 -a 或 —all 显示全部信息 -b -d -l -p -r -t -T -u 获取本人信息12$ who am ithink pts/18 2020-01-19 23:35 (:0)]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程：date指令]]></title>
    <url>%2F2020%2F01%2F19%2Fshell-date%2F</url>
    <content type="text"><![CDATA[date命令用于显示当前的日期及时间，直接运行可得到如下格式的显示： 12$ dateSun Jan 19 21:42:52 CST 2020 可以在命令后添加参数以设定输出格式(date [OPTION]... [+FORMAT])，例如： 12$ date +%Y%m%d20200119 常用的格式参数如下所示： 参数 说明 %H 小时(00~23) %I 小时(01~12) %M 分(00~59) %m 月(01~12) %p 显示AM或PM %r 时间(hh:mm:ss) %S 秒(00~59) %s 从1970-01-01 00:00:00 UTC开始到现在的秒数 %T 24小时制时间 %H:%M:%S %X 按照当前系统时间格式显示当前时间 %x 按照当前系统日期格式显示当前日期 %Z 时区 %a 星期简称(Sun) %A 星期全称(Sunday) %b 月的简称(Dec) %B 月的全称(December) %c 日期和时间(Sun 19 Jan 2020 10:06:36 PM CST) %d 一个月的第几天(01~31) %D 日期(mm/dd/yy) %w 一个星期的第几天(0代表Sunday) %W 一年的第几个星期(01~53)，星期一为第一天 %y 年的最后两位(20) %Y 年(2020)]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F01%2F18%2Fregexp%2F</url>
    <content type="text"><![CDATA[正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 为什么使用正则表达式在Linux终端和Vim等文本编辑器中经常会使用到正则表达式来匹配期望的文本，通过使用正则表达式可以： 测试字符串内的模式， 例如查看字符串内是否出现电话号码或信用卡号码等； 替换文本， 识别特定文本并进行相关操作； 基于模式匹配从字符串中提取子字符串，可以查找文档内或输入域内特定的文本。 例如，可以使用data(\w)?\.dat可以匹配以下内容： 1234data.datdata1.datdatax.datdataN.dat ?可以匹配文件名中的0个或1个字符，而*通配符匹配0个或多个字符。data.*\.dat可以匹配以下内容： 1234data.datdata2.datdata12.datdataxYZ.dat 语法正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 例如， runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。 runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。 colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符 \f 匹配一个换页符。等价于 \x0c 和 \c \n 匹配一个换行符。等价于 \x0a 和 \cJ \r 匹配一个回车符。等价于 \x0d 和 \cM \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符 \S 匹配任何非空白字符。等价于 \f\n\r\t\v \t 匹配一个制表符。等价于 \x09 和 \cI \v 匹配一个垂直制表符。等价于 \x0b 和 \cK 特殊字符所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 \: runo\*ob 匹配 runo*ob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\放在它们前面。下表列出了正则表达式中的特殊字符： 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $ () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \) * 匹配前面的子表达式0次或多次。要匹配 字符，请使用 `\` + 匹配前面的子表达式1次或多次。要匹配 + 字符，请使用 \+ . 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. [ 标记一个中括号表达式的开始。要匹配 [，请使用 \[ ? 匹配前面的子表达式0次或1次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \? \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。\n 匹配换行符。序列 \\ 匹配 \、，而 \( 则匹配 ( ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^ { 标记限定符表达式的开始。要匹配 {，请使用\{ &#124; 指明两项之间的一个选择。要匹配 &#124;， 请使用 \&#124; 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式0次或多次。例如，zo* 能匹配 z 以及 zoo。* 等价于{0,} + 匹配前面的子表达式1次或多次。例如，zo+ 能匹配 zo 以及 zoo，但不能匹配 z。+ 等价于 {1,} ? 匹配前面的子表达式0次或1次。例如，do(es)? 可以匹配 do 、 does 中的 does 、 doxy 中的 do 。? 等价于 {0,1} {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 Bob 中的 o，但是能匹配 food 中的2个 o {n,} n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 Bob 中的 o，但能匹配 foooood 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o* {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 fooooood 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格 以下正则表达式匹配一个正整数， [1-9]设置第一个数字不是0， [0-9]*表示任意多个数字： 1/[1-9][0-9]*/ 请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定1位但至多2位数字： 1/[0-9]&#123;1,2&#125;/ 上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。改进下，匹配 1~99 的正整数表达式如下： 1/[1-9][0-9]?/ * 、+ 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。 例如，您可能搜索 HTML 文档，以查找在 h1 标签内的内容。HTML 代码如下： 1&lt;h1&gt;RUNOOB-菜鸟教程&lt;/h1&gt; 贪婪：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。 1/&lt;.*&gt;/ 非贪婪：如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 \。 1/&lt;.*?&gt;/ 也可以使用以下正则表达式来匹配 h1 标签，表达式则是： 1/&lt;\w+?&gt;/ 通过在 * 、+ 或 ? 限定符之后放置 ?，该表达式从贪婪表达式转换为非贪婪表达式或者最小匹配。 未完待续。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Qt Creator无法输入中文问题]]></title>
    <url>%2F2020%2F01%2F17%2Fqt_im%2F</url>
    <content type="text"><![CDATA[在Ubuntu 16.04系统下安装Qt5.12.2之后，发现在Qt Creator下无法使用Sogou Linux输入法实现中文输入。这是由于Sogou输入法使用的是fcitx框架，而Qt Creator下缺少fcitx输入法的插件造成的。 解决步骤1. 确认安装fcitx-frontend-qt51sudo apt install fcitx-frontend-qt5 2. 确认该路径下存在文件由于Sogou Linux输入法采用的是fcitx框架，因此，需要确认libfcitxplatforminputcontextplugin.so是否存在 12cd /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontextsls | grep libfcitx 3. 将此lib文件复制到Qt与Qt Creator的对应路径下12sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt5.12.2/5.12.2/gcc_64/plugins/platforminputcontexts/ 随后重启Qt Creator，便可以输入中文了。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
        <tag>Qt</tag>
        <tag>输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu右上角状态指示栏顺序配置]]></title>
    <url>%2F2020%2F01%2F16%2Fubuntu-indicator%2F</url>
    <content type="text"><![CDATA[Ubuntu的右上角状态指示栏(indicator)顺序通常按照先加载靠右，后加载靠左的顺序放置图标，但有时配置顺序不理想，需要手动调整。 设置方法在Ubuntu中存在一个表单，这个表单里固定了一部分indicator的顺序，这个文件保存在如下位置： 1/usr/share/indicator-application/ordering-override.keyfile 若是针对个人用户的配置，可以将ordering-override.keyfile复制到用户目录下： 1cp /usr/share/indicator-application/ordering-override.keyfile ~/.local/share/indicators/application/ 随后利用vim ~/.local/share/indicators/application/ordering-override.keyfile打开.keyfile文件，可以看到，文件里的内容如下所示： 123456[Ordering Index Overrides]nm-applet=1My_Weather_Indicator=2lang_indicator=3bluetooth_manager=4transmission=6 数字越大则越靠近左边，而数字越小则越靠近右边。若想要indicator放置在最左边，则可以使数值为-1： 1indicator_sysmonitor=-1]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 未知索引格式错误]]></title>
    <url>%2F2019%2F09%2F29%2FGit_fatal%2F</url>
    <content type="text"><![CDATA[错误说明运行git status时，提示 1fatal: Unknown index entry format xxxxx 解决方法进入仓库文件夹，输入以下指令： 12rm -f .git/indexgit reset 大功告成，喜大普奔。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：自定义消息类型]]></title>
    <url>%2F2019%2F08%2F06%2Fros_message%2F</url>
    <content type="text"><![CDATA[ROS消息文件ROS的消息文件是一个描述ROS中所使用消息类型的简单文本，通常存放在功能包文件夹下的msg文件夹下，可以被用来生成不同语言的源代码。 消息数据类型ROS中的消息可使用的基本数据类型如下： int8, int16, int32, int64 (plus uint*) float32, float64 string time, duration 可变长度的数组，例如int8[]，以及固定长度的数组，例如float32[10] ROS消息中还有一个特殊的数据类型：Header， 其含有时间戳和坐标系信息。通常在很多msg文件的第一行有： 1Header header 个人理解（不一定准确），Header类型通常包含在频繁发送的消息中，这样订阅节点可以根据Header中的时间戳信息等做信息同步处理。 同时，msg文件中还可以包括其他消息文件类型，例如在下面xxx.msg文件中，使用了Header, string以及另外两个消息类型。 1234Header headerstring child_frame_idgeometry_msgs/PoseWithCovariance posegeometry_msgs/TwistWithCovariance twist 使用消息为了使用消息，需要在package.xml中添加编译依赖和执行依赖： 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 并且在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖： 1234find_package(catkin REQUIRED COMPONENTS ... message_generation) 同时，利用catkin_package函数设置运行依赖： 1234catkin_package( ... CATKIN_DEPENDS message_runtime ...) 并添加需要参与编译的msg文件： 12345add_message_files( FILES xxx.msg ...) 确保CMake知道在消息文件更改后重新编译msg文件： 1234generate_messages( DEPENDENCIES std_msgs) 随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rosmsg命令查看自定义的消息类型： 1rosmsg show xxx 消息相关命令 rosmsg show xxx: 查看消息xxx类型，可以不指定功能包名。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：ROS命名空间及重映射]]></title>
    <url>%2F2019%2F08%2F06%2Fros_namespace%2F</url>
    <content type="text"><![CDATA[ROS的命名命名是ROS中的基本概念。ROS中的节点、话题以及参数都必须有唯一的命名。例如机器人上的相机可以命名为camera，并且相机可以输出一个话题image，同时读取一个frame_rate的参数来控制发送图像的频率。一个有效的命名具备以下特点： 首字符为字母（[a-z|A-Z]）、波浪线（～）或左斜杠（/）。（不可以为下划线_） 后续字符可以是字母或数字（[0-9|a-z|A-Z]）、下划线（_）或者左斜杠（/） 当一个机器人上存在两个相机时，由于相机的功能几乎完全一样，我们没有必要为两个相机分别编写一个程序，同时，也不想让两个相机的话题都发布在image话题上，这样会导致两个相机的画面交替出现。更一般地，命名的冲突在机器人系统中非常容易发生，这是因为机器人上常常包含相同的硬件或软件来简化工作量，例如相同的左右机械臂、相同的相机以及相同的多个轮子。为了避免命名上的冲突，ROS中采用两种机制来处理这种情况：命名空间和重映射。 命名空间 Namespace命名空间是计算机科学中的一个基本概念。根据UNIX路径和网络URI的规范，ROS使用斜杠（/）来分隔命名空间。ROS可以在不同的命名空间中启动同一个节点来避免命名冲突。 例如，具有两个相机的机器人可以在不同的命名空间left和right中启动两个相机的节点，最终会有两路图像流，分别为left/image和right/image。 重映射 Remap命名空间避免了命名的冲突，以相机为例，左相机发布的图像流话题为left/image，而在ROS中存在另一个节点nodex，专门接收image话题，由于两个话题在不同的命名空间之下，因此无法接收到左相机的图像信息。为了解决这个问题，一种方法是在同一个命名空间下启动这个节点，即在left命名空间下启动节点nodex，于是节点变为left/nodex，此时接收的image话题也将变为left/image。但是在复杂的程序当中，有可能节点需要“深入”不止一个命名空间之中，十分不方便。因此ROS中还可以用重映射（remap）的方式来解决这个问题。 在ROS中，程序中任何一个用于命名的字符串都可以在运行时重映射。例如，ROS中的一个常用程序image_view将image主题实时渲染在窗口上。使用重映射，可以使image_view接收left/image或者right/image，而无需修改image_view的代码。 命名空间和重映射的使用在命令行中使用由于ROS的设计模式鼓励软件的重用，重命名在开发和部署ROS软件的时候非常普遍。为了简化操作，ROS在命令行启动节点时提供了标准语法来重命名。 将image话题重映射到right/image可以利用重映射语法来完成： 1$ rosrun package image_view image:=right/image 把节点放置到命名空间中可以利用__ns命名空间重映射语法来完成： 1$ rosrun package camera __ns:=right 修改节点的名字可以利用__name重命名语法来完成： 1$ rosrun package camera __name:=camera2 在launch文件中使用 通过设置name参数来确定节点的名字： 1&lt;node name=&quot;turtlesim_node2&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot;/&gt; 通过设置ns参数来确定默认命名空间： 1&lt;node name=&quot;turtlesim_node&quot; pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node.py&quot; ns=&quot;sim1&quot; /&gt; 通过remap标签设置重映射： 1&lt;remap from=&quot;image&quot; to=&quot;right/image&quot;/&gt; 在ROS程序终端中使用可以利用环境变量设置默认命名空间： 1export ROS_NAMESPACE=default-namespace]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：自定义服务]]></title>
    <url>%2F2019%2F08%2F06%2Fros_service%2F</url>
    <content type="text"><![CDATA[ROS中的服务服务（Service）是ROS节点之间同步通讯的一种方式，允许客户端（Client）节点发布请求（Request），由服务端（Server）节点处理后反馈应答（Response）。 定义服务ROS中的服务可以通过srv文件夹下的xxx.srv文件进行语言无关的接口定义。文件包括请求与应答两个数据域，使用“—-”进行分割。 1234int64 aint64 b---int64 sum 使用服务首先需要在package.xml文件表明对消息生成系统的依赖，即构建依赖项message_generation和运行依赖项message_runtime： 12345&lt;build_depend&gt;rospy&lt;/build_depend&gt;&lt;run_depend&gt;rospy&lt;/run_depend&gt;&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;run_depend&gt;message_runtime&lt;/run_depend&gt; 随后在CMakeLists.txt文件中利用find_package函数增加对message_generation的依赖：1234find_package(catkin REQUIRED COMPONENTS ... message_generation) 同时，利用catkin_package函数设置运行依赖：1234catkin_package( ... CATKIN_DEPENDS message_runtime ...) 并添加需要参与编译的srv文件：12345add_service_files( FILES xxx.srv ...) 确保CMake知道在消息文件更改后重新编译msg文件：1234generate_messages( DEPENDENCIES std_msgs) 随后便可在功能包目录下运行catkin_make进行编译，成功后可使用rossrv命令检验服务的定义是否和我们想的一样：1rossrv show xxx 还可以使用rossrv list来查看所有可用的服务，使用rossrv packages来查看所有提供了服务的包，使用rossrv package xxx来查看xxx功能包提供的服务。 注意，ROS中还有一个命令rosservice，这个命令是用来在ROS运行时和启动的服务进行交互的命令，例如： 1rosservice call /spawn 8.0 8.0 0.0 &apos;turtle2&apos;]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：CMakeLists.txt文件]]></title>
    <url>%2F2019%2F08%2F06%2Fros_cmakelist%2F</url>
    <content type="text"><![CDATA[CMakeLists.txtROS中使用的编译器catkin是对cmake的一种封装，因此编译规则使用的也是CMakeLists.txt文件，关于CMakeLists.txt文件的规则之前在博客中已经提及过，不再赘述。 编译规则在ROS功能包中的CMakeLists文件主要包括以下配置项： project(PROJ_NAME): 项目名称，一般情况下使用catkin_create_pkg命令会自动生成； find_package(catkin REQUIRED COMPONTS rospy roscpp …): 寻找相关的功能包； include_directories(include ${catkin_INCLUDE_DIRES}): 设置头文件的相对路径，通常在功能包下将相关的头文件都放置在include文件夹下； add_executable(node_name src/xxx.cpp): 设置需要编译的代码和生成的可执行文件； target_link_libraries(node_name ${catkin_LIBRARIES}): 设置链接库； add_dependencies(node_name ${PROJECT_NAME}_generate_messages_cpp): 设置依赖，一般情况下自定义了消息类型的话便需要添加依赖。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：package清单文件]]></title>
    <url>%2F2019%2F08%2F06%2Fros_package_xml%2F</url>
    <content type="text"><![CDATA[package清单文件每一个ROS的功能包都包含一个package.xml的功能包清单文件，用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。 package.xml规则package.xml文件采用xml标记语言来编写，其中的主要信息包括一下几种： name: 功能包的名称； version: 功能包的版本； description: 功能包的描述； maintainer: 功能包的维护者信息； license: 许可信息，MIT，BSD，GPL等； 除此之外，package.xml中还包含了功能包所需的各种依赖项，主要包括： buildtool_depend: 编译工具依赖项，通常为catkin； build_depend: 功能包代码编译所需的依赖项，例如roscpp，rospy，geometry_msgs，message_generation等； run_depend: 功能包运行过程中所需的依赖项，例如roscpp，rospy，std_msgs，message_runtime等； 如果是元功能包，则还需包含一个引用标签： 123&lt;export&gt; &lt;metapackage/&gt;&lt;/export&gt;]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：功能包package文件结构]]></title>
    <url>%2F2019%2F08%2F06%2Fros_package_struct%2F</url>
    <content type="text"><![CDATA[ROS功能包package在ROS下，所有的文件按照功能包（package）的形式进行组织，是ROS软件中的基本单元。其中包括ROS节点、库、配置文件等。 package的典型文件结构ROS package的典型结构包含一下文件及文件夹： config（文件夹）：放置功能包中的配置文件，由用户创建，文件名可以不同。 include（文件夹）：放置功能包中需要用到的头文件。 scripts（文件夹）：放置可以直接运行的Python脚本。 src（文件夹）：放置需要编译的C++代码。 launch（文件夹）：放置功能包中的所有启动文件。 msg（文件夹）：放置功能包自定义的消息类型。 srv（文件夹）：放置功能包自定义的服务类型。 action（文件夹）：放置功能包自定义的动作指令。 CMakeLists.txt（文件）：编译器编译功能包的规则（cmake的规则文件）。 package.xml（文件）：功能包清单，这个文件可以显示包信息，并注明依赖项，之后可以利用rosdep来安装依赖。 元功能包meta package元功能包是一种特殊的功能包，只包含一个package.xml元功能包清单文件，其主要功能是将多个功能包整合成一个逻辑上的独立功能包，类似于功能包集的概念。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu与Windows双系统时间设置问题]]></title>
    <url>%2F2019%2F08%2F01%2Fubuntu-time%2F</url>
    <content type="text"><![CDATA[问题缘由现在很多人都在电脑里安装了Ubuntu和Windows双系统，在安装完系统之后会发现，系统的显示时间经常会出问题，要么比正常时间快8个小时，要么比正常时间慢8个小时。即使利用网络同步时间之后，当切换过系统之后还是会出现时间差的问题。 这种现象是由于Windows与Ubuntu默认对时间的管理方式不同造成的。我们知道电脑的BIOS里记录着一串时间数据，操作系统就是根据这个数据得到当前时间的。Ubuntu系统使用的是UTC时间（世界协调时），系统会把BIOS里记录的时间看成GMT+0时间，即世界标准时。在Ubuntu系统中有一个设置，是配置当前所在时区的，在中国就会配置为东八区（GMT+8），所以Ubuntu会把BIOS中得到的时间加上8个小时显示出来，随后在系统关机的时候，将当前显示的时间减去8个小时后存入BIOS中。 而在Windows中，会将BIOS中的时间看做本地时间，直接显示出来，因此，当从Ubuntu切换到Windows时，会出现时间差8个小时的情况。 解决方法最简单的方法就是将Ubuntu下的UTC时间关闭，采用和Window一样的时间管理方式。只需要在Ubuntu终端下运行一行代码： 1$ sudo timedatectrl set-local-utc 1 这样便可以使Windows和Ubuntu下的时间同步了。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分屏终端Terminator上手]]></title>
    <url>%2F2019%2F04%2F06%2Fterminator_intro%2F</url>
    <content type="text"><![CDATA[之前使用Ubuntu时一直使用系统自带的终端，最苦恼的便是在同时使用多个终端的时候互相重叠，很难控制，有时候甚至找不到之前开的终端跑到哪里了。后来佳神给推荐了一款老外经常使用的终端Terminator，上手了几天的确感觉很方便，尤其是分屏功能，可以在一个终端上像Vim一样分成多个终端，在使用ROS这种需要同时运行多个终端的软件时尤为便利。 特点Terminator可以在同一个窗口上分割多个子窗口，每个小窗口运行独立的命令程序。一个父窗口管理多个子窗口，清晰明了知道每个子窗口的运行情况。可以快速自由切换子窗口，并且对子窗口进行最大化和全屏状态。除此之外还有自定义窗口标题、激活标签等等。 安装Ubuntu软件源可以直接安装1sudo apt install terminator 若想要安装最新版，则需要手动添加ppa123sudo add-apt-repository ppa:gnome-terminatorsudo apt updatesudo apt install terminator 安装后，按终端的快捷键Ctrl+Alt+T便可呼出Terminator终端 设置设置看个人喜好，配色方案什么的可以在设置菜单终端首选项里自由发挥，对于我来说，我一般配置两个： 背景配置成80%透明，这样在抄写各种东西的时候很方便，可以透过终端看到终端后面的东西。 在配置文件里添加对256色的支持，这个在18.04下是迷人支持的，但是在14.04下是不支持的，需要手动开启一下，否则像Vim的插件airline之类的颜色是无法显示的。 快捷键 水平分屏Ctrl+Shift+O 垂直分屏Ctrl+Shift+E 搜索Ctrl+Shift+F 复制Ctrl+Shift+C 粘贴Ctrl+Shift+V 关闭当前终端Ctrl+Shift+W 退出当前窗口Ctrl+Shift+Q 切换显示当前窗口Ctrl+Shift+X 全屏状态F11 Clear屏幕Ctrl+Shift+G 移动分隔条Ctrl+Shift+方向键 隐藏/显示滚动条Ctrl+Shift+S 添加右键菜单若想把Terminator添加到右键菜单方便使用，有2种方案： nautilus-actions工具，貌似在18.04上不好使 fma-config-tool工具]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Terminator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt的ui编译机制浅析]]></title>
    <url>%2F2019%2F03%2F17%2Fqt_uic%2F</url>
    <content type="text"><![CDATA[Qt的ui编译机制利用Qt来设计GUI界面有两种方法，一种是直接在cpp文件中编写界面，另一种就是利用ui文件来编写界面，在cpp中编写界面没有在ui文件中利用拖拽的形式来编写界面来更直观。但是Qt是如何将ui文件转换成C++代码却很令我困惑，因此我特意了解了一下Qt的ui编译机制，加深对Qt的理解。 利用uic来编译.ui文件Qt的.ui文件通过Qt Designer设计好以后，利用uic程序将.ui文件中的xml语法转换为c++的类文件，假设ui文件名为mainwindow.ui，在命令行中输入如下命令:1uic mainwindow.ui -o ui_mainwindow.h 注意：若存在多个Qt版本，则可能需要指定相应uic执行路径 通过uic会生成mainwindow.ui文件对应的头文件ui_mainwindow.h，这个ui_mainwindow.h文件的内容大致如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/********************************************************************************** Form generated from reading UI file &apos;mainwindow.ui&apos;**** Created by: Qt User Interface Compiler version 5.9.5**** WARNING! All changes made in this file will be lost when recompiling UI file!********************************************************************************/#ifndef UI_MAINWINDOW_H#define UI_MAINWINDOW_H#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QAction&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QButtonGroup&gt;#include &lt;QtWidgets/QHeaderView&gt;#include &lt;QtWidgets/QMainWindow&gt;#include &lt;QtWidgets/QMenuBar&gt;#include &lt;QtWidgets/QStatusBar&gt;#include &lt;QtWidgets/QToolBar&gt;#include &lt;QtWidgets/QWidget&gt;QT_BEGIN_NAMESPACEclass Ui_MainWindow&#123;public: QMenuBar *menuBar; QToolBar *mainToolBar; QWidget *centralWidget; QStatusBar *statusBar; void setupUi(QMainWindow *MainWindow) &#123; if (MainWindow-&gt;objectName().isEmpty()) MainWindow-&gt;setObjectName(QStringLiteral(&quot;MainWindow&quot;)); MainWindow-&gt;resize(400, 300); menuBar = new QMenuBar(MainWindow); menuBar-&gt;setObjectName(QStringLiteral(&quot;menuBar&quot;)); MainWindow-&gt;setMenuBar(menuBar); mainToolBar = new QToolBar(MainWindow); mainToolBar-&gt;setObjectName(QStringLiteral(&quot;mainToolBar&quot;)); MainWindow-&gt;addToolBar(mainToolBar); centralWidget = new QWidget(MainWindow); centralWidget-&gt;setObjectName(QStringLiteral(&quot;centralWidget&quot;)); MainWindow-&gt;setCentralWidget(centralWidget); statusBar = new QStatusBar(MainWindow); statusBar-&gt;setObjectName(QStringLiteral(&quot;statusBar&quot;)); MainWindow-&gt;setStatusBar(statusBar); retranslateUi(MainWindow); QMetaObject::connectSlotsByName(MainWindow); &#125; // setupUi void retranslateUi(QMainWindow *MainWindow) &#123; MainWindow-&gt;setWindowTitle(QApplication::translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, Q_NULLPTR)); &#125; // retranslateUi&#125;;namespace Ui &#123; class MainWindow: public Ui_MainWindow &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_MAINWINDOW_H 这个文件就是将.ui文件转换为C++可以看得懂的代码，之后参与Qt源代码的编译，可以看到这个文件中定义了一个Ui_MainWindow类，里面包含了在.ui文件中创建的各种窗口部件的实现，文件最后还定义了一个命名空间：123namespace Ui &#123; class MainWindow: public Ui_MainWindow &#123;&#125;;&#125; 这个命名空间Ui中包含了一个新类MainWindow，而这个新类继承自Ui_MainWindow类，之后我们便可以在别的文件中利用Ui::MainWindow调用这个ui类，或者直接调用Ui_MainWindow也可以。 Ui调用在Qt项目中，在mainwindow.h中添加Ui命名空间的声明：123namespace Ui &#123;class MainWindow;&#125; 之后在继承QMainWindow类的对象声明中添加成员变量：1Ui::MainWindow *ui; 在mainwindow.cpp的类构造函数中，初始化ui成员变量：12ui = new Ui::MainWindow;ui-&gt;setupUi(this); 在类的析构函数中释放ui指针指向的内存空间：1delete ui; 这样便实现了ui的调用。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>uic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt高分屏支持]]></title>
    <url>%2F2019%2F03%2F17%2Fqt_high_dpi%2F</url>
    <content type="text"><![CDATA[随着智能手机等电子设备的发展，越来越多的电子设备开始使用上了高分屏，高分屏的确让屏幕的观感更好，但是若没有相应的支持，由于DPI过高，会导致程序字体按钮等看上去特别小，影响使用。而Qt从5.6版本开始对高分屏有了相应的支持，只需要一行代码即可完成对高分屏的支持。 代码使用在程序的main函数中QApplication对象初始化之前加入如下一行代码即可： 1QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); 这个文件看上去大致如下： 123456789101112#include "mainwindow.h" //头文件#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication::setAttribute(Qt::AA_EnableHighDpiScaling); //添加高分屏支持 QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();&#125; 说明添加完上述代码后，若是高分屏的电脑则会将Qt的窗口相应的放大，若不是高分屏的电脑则分辨率不变，这样便实现了对高分屏的支持。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
        <tag>Qt</tag>
        <tag>高分辨率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM插件推荐]]></title>
    <url>%2F2019%2F03%2F06%2Fvim_intro%2F</url>
    <content type="text"><![CDATA[作为一个半入门级程序员，不会使用VIM这种大神级的文本编辑器，总感觉到心里有一丝丝的羞愧～～正好赶上这段空闲时间，便在网上买了一本《Practical VIM》，从头开始对VIM进行一下系统的学习。推荐一下Vim下的牛逼插件。 Vundle 下载地址: https://github.com/VundleVim/Vundle.vim 超级方便的插件管理工具，我只能说这个是安装管理所有插件的开始，第一需要安装的就是它！ airline 下载地址：https//github.com/vim-airline/vim-airline vim状态提示栏，我认为的必需插件之一！ YouCompeleteMe 下载地址： https://github.com/Valloric/YouCompleteMe 超强悍代码补全插件 tpopetpope不是插件，而是一个人，Vim插件的最主要贡献者之一，提供了众多好用插件，看看Github上的star就明白了，再此只推荐几个我经常用的。 tpope/vim-fugitive tpope/vim-surround tpope/vim-abolish tpope/vim-commentary]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vim plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim相关指令汇总]]></title>
    <url>%2F2019%2F03%2F05%2Fvim_cmd%2F</url>
    <content type="text"><![CDATA[查找指令 f{char}/F{char} 在行内查找下/上一指定字符，光标停留在查找到的指定字符上，重复;，回退,； t{char}/T{char} 在行内查找下/上一指定字符，光标停留在查找到的指定字符之前，重复;，回退,； /pattern&lt;CR&gt;/?pattern&lt;CR&gt; 在文档中查找下/上一处匹配项，重复n，回退N； * 查找当前光标下的单词，重复n，回退N。 替换指令 :s/target/replacement 执行一处替换 :s/target/replacement/g 执行一行替换 :%s/target/replacement/g 执行全文替换 移动指令 j,k/gj,gk 移动实际行/屏幕行 0/g0 移动到实际行/屏幕行行首 ^/g^ 移动到实际行/屏幕行的第一个非空白字符 `/`g 移动到实际行/屏幕行的行尾 基于单词移动 w 正向移动到下一单词开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾 W 正向移动到下一字串开头 B 反向移动到当前字串/上一字串的开头 E 正向移动到当前字串/下一字串的结尾 gE 反向移动到上一字串的结尾 简单理解：字串比单词更长，e.g.为4个单词或1个字串，如果要删除的词里有特殊符号，则用字串删除更方便 删除指令 x/dl 删除当前字符 dd 删除当前行 dw 删除当前单词 daw 删除当前文本对象 dap 删除当前段落 &lt;C-h&gt; 插入模式下删除前一个字符（同退格键）(bash也可用) &lt;C-w&gt; 插入模式下删除前一个单词(bash也可用) &lt;C-u&gt; 插入模式下删除至行首(bash也可用) 复制和粘贴指令 y 复制yank yw 复制当前单词 yap 复制当前段落 &quot;ayw 复制当前单词到a寄存器 p 粘贴put（光标之后） &quot;ap 将寄存器a中的内容复制到当前位置 P 粘贴（光标之前） &lt;C-o&gt;{register} 在插入模式下，粘贴寄存器{register}中的内容到当前光标下 运算指令 [count]&lt;C-a&gt; 对当前光标上或之后的数值加[count] [count]&lt;C-x&gt; 对当前光标上或之后的数值减[count] 注：&lt;C-a&gt;与&lt;C-x&gt;可以对光标之后的第一个数值进行操作，不必将光标移动到数值的位置也可。 其他指令 g~ 反转大小写 g~~ 反转当前行大小写 g~w 反转当前单词大小写 g~W 反转当前字串大小写 g~ap 反转当前段落大小写 gU 转换为大写 gUU 转换当前行为大写 gUw 转换当前单词为大写 gUap 转换当前段落为大写 gu 转换为小写 guu 转换当前行为小写 guw 转换当前单词为小写 guap 转换当前段落为小写 &gt;/&lt; 增加/减小缩进 &gt;&gt; 缩进当前行 &gt;w/&gt;l 增加当前行缩进（毕竟单词和字符都在一行） &gt;ap 增加当前段落缩进 = 自动缩进 gc 注释/反注释（需安装tpope/vim-commentary插件） gcc 注释/反注释当前行 gcap 注释当前段落 zz 重绘屏幕，当前行显示在窗口正中 &lt;C-o&gt;zz 在插入模式下切换普通模式并重绘屏幕，之后重新返回插入模式 xp 调换光标之后的两个字符 ddp 调换当前行和它的下一行 yyp 创建当前行副本 跳转指令 m{char} 负责设置标记 \{char}` 负责跳转到标记 经典组合 ea 在单词结尾添加 f,dt. 删除后半句（逗号到句号之间内容） 寄存器说明有名寄存器（普通寄存器） &quot;a~&quot;z 特殊寄存器 &quot;&quot;无名寄存器，缺省使用，x，s，d{motion}，y{motion} 都会覆盖其内容； &quot;0 复制专用寄存器，当使用y{motion}时，会覆盖其内容； &quot;_ 黑洞寄存器，有去无回。 &quot;+/&quot;* 系统剪贴板，有一定区别，但是不加以区分了 &quot;+p 将系统剪贴板的内容粘贴 &quot;= 表达式寄存器 &quot;% 当前文件名（read only） &quot;# 轮换文件名（read only） &quot;. 上次插入的文本（read only） &quot;: 上次执行的Ex命令（read only） &quot;/ 上次查找的模式（可使用:let进行赋值） 技巧总结 能够重复，就别用次数。 dw.要优于2dw和d2w 尽量不用光标键，使手指始终位于本位行上]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CMAKE构建Qt和OpenCV项目]]></title>
    <url>%2F2019%2F03%2F05%2Fcmake_qt_opencv%2F</url>
    <content type="text"><![CDATA[预备知识QtQt是一套完整的跨平台软件开发框架，在开源世界无人不知无人不晓。 官网地址：https://qt.io OpenCV开源计算机视觉库，如何编译OpenCV可以参考我的另一篇博客《利用CMAKE编译OpenCV源码》 CMAKE关于什么是CMAKE可以参考我的另一篇博客《利用CMAKE构建和管理软件项目》。 目录结构 项目目录：qt_cmake 源文件目录： src 文件： main.cpp mainwindow.cpp mainwindow.h mainwindow.ui 构建文件目录：build 文件内容新建一个文件夹名为qt_cmake，在文件夹下新建两个文件夹，一个为src，另一个为build。其中src用来放置工程源代码文件，build用来存放构建生成的项目文件。 在src文件夹下新建main.cpp文件，内容如下:1234567891011#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();&#125; 利用Qt Creator新建一个Qt设计师界面类，会自动生成3个文件：mainwindow.h，mainwindow.cpp，mainwindow.ui。 随后打开mainwindow.cpp文件，在其中填入相关的OpenCV代码做测试：123456789101112131415161718192021#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;opencv2/opencv.hpp&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); cv::Mat srcImg = cv::imread(&quot;/path/to/your/image.jpg&quot;); cv::imshow(&quot;origin image&quot;,srcImg); cv::waitKey(0);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 在src文件夹下建立CMakeLists.txt文件，在里面建立内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041cmake_minimum_required(VERSION 3.1)project(qt_cmake)# Find includes in corresponding build directoriesset(CMAKE_INCLUDE_CURRENT_DIR ON)# Instruct cmake to run moc automatically when neededset(CMAKE_AUTOMOC ON)# Create code from a list of Qt designer ui filesset(CMAKE_AUTOUIC ON)# set OpenCV directory#set(OpenCV_DIR /usr/share/OpenCV)# set Qt directory#set(CMAKE_PREFIX_PATH /home/think/Qt5.11.1/5.11.1/gcc_64/lib/cmake)# Find the QtWidgets libraryfind_package(Qt5 REQUIRED Widgets Core)#find_package(Qt5Widgets CONFIG REQUIRED)# Finde OpenCV libraryfind_package(OpenCV REQUIRED)message(STATUS &quot;OpenCV library status:&quot;)message(STATUS &quot; version: $&#123;OpenCV_VERSION&#125;&quot;)message(STATUS &quot; libraries: $&#123;OpenCV_LIBS&#125;&quot;)message(STATUS &quot; include path: $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)set(SOURCES main.cpp mainwindow.cpp)set(FORMS mainwindow.ui)add_executable(main $&#123;SOURCES&#125; $&#123;FORMS&#125;)#link_directories($&#123;OpenCV_LIBRARY_DIRS&#125;)target_link_libraries(main Qt5::Widgets $&#123;OpenCV_LIBS&#125;) 简单介绍一下CMakeLists.txt文件中代码含义 cmake_minimum_required(VERSION 3.1) 接下来是设置cmake要求的最低版本号：为3.1。CMAKE在3.1版本以上才支持Qt。 project(qt_cmake [CXX] [C] [Java]) 定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的，这个指令隐式的定义了两个cmake变量:qt_cmake_BINARY_DIR以及qt_cmake_SOURCE_DIR。前者指构建路径，后者指工程路径，即CMakeLists.txt所在的路径。 同时cmake系统也帮助我们预定义了PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR变量，他们的值分别跟qt_cmake_BINARY_DIR与qt_cmake_SOURCE_DIR一致。 为了统一起见，建议以后直接使用PROJECT_BINARY_DIR，PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。如果使用了qt_cmake_SOURCE_DIR，修改工程名称后，需要同时修改这些变量。 set(OpenCV_DIR /usr/share/OpenCV) 设置OpenCV_DIR变量，若只安装了一个版本的OpenCV则不用设置这个变量，若存在多个版本的OpenCV则需要利用OpenCV_DIR变量来指定想要的版本。 find_package(OpenCV REQUIRED) find_package这个指令以被用来在系统中自动查找配置构建工程所需的程序库。在linux和unix类系统下这个命令尤其有用。CMake自带的模块文件里有大半是对各种常见开源库的find_package支持，支持库的种类非常多。 当它找到OpenCV程序库之后，就会帮助我们预定义几个变量，OpenCV_FOUND、OpenCV_INCLUDE_DIRS、OpenCV_LIBRARY_DIRS、OpenCV_LIBRARIES，它们分别指是否找到OpenCV，OpenCV的头文件目录，OpenCV的库文件目录，OpenCV的所有库文件列表。 include_directories(${OpenCV_INCLUDE_DIRS}) OpenCV相关包含路径 add_executable(main ${SOURCES} ${FORMS}) 添加可执行文件main target_link_libraries(main Qt5::Widgets ${OpenCV_LIBS}) 添加动态链接库 构建 进入build目录 执行cmake ../src 执行make 运行程序./main]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>Qt</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CMAKE编译OpenCV源码]]></title>
    <url>%2F2019%2F02%2F12%2Fcmake_build_opencv%2F</url>
    <content type="text"><![CDATA[OpenCV是什么OpenCV的中文名称是”开源计算机视觉库“（Open Source Computer Vision Library），于1999年由Intel建立，是一个基于开源发行的跨平台计算机视觉库，可以运行在Linux、Windows、Mac OS、Android、iOS、FreeBSD、OpenBSD等操作系统上。OpenCV由一系列C函数和C++类构成，轻量且高效。除了支持C/C++语言编译开发之外，还支持使用C#，Python、Ruby等语言的接口。 为什么要编译源码在OpenCV的官网提供了许多编译好的Release版本的OpenCV二进制文件，但是由于很多人的需求不同，比如OpenCV官网提供的Windows版本是利用MSVC编译的，但是很多人却需要在Windows下使用MinGW编译代码，因此需要Windows下MinGW可以利用的二进制文件，由于OpenCV提供源码，因此可以利用OpenCV的源码编译出各种二进制文件，也可以修改官网的OpenCV源码并编译后为自己所用。 利用CMAKE编译OpenCV源码关于什么是CMAKE可以参考我的另一篇博客《利用CMAKE构建和管理软件项目》。 安装完CMAKE之后，启动cmake-gui。 指定OpenCV源码存放路径。点击Browse Source按钮，在弹出的对话框中指定OpenCV源码存放路径/path/to/opencv/sources。 指定OpenCV构建存放路径。点击Browse Build按钮，在弹出的对话框中指定OpenCV构建文件存放路径，可随意设置，但不要放在源码路径下。 点击Configure按钮，进行第一次配置，之后会弹出编译器选择对话框，选择想要生成的项目文件（比如MSVC或者MinGW），可以使用默认的编译器，也可以指定编译器，比如在使用MinGW编译时，可以指定采用GCC和G++来编译OpenCV源码。确认无误点击Finish按钮开始第一次配置过程。 第一次配置完成后，会在主对话框上出现很多编译选项，勾选Advanced还会显示更多，这些都是默认的编译选项，可以进行修改，比如勾选WITH_OPENGL和WITH_QT选项等。设置完成后还需要进行第二次配置，再次点击Configure按钮，高亮的选项会变成正常（若还是有高亮选择则需要继续修改配置选项然后点击Configure配置）。 点击Generate生成项目文件，会在构建存放路径下生成对应的项目文件，比如VS的.sln解决方案文件，或者MinGW的Makefile文件，于是便可以利用对应的项目文件生成二进制文件了。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装时如何分配目录空间]]></title>
    <url>%2F2019%2F01%2F25%2Fubuntu-partition%2F</url>
    <content type="text"><![CDATA[写在前面像我这种主力系统为Linux，但是有些软件还必须在Windows上运行的人，在笔记本上安装Linux与Windows是必不可少的。估计很多用双系统的同学在手动安装Ubuntu或者其他Linux发行版时会像我一样，对如何给Linux的各个目录分配空间头疼不已。因此我下定决心研究了一下这些目录的功能，在此分享给大家。 Linux的分区和挂载Linux的分区和Windows有很大不同。在Windows下，是以盘符来分割各个空间，而且一般操作系统都安装在C盘，剩下的D盘，E盘可以用来存储其他的文件和程序。而Linux不同，Linux有一个最基本的根目录/，所有其他的目录都在这个目录下，根目录/就像是一个大房子，/目录下面的其他目录，比如/etc，/boot等，就像是一个一个功能区，/etc用来存储配置文件，/bin用来放二进制程序，/boot用来放启动文件，/home用来放用户的文件等等。 Linux的分区和目录的关系是：可以指定一个目录力的东西存在某个分区里，如果不指定，则这个目录里的东西存在上一级目录所在分区中，如果上一级目录页没有特殊制定分期，则再上溯一级目录，以此类推。最后可以上溯到根目录/。所以装系统的时候，其他的都可以不指定，但是一定要指定/目录存放的分区。 空间分配给Ubuntu一般30G左右就够用了，一般安装的时候我们都给/boot,/swap,/和/home分配一下相应的空间，其余的可以不分配。 /boot为启动分区，分配大小：200MB，分区类型：主分区，分区位置：空间起始位置，用于：Ext4日志文件系统，挂载点：/boot； swap为交换空间，一般为实际内存2倍左右，但是如果内存足够大，就不需要设置。分配大小：内存×2，分区类型：逻辑分区，分区位置：空间起始位置，用于：交换空间，挂载点：SWAP； /为根目录，分配大小：至少10G以上，分区类型：逻辑分区，分区位置：空间起始位置，用于：Ex4日志文件系统，挂载点：/； /home为用户目录，分配大小：剩余所有空间，分区类型：逻辑分区，分区位置：空间起始位置，用于：Ext4日志文件系统，挂载点：/home。 安装启动引导设备Ubuntu采用Grub来引导系统，选择/boot所在分区即可。 UEFI引导下的配置若用UEFI引导系统，则空间分配时无需给/boot分配空间，在安装启动引导设备的选项中，选择Windows Boot Manager所在的分区即可完成引导。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GRUB简介与配置]]></title>
    <url>%2F2019%2F01%2F24%2Fgrub%2F</url>
    <content type="text"><![CDATA[什么是GRUBGNU GRUB（简称“GRUB”）是一个来自GNU项目的启动引导程序。GRUB 来自 GRand Unified Bootloader 的缩写。它的功能是在启动时从 BIOS 接管掌控、加载自身、加载 Linux 内核到内存，然后再把执行权交给内核。一旦内核开始掌控，GRUB 就完成了它的任务，也就不再需要了。GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。 简单的说，如果你的电脑上需要同时安装多个操作系统，比如Windows，Ubuntu，Centos，RHEL等（各种LINUX发行版）的话，就可以利用GRUB来作为启动引导程序，来引导系统启动。 GRUB菜单GRUB 菜单的功能是当默认的内核不是想要的时，允许用户从已经安装的内核中选择一个进行引导。通过上下箭头键允许你选中想要的内核，敲击回车键会使用选中的内核继续引导进程。 GRUB 菜单也提供了超时机制，因此如果用户没有做任何选择，GRUB 就会在没有用户干预的情况下使用默认内核继续引导。敲击键盘上除了回车键之外的任何键会停止终端上显示的倒数计时器。立即敲击回车键会使用默认内核或者选中的内核继续引导进程。 GRUB配置GRUB的一个重要的特性是安装它不需依附一个操作系统，但是这种安装需要一个Linux/Windows副本。由于单独工作，GRUB实质上是一个微型系统，通过链式启动的方式，它可以启动所有安装的主流操作系统。 因此GRUB通常在Linux系统下进行配置。grub.cfg文件是GRUB配置文件。它由grub-mkconfig程序根据用户的配置使用一组主配置文件以及GRUB默认文件而生成。/boot/grub/grub.cfg文件在Linux安装时会初次生成，安装新内核时又会重新生成。但是如果需要手动配置GRUB，则不能修改这个文件，而是修改/etc/default/grub文件，这个文件的内容大致如下所示： 12345678910111213141516171819202122232425262728GRUB_DEFAULT=0GRUB_HIDDEN_TIMEOUT=0GRUB_TIMEOUT=10GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;GRUB_CMDLINE_LINUX=&quot;&quot;# Uncomment to enable BadRAM filtering, modify to suit your needs# This works with Linux (no patch required) and with any kernel that obtains# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)#GRUB_BADRAM=&quot;0x01234567,0xfefefefe,0x89abcdef,0xefefefef&quot;# Uncomment to disable graphical terminal (grub-pc only)#GRUB_TERMINAL=console# The resolution used on graphical terminal# note that you can use only modes which your graphic card supports via VBE# you can see them in real GRUB with the command `vbeinfo&apos;GRUB_GFXMODE=1366x768# Uncomment if you don&apos;t want GRUB to pass &quot;root=UUID=xxx&quot; parameter to Linux#GRUB_DISABLE_LINUX_UUID=true# Uncomment to disable generation of recovery mode menu entries#GRUB_DISABLE_RECOVERY=&quot;true&quot;# Uncomment to get a beep at grub start#GRUB_INIT_TUNE=&quot;480 440 1&quot; 在修改完/etc/default/grub文件之后，需要在终端运行update-grub来更新/boot/grub/grub.cfg文件，这样就完成了对GRUB的配置。 下面介绍几个本人比较常用的GRUB配置。 修改开机默认引导上次选择的操作系统 打开/etc/default/grub文件 1sudo vim /etc/default/grub 修改并加入如下代码 12GRUB_DEFAULT=savedGRUB_SAVEDEFAULT=true 更新/boot/grub/grub.cfg文件 1sudo update-grub 修改GRUB开机引导画面GRUB最爽的就是开机引导画面的定制，可以下载各种大神制作的主题，使开机画面美轮美奂。 下载GRUB主题，将主题下的文件夹中的内容复制到/boot/grub/themes下 1sudo cp -R /path/to/your_theme /boot/grub/themes 修改/etc/default/grub文件 将GRUB_GFXMODE修改为自己屏幕分辨率 1GRUB_GFXMODE=1366*768 修改或添加一行 1GRUB_THEME=/boot/grub/themes/your_theme/theme.txt 更新/boot/grub/grub.cfg文件 1sudo update-grub GRUB引导修复当/boot/grub/grub.conf配置文件丢失, 或者关键配置出现错误, 或者MBR、UEFI记录的引导程序遭到破坏时, Linux主机启动后可能只会出现“grub&gt;”的提示符，无法完成进一步的系统启动过程。 这表示你的grub2的配置文件损坏，GRUB找不到Ubuntu系统的引导项. 从而进入修复模式了(grub rescue), 也称救援模式。在救援模式下只有很少的命令可以用: set，ls，insmod，root，prefix。 命令 描述 set 查看环境变量 ls 查看设备 insmod 加载模块 root 指定用于启动系统的分区，设置GRUB启动分区 prefix 设定GRUB启动路径 进入GRUB救援模式后手动引导系统 利用ls命令列出所有磁盘分区，查找启动分区，一般情况下EFI启动分区大小为500M左右，Linux的/boot分区为200M～500M。 执行以下命令来手动引导系统 1234grub&gt;set root=(hd0,msdos8) //假设启动分区为(hd0,msdos8)grub&gt;set prefix=(hd0,msdos8)/boot/grubgrub&gt;insmod normal //启动normal启动grub&gt;normal 重启之后就可以进入Linux系统了，在进入系统之后，可以更新GRUB引导项来恢复GRUB引导 1sudo update-grub 或者重新安装GRUB 1sudo grub-install /dev/sda // /dev/sda为启动分区位置 注意事项 若系统是用UEFI引导的话，则输入更新GRUB指令sudo update-grub可能无法奏效，这是因为这条命令会更新/boot/grub/grub.cfg文件，但是EFI下的配置文件是在/boot/efi/EFI/ubuntu/grub.cfg路径下，因此需要输入 1sudo grub-mkconfig -o /boot/efi/EFI/ubuntu/grub.cfg 重启便会更新GRUB。 有时GRUB引导进入Ubuntu时会提示file &quot;/boot/grub/grubenv&quot; not found或者file &quot;EFI/ubuntu/grubenv&quot; not found， 出现这种情况话，进入系统，输入 1sudo grub-editenv /boot/grub/grubenv create 或者 1sudo grub-editenv /boot/efi/EFI/ubuntu/grubenv create 来创建GRUB环境文件即可。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>grub</tag>
        <tag>启动管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Shadowsocks代理及终端使用ss]]></title>
    <url>%2F2019%2F01%2F24%2Fterminal_via_ss%2F</url>
    <content type="text"><![CDATA[作为一名勤勤恳恳的科研人员，在使用Ubuntu的时候，避免不了要经常科学上网，最好用的莫过于Shadowsocks代理，在此简单介绍下如何在Ubuntu下使用Shadowsocks（以下简称ss）代理以及让终端也使用ss上网。 预备条件 一台境外VPS服务器，并且已经搭载好ss服务 本机安装了Ubuntu系统（其他Linux发行版操作类似） 安装shadowsocks-qt5shadowsocks-qt5是ss在linux下的gui程序，在终端输入以下指令，添加ss-qt5的PPA源并更新 12$ sudo add-apt-repository ppa:hzwhuang/ss-qt5$ sudo apt-get update 随后安装ss-qt5 1$ sudo apt-get install shadowsocks-qt5 之后运行ss-qt5，在里面配置相应的服务器信息后便可以测试连接是否成功。为了可以在浏览器里方便的使用ss，推荐Chrome浏览器下的插件SwitchyOmega，简单介绍以下SwitchOmega的配置。 安装配置SwitchyOmega在Chrome商店或者https://www.switchyomega.com/download/下载SwitchyOmega插件并安装到Chrome。 随后在SwitchOmega配置中新建一个情景模式proxy,协议选择socks 5, 地址127.0.0.1,端口1080（根据ss-qt5中的配置适当修改）。其实这样配置之后启动proxy模式便可以实现科学上网了，但是此时所有的上网流量都需要经过VPS，很多国内的网站，比如百度等也是需要经过代理上网，增加了上网的延时，因此可以配置PAC来实现墙内网站直接连接，墙外网站走代理的完美解决方案。 配置PAC在SwitchyOmega的自动切换模式下，在规则列表规则前面的框打√，再将后面的情景模式设置为proxy，意思是规则列表中的内容，我们使用proxy情景模式。然后规则列表设置中： 12规则列表格式： AutoProxy规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 输入上面的网址后请点击“立即更新情景模式”，更新成功后可以看到下面的更新时间和内容，这样设置完成 “规则列表规则” 后就不需要在切换规则中一个一个添加条件了。 配置终端走ss代理终端下走代理需要proxychains这个小软件的帮助，首先安装proxychains 1$ sudo apt-get install proxychains 安装完毕后，修改/etc/proxychains.conf中的内容，在最后[ProxyList]选项里填入ss的信息 1socks5 127.0.0.1 1080 这样就已经配置成功了，若想让终端的命令走ss代理的话，就在命令前加上proxychains即可。 验证是否配置成功，首先输入curl ip.gs查看当前未走代理的ip地址，之后输入proxychains curl ip.gs查看走代理的ip地址，若ip地址是VPS的服务器地址，则配置成功。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shadowsocks</tag>
        <tag>bash</tag>
        <tag>proxychains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CMAKE构建和管理软件项目]]></title>
    <url>%2F2019%2F01%2F02%2Fcmake%2F</url>
    <content type="text"><![CDATA[CMAKE是什么CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。 对于一个大型软件，其编译、维护是一个复杂而耗时的过程。它涉及到大量的文件、目录，这些文件可能是在不同的时间、由不同的人、在不同的地方分别写的，其中一些是程序，有些是数据，有些是文档，有些是衍生文件。甚至参与开发的人员也不一定清楚所有文件的细节，包括如何处理它们。此外，构成软件的文件数目可能达到成百上千，甚至成千上万个，开发过程中当修改了少量几个文件后，往往只需要重新编译、生成少数几个文件。有效地描述这些文件之间的依赖关系以及处理命令，当个别文件改动后仅执行必要的处理，而不必重复整个编译过程，可以大大提高软件开发的效率。 为什么用CMAKE如果你之前有过维护软件包的构建和安装的经验，你就会对CMake有兴趣。当前很多项目都可以在Linux下用Makefile和在Windows下用Visual Studio进行编译；这要求开发者在对应的系统下保持构建工具的更新，并且不同系统的构建行为保持一致；如果再引入XCode，这需要更多的构建工具，这样会是一个问题。如果在此基础上引入可选组件，比如如果系统上有libjpeg，项目就支援JPEG，这会造成更大的麻烦。CMake提供了一个简单的，易于理解的文件格式来解决上述问题。如果一个项目有多个开发者参与，或者这个项目有多个目标平台；那么不可避免的需要在多台PC上进行构建，不同的PC在开发环境上会有差异。 自动进行项目构建所需的program、library、header file的查找能力； 在source tree以外进行构建的能力； 为Qt moc，SWIG等自动产生复杂的自定义命令的能力； 在configuration阶段进行可选组件定制的能力； 自动从简单文件文件产生workspace和project的能力； 配置生成静态库/动态库的能力； 自动产生文件依赖，支持并行编译； CMAKE基本语法build的过程由每个目录下的名为CMakeFileLists.txt的文件组成的一系列文件列表所控制；CMakeFileLists.txt文件由CMake语句进行项目描述，CMake语句的语法为： 1command(args...) command是命令的名字，CMake是不区分大小写的； args是一系列由空格分隔的参数，如果参数中有空格，参数需要用双引号引起来； 变量被引用的格式是${VAR}; 多个参数可以使用set来使之构成一个list。 1set(Foo a b c) 这样设置的结果是Foo的值是 a b c; CMake可以直接访问系统环境变量和Windows注册表；访问系统环境变量的语法： 1$Env&#123;ARG&#125; 访问Windows注册表： 1[HKEY_CURRENT_USER\\Software\\path1\\path2;key] 如何运行CMAKE举一个简单的例子，在文件夹下建立一个C语言源文件main.c，内容如下： 123456789101112#include &lt;stdio.h&gt;void main()&#123; float sum; int i; for(int i=0;i&lt;100;i++) sum += 0.1; printf(&quot;sum:%f\n&quot;,sum);&#125; 在文件夹下建立CMakeLists.txt文件，内容如下： 12cmake_minimum_required(VERSION 2.8)add_executable(Main main.c) 在终端运行： 1$cmake . 则可以看到在文件夹下生成了Makefile文件，紧接着运行：1$make 在文件夹下看到生成了可执行文件Main，于是在终端运行：1$./Main 可以看到终端运行了程序并输出：1$sum:10.000002 后记强烈推荐一本CMAKE圣经《Mastering CMAKE》，CMAKE的强大之处只有一点点的学习体会才能感受到，我也会在今后的学习中慢慢领悟CMAKE的精髓，用CMAKE来管理构建我自己的项目。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络初探（四）：网络里的中间商—正向代理与反向代理]]></title>
    <url>%2F2018%2F12%2F29%2Fnetwork_4%2F</url>
    <content type="text"><![CDATA[知乎网络大神车小胖对于正向代理与反向代理做了一个有趣的类比： 很久以前，老王去饭店吃饭，需要先到饭店，七荤八素点好菜，坐等饭菜上桌，然后大快朵颐，不亦乐乎。有了第三方订餐外卖平台，老王懒得动身前往饭店，老王打个电话或用APP，先选好某个饭店，再点好菜，外卖小哥会送上门来。这种模式被起名为正向代理（Forward Proxy）由于某个品牌的饭店口碑特别好，食客络绎不绝涌入，第三方订餐电话也不绝于耳，但是限于饭店接待能力有限，无法提供及时服务，很多食客等得不耐烦了，纷纷铩羽而归，饭店老总看着煮熟的鸭子飞走了，心疼不已。痛定思痛，老总又成立了几个连锁饭店，形成一个集群，对外提供统一标准的菜品服务，电话订餐电话400-xxx-7777，当食客涌入饭店总台，总台将食客用大巴运到各个连锁店，这样食客既不需要排队，各连锁店都能高速运转起来，一举两得，老总乐开了花，并为此种运作模式起名为反向代理（Reverse Proxy）。反向代理在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。 概念正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。 反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。 区别正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。 正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。 正向代理和反向代理最关键的两点区别： 是否指定目标服务器 客户端是否要做设置 正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。 从用途上来区分： 正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率 反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能 从安全性来讲： 正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务 反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器 使用场景正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。 从上面的介绍也就可以猜出来正向代理的至少一个功能（比如科学上网），也即： 用户A无法访问facebook，但是能访问服务器B，而服务器B可以访问facebook。于是用户A访问服务器B，通过服务器B去访问facebook，，服务器B收到请求后，去访问facebook，facebook把响应信息返回给服务器B，服务器B再把响应信息返回给A。这样，通过代理服务器B，就实现了翻墙。 从上面的介绍也可以猜出来反向代理的至少一个功能（比如负载均衡），也即： 假设用户A访问 http://www.somesite.com/something.html，但www.somesite.com上并不存在something.html页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道something.html页面究竟位于哪台机器上。当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。 当然反向代理的作用还有很多，这里简单列举一下： 保护和隐藏原始资源服务器 加密和SSL加速 负载均衡 缓存静态内容 压缩 减速上传 安全 外网发布 总结总之，正向代理代理的对象是客户端，反向代理代理的对象是服务端；正向代理隐藏了真实的客户端，反向代理隐藏了真实的服务端。]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>正向代理</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用make编译LaTeX文档]]></title>
    <url>%2F2018%2F12%2F20%2Fmake_latex%2F</url>
    <content type="text"><![CDATA[由于一直使用Ubuntu作为主力系统，很多代码编写的工作都用VIM来完成，VIM这个牛逼闪闪的编辑器的确装逼范十足，让人爱不释手，导致我恨不得将所有的编辑器都抛弃掉，全部采用VIM来编辑（除了WORD之外还真没什么不可以）。VIM下来编辑LaTeX文档自然不在话下，利用vim-latex插件可以轻松实现LaTeX文档的编写与编译。但是这个插件也有一定的缺陷——不能利用Magic Comments自动识别编译引擎来编译LaTeX文档，默认情况下\ll快捷键只能支持一种编译引擎！这就让经常需要在pdflatex和xelatex之间切换的我很尴尬，每次编写完文档，都需要切到终端去利用不用的命令行来实现LaTeX文档的编译工作。为了充分展现我懒惰的一面，打算采用make来编译LaTeX文档，这样在编写好Makefile之后，我只需要在终端输入make就可以实现文档的全自动编译，简直不要太美妙！ 准备工作在编写Makefile之前，请确认你的系统环境是否满足以下条件： TeX环境，可以是TeX Live或者MiKTeX； GNU make工具，在Linux下一般默认已安装（或利用apt install make安装），若在Windows下则需要安装minGW。 make命令在执行时，需要一个Makefile文件，以告诉make命令需要如何去编译和链接程序，接下来我就会编写一个针对于xelatex的Makefile文件。 Makefile规则Makefile文件的编写规则大致如下 1234target ... : prerequisites ... command ... ... target：可以是一个目标文件，也可以是一个执行文件，还可以是一个标签（伪目标） prerequisites：生成该target所依赖的文件或target command：该target要执行的命令（任意的shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件， 其生成规则定义在command中。说白一点就是说:prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会执行。 这就是Makefile的规则，也是Makefile最核心的内容。 Makefile编写123456789101112131415161718192021222324252627282930313233343536373839404142LATEX=xelatex #定义变量，指定编译引擎LATEXOPT=--shell-escape #定义变量 指定编译参数NONSTOP=--interaction=nonstopmode #定义变量 指定编译模式LATEXMK=latexmk #采用latexmk来编译latex文档LATEXMKOPT=-pdf #latexmk参数 输出pdfCONTINUOUS=-pvc #若加入-pvc选项则可以持续检测文件改动并实时显示MAIN=main #根文件名称SOURCES=$(MAIN).tex Makefile FIGURES := $(shell find figures/* movies/* -type f)all: $(MAIN).pdf#$(MAIN).pdf: $(MAIN).tex $(SOURCES) $(FIGURES)# $(LATEXMK) $(LATEXMKOPT) $(CONTINUOUS) \# -pdflatex=&quot;$(LATEX) $(LATEXOPT) $(NONSTOP) %O %S&quot; $(MAIN)$(MAIN).pdf: $(MAIN).tex $(SOURCES) $(FIGURES) $(LATEXMK) $(LATEXMKOPT) \ -pdflatex=&quot;$(LATEX) $(LATEXOPT) $(NONSTOP) %O %S&quot; $(MAIN)force: rm $(MAIN).pdf $(LATEXMK) $(LATEXMKOPT) $(CONTINUOUS) \ -pdflatex=&quot;$(LATEX) $(LATEXOPT) %O %S&quot; $(MAIN)clean: $(LATEXMK) -C $(MAIN) rm -f $(MAIN).pdfsync rm -rf *~ *.tmp rm -f *.bbl *.blg *.aux *.end *.fls *.log *.out *.fdb_latexmkonce: $(LATEXMK) $(LATEXMKOPT) -pdflatex=&quot;$(LATEX) $(LATEXOPT) %O %S&quot; $(MAIN)debug: $(LATEX) $(LATEXOPT) $(MAIN).PHONY: clean force once all make编译把上面的内容放入Makefile文件，放在LaTeX文件夹下，根据需要修改文件头部定义的变量，可以更换编译引擎，编译参数和编译模式。之后在终端下输入make即可完成编译。 若想要删除目录下生成的中间文件，则输入make clean即可。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络初探（三）：路由里的小搬运工—NAT]]></title>
    <url>%2F2018%2F09%2F07%2Fnetwork_3%2F</url>
    <content type="text"><![CDATA[现在由于我们每个人的手机、电脑、平板电脑等设备都有接入互联网的要求，可是我们家里通常只有一路网线入户，为了解决这个问题我们家里现在都会购买一台无线路由器，将这根入户网线连接到路由器的WAN口之后，便可以通过路由器上的LAN口或者WIFI接入来上网了。这时候我们查看一下我们设备的IP地址，通常为192.168.1.110这种形式，可是我们登陆ip138.com这种IP查询网站时，显示的却是类似96.46.185.33这样的IP，为什么本机显示的IP地址和IP查询网站上显示的IP不一样呢？到底是哪里出现了问题？其实这两个IP显示的都没错，这是因为我们路由器有一个小搬运工—NAT的存在，可是NAT的功能是什么？存在的意义是什么？这就要先从我们的IP地址说起。 公网IP与私有IP之前的博客里提过，IP地址是一串32比特的字符串，每8比特用一个.隔开，可表示为xx.xx.xx.xx，IP地址又有公网IP和私有IP之分，负责分配IP地址的机构预留了三块专有地址，作为私有IP地址供内部组网使用： A类：10.0.0.0～10.255.255.255/8 B类：172.16.0.0～172.31.255.255/12 C类：192.168.0.0～192.168.255.255/16 IP地址是互联网设备的身份证，也就是每个接入互联网的设备都必须具备唯一的IP地址，这个唯一的IP地址就是公网IP。具备公网IP地址的设备就像是有了具体的门牌号，我们可以直接利用公网IP来和这个设备进行通信。可是IP地址是珍贵的资源，全世界只有20亿左右的IP地址资源，若以现在的互联网发展速度，是无法为每一台设备都分配一个公网IP地址的。但是由于互联网通信协议的要求，每个接入互联网的设备必须具备唯一的公网IP，因此为了解决这个冲突，NAT就应运而生了。 什么是NATNAT(Network Address Translation，网络地址转换) ，用于将一整个内部网络通过一个公网IP连接进互联网。我们家里的路由器都具备NAT的功能，也就是将我们分配给我们的设备私有IP转换为公网IP接入互联网，从而实现只具备私有IP的设备也可以接入互联网的功能。 NAT工作过程NAT的工作开始要从用户连接上路由器之后开始说起。当用户A利用手机WIFI连接上路由器后，通过路由器内置的DHCP服务器，会自动为用户分配以下信息： IP地址：192.168.1.100 子网掩码：255.255.255.0 缺省网关：192.168.1.1 DNS服务器：192.168.1.1 用户A的手机在局域网下的IP(192.168.1.100)是唯一的，但这个IP是私有IP地址，无法直接连接互联网，可是现在用户A在手机上打开了浏览器，想要访问公网IP为2.2.2.2的服务器上的网页，于是乎一个隐藏在路由器内部的小搬运工—NAT即将登场了。 1 客户端的IP报文发送给路由器用户A的手机浏览器会填写一个包含以下信息的报文发送给路由器： 目的地：2.2.2.2 目的端口：80 发送方地址：192.168.1.100 发送方端口：1234 2 小搬运工NAT出场路由器收到了从192.168.1.100这个IP发送过来的报文，可是它不能直接将这个报文发送到互联网中，因为192.168.1.100这个IP是一个私有IP，若原封不动地发送上去的话，是无法收到2.2.2.2返回信息的。路由器的WAN是连接着互联网的，具有公有IP 1.1.1.1。于是路由器就请来了小搬运工NAT，将这个报文做了一些修改： 目的地：2.2.2.2 目的端口：80 发送方地址：1.1.1.1 发送方端口：6789 我们发现，NAT将报文中的发送方地址和端口修改成了路由器的公网IP 1.1.1.1，并且将端口号换成了6789。于是这个报文的发送方就具备了公网IP，于是便可以顺利的接收从2.2.2.2返回的消息了。 但这还没有结束，如果NAT只是简单的修改了发送方的地址和端口之后便撒手不管了，那么就算2.2.2.2返回了消息，可也只是路由器接收到了消息，路由器下面可能连接着数十个私有IP的设备，那这个消息到底应该转发给谁呢？ 3 NAT会作记录小搬运工NAT有一个好习惯，就是每次修改了发送方地址和端口之后，都会用小本把这个改动记录下来，这就是地址转换表，每次路由器呼叫NAT来进行一次地址转换，NAT都会细心的把这个改动记录下来，这个记录大致是如下形式： 公网IP 私有IP 路由器端口号 主机端口号 存活时间（秒） 2.2.2.2 192.168.1.100 6789 1234 300 3.3.3.3 192.168.1.106 12859 5896 300 4 NAT将服务器报文转发给私有IP下的设备正是因为有了地址转换表的存在，当服务器2.2.2.2将用户A的手机想要得到的报文返回时，NAT会参照地址转换表中的内容，将相应的报文转发给局域网下具有私有IP的手机，手机就可以和互联网通信啦！ 写在后面NAT的一系列动作，都是悄无声息的在路由器中完成的，甚至让很多人忘记了它的存在。这就是为什么我们在本地电脑上查看IP是私有IP，而在查询IP的网站ip138.com下查询到的却是公网IP了，全部都是NAT这个小搬运工在后面捣的鬼！可是我们要感谢NAT，要是没有它，我们的电脑可能就要被困在路由器的小黑屋中，无法和互联网中的世界联系啦！]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络地址转换</tag>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络初探（二）：自动配置上网信息的DHCP服务器]]></title>
    <url>%2F2018%2F09%2F06%2Fnetwork_2%2F</url>
    <content type="text"><![CDATA[一台计算机如果想要接入互联网，则必须要配置以下四项参数： IP地址 子网掩码 缺省网关 DNS服务器IP地址 但通常我们利用网线连接路由器的网口或者连接上无线路由器WIFI之后，也没有手动配置过这些信息，但是我们就已经可以上网了，此时我们在命令行下运行ipconfig -all(Linux下运行ifconfig)就可以看到，以上所需的信息都已经自动配置完成了，这就是DHCP服务的功劳啦！ 什么是DHCPDHCP(Dynamic Host Configuration Protocol，动态主机配置协议) 是用于内部网络自动分配IP地址的网络协议。目前我们买到的路由器都具备DHCP服务器的功能，当我们连接上路由器后，我们的电脑就会在网络中寻找DHCP服务器，而DHCP服务器接收到消息后便会响应电脑的请求，分配空闲的IP地址给我们的电脑。 DHCP工作过程1 客户端寻找DHCP服务器当客户端首次连接上路由器时，并没有任何的IP地址设定，因此它将以广播（broadcast）的方式，采用UDP协议在网络中发送DHCP Discover报文来寻找DHCP服务器（目的端口68，源端口67）。网络中所有安装了TCP/IP协议的主机都会接收到这个消息，但是只有DHCP服务器会作出响应。 2 DHCP服务器给客户端分配IP参数服务器接收到客户端发来的DHCP Discover报文，会从IP地址池中选择一个空闲的IP地址，对应的子网掩码、缺省网关、DNS服务器IP地址，以单播（unicast）的方式，采用UDP协议发送给客户端一个包含以上信息的DHCP Offer报文（目的端口67，源端口68）。 3 客户端接受IP参数DHCP客户端接收到DHCP Offer报文，选择接收到的第一个信息（若网络中存在多个DHCP服务器，则只接收第一个收到的DHCP报文），以单播方式回答一个DHCP Request报文，里面包含其所选定的DHCP服务器请求IP地址的内容。 4 IP地址分配确认DHCP服务器接收到DHCP客户端响应的DHCP Request报文后，便以单播的形式向客户端发送DHCP Ack报文，告诉客户端可以使用其提供的IP地址。客户端接收到DHCP Ack报文后，会尝试用获得的参数配置TCP/IP协议栈，同时还要尝试ARP广播请求自己IP对应的MAC地址，这个为了确定这个IP地址是唯一，不会引起IP冲突，若没有受到任何回复则可以完成配置工作。 DHCP中继代理DHCP服务器正常工作，要求和客户端处于同一个网段内，若一个公司具有数十个子网，便需要数十个DHCP服务器，这是很浪费的。这个问题可以通过DHCP中继处理来解决。即在每个网段内有一个DHCP中继代理，之后将每个中继代理和DHCP服务器处于同一网段下即可，DHCP中继代理就充当让客户端与服务器相互发现彼此的中介机构。 DHCP中继代理的工作过程如下： 接受网段内DHCP广播报文 添加[中继代理 xx.xx.xx.xx]字段 将广播转单播发给DHCP服务器 接收DHCP服务器报文并法给客户端 DHCP优化DHCP服务器能够实现上述功能，看上去已经很好了，但是仍然存在一些问题，但聪明的程序员已经想到了解决方案。 多DHCP服务共存当多个网段处于同一个广播域下，存在多个DHCP服务器时，申请IP地址时，每个DHCP服务器都会响应客户端的报文，则客户端会以第一个收到的DHCP报文中包含的IP地址作为自己的IP地址，这在很多时候是不被允许的，客户端所处的网段是需要可控的。 解决方法 可利用VLAN（虚拟局域网）技术来解决，VLAN可以隔离广播，限制不同网段之间的访问，这样就可以有效的避免DHCP广播报文在不同网段内的传播，提高了安全性。 DHCP欺诈由于DHCP就是通过DHCP报文来分配IP地址的，那么在网络下若存在一台计算机，伪造了大量的MAC地址，并利用这些地址发送DHCP报文申请IP地址，则地址资源就要被耗尽，会造成同一个网段下其他用户无法上网。 解决方法 DHCP窥探（DHCP Snooping）监视端口，当DHCP Discover信息经过的时候，会在原报文基础上增加一个安全选项[Option 82]，这里面记录了交换机名称、端口号等信息，这样若发现端口申请了多个IP，则拒绝继续分配IP地址。 ARP漏洞计算机利用ARP广播协议在网络中发现彼此的MAC地址，若计算机A在发送ARP报文时，被网络中的一台伪造MAC地址的计算机B回答了，则本应发给目标计算机C的消息全部发送给了伪造MAC地址的计算机B，计算机B看到了内容之后再将消息转发给C，这样A和C之间的消息都被B给劫持了，这就是网络流量的劫持。 解决方法 同样利用DHCP窥探，在DHCP窥探时，会生成一张绑定表，里面记录了端口号、主机MAC地址、IP地址等信息，因此若发现报文中MAC地址、IP地址与端口号有任何一个不符合都被认为是欺诈行为。]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>动态主机配置</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络初探（一）：IP地址与域名解析]]></title>
    <url>%2F2018%2F09%2F02%2Fnetwork_1%2F</url>
    <content type="text"><![CDATA[作为一个工科男，一直对互联网这个每天离不开的庞大计算机网络充满了好奇。但互联网的知识如此繁杂，想了解但却又无从下手。虽说之前也配置过家里的路由器，利用过shadowsocks进行科学上网，但是却使用只能照着教程一步一步来，对互联网还是一知半解。正好遇上了同样喜欢研究的丁博士，趁着和他请教搭建VPS服务器的同时，研究了一下计算机网络的知识，对计算机网络的搭建有了初步的了解。 IP地址当今的互联网是基于TCP/IP的思路设计的，由一些小的子网通过路由器连接起来形成一个巨大的网络。在计算机网络中，所有的设备都会被分配到一个IP地址，这个地址就像是家庭住址，互联网之间的信息传递就像是快递员送信，快递员如果不想把信送错地方，那么就需要每一个设备都有一个唯一的门牌号，例如“XX区XX街XX号”。实际的IP地址是一串32比特的数，每8比特（1字节）一组，分为四组，所以我们看到的IP地址就是这样的：192.168.0.1。 子网掩码TCP/IP是将多台计算机组成一个子网，然后再利用路由器将这些子网连接起来，IP地址是由网段号+主机号构成的，但是单看IP地址是无法确定哪些计算机在一个子网下的，于是乎一个叫子网掩码的东西就呼之欲出了。子网掩码（mask）是一串与IP地址相同长度的32比特数字，其左边一半都是1，右边一半都是0。子网掩码为1的部分表示网段号（子网下的计算机IP地址相同的部分），子网掩码为0的部分表示主机号（子网下不同的计算机IP地址不同的部分）。其表示方法有两种，例如，网段号24位，主机号8位的子网下的计算机A：192.168.0.1，可以表示为192.168.0.1/255.255.255.0，或者192.168.0.1/24。这就表示在192.168.0.1这个IP地址中192.168.0代表网段号，而.1代表主机号，于是IP为192.168.0.X（X表示1～254中的任意值）均处在同一个子网下。 值得一提的是，主机号部分比特全为0代表整个子网而不是某一台设备，例如192.168.0.0/24代表整个子网；而主机号部分比特全为1代表向子网上所有设备发送包，即广播（Broadcast，这很有用，比如ARP查询MAC地址时就需要利用广播）。 域名解析正常来讲，我们想访问网络中的任意一台计算机，只需要输入它的IP就能和它通信了。比如我们想访问百度，其实可以直接在浏览器下输入其服务器的IP123.125.115.110即可，可是几乎没人这样做，大家都是直接输入域名baidu.com来访问的，这就像我们知道每个人的名字，但是却不会记住每个人的身份证一样，与其记住一串毫无规律的数字，不如去记住一个直观的名字来的容易。但是计算机之前是靠IP地址来通信的，当我们输入baidu.com这个域名的时候，DNS服务器（Domain Name System，域名服务系统）就登场了，浏览器会去最近的DNS服务器查询[baidu.com]这个域名对应的IP地址，然后利用查询到的IP地址来登陆百度的网站，这个过程就叫域名解析。 DNS服务器同样是有IP地址的，有时候我们在Windows下配置IPv4协议时，输入首选和备用DNS服务器的地址，为的就是能够把域名正确解析到对应的IP地址。]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>IP地址</tag>
        <tag>域名解析</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人操作系统ROS学习笔记：安装与配置]]></title>
    <url>%2F2018%2F08%2F30%2Fros_install%2F</url>
    <content type="text"><![CDATA[什么是ROS？ROS (Robot Operating System, 机器人操作系统)在其官网ros.org上是这么介绍的： ROS 提供一系列程序库和工具以帮助软件开发者创建机器人应用软件。它提供了硬件抽象、设备驱动、函数库、可视化工具、消息传递和软件包管理等诸多功能。ROS遵循BSD开源许可协议。 听上去还是没有感觉到ROS的厉害之处，在我刚开始接触ROS的时候，以为ROS只是一些函数库，类似于各种应用程序开放的API一样，我只要调用相应的函数，就执行相应的功能。但是在后来的使用过程中，我才意识到ROS并不仅仅是一堆可供调用的函数而已。实际上ROS是一个机器人系统的开发框架，之所以可以称自己为“操作系统”，就是因为在这个框架之上，ROS为机器人的开发提供了一个平台，类似于一个操作系统一样，他帮你抽象好了硬件，设置好消息传递方式，让你可以更加方便快捷的实现你的想法，而不用从机器人硬件的底层开始编写程序，提高机器人系统的研发效率。 ROS能做什么？作为一种标准化机器人软件框架，利用ROS中大量的示例代码和开源程序可以轻松地完成机器人编程和控制。ROS的设计目标之一便是提高代码的复用率，ROS在运行时松散耦合，各个子功能之间相互独立，利用发布与订阅消息进行通讯，因此极易扩展，并且ROS提供了大量的监视和调试工具，方便机器人控制程序的开发。 我认为ROS也有一定的缺点，即实时性差，以我对ROS的了解，在一台普通电脑上，ROS的控制频率很难超过20Hz。当然ROS设计的目的是快速的进行机器人系统的开发，提高控制频率也并不是ROS关注的方向。 安装ROS在ROS的官方网站ros.org有详细的安装介绍，这里不再赘述，只简单介绍以下安装步骤。 ROS版本与操作系统环境ROS在Ubuntu下有着完美的支持，因此对于像我这样的新手果断选择在Ubuntu下安装ROS。不同的Ubuntu版本对应着不同版本的ROS，必须按照官网上ROS版本所支持的Ubuntu版本来进行对应安装。由于我目前的版本为Ubuntu 18.04 LTS，因此我安装的是ROS Melodic Morenia，如果你使用的是Ubuntu 16.04 LTS,则需要对应安装ROS Kinetic Kame，这两个版本的ROS都是长期支持版，推荐使用。 添加sources.list1$sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos; 设置keys1$sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 更新库1$sudo apt-get update 安装ROS完整版1$sudo apt-get install ros-melodic-desktop-full 安装rosdep12$sudo rosdep init$rosdep update 配置环境12$echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc$source ~/.bashrc 添加用于构建package的依赖1$sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential 到这里，ROS就已经安装完成，可运行如下指令来验证ROS环境是否已经配置完成： 1$printenv | grep ROS 如果显示如下内容则说明已经完成。 12345678ROS_ETC_DIR=/opt/ros/melodic/etc/rosROS_ROOT=/opt/ros/melodic/share/rosROS_MASTER_URI=http://localhost:11311ROS_VERSION=1ROS_PYTHON_VERSION=2ROS_PACKAGE_PATH=/opt/ros/melodic/shareROSLISP_PACKAGE_DIRECTORIES=ROS_DISTRO=melodic]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分布式版本控制系统使用心得]]></title>
    <url>%2F2018%2F04%2F14%2FGit_intro%2F</url>
    <content type="text"><![CDATA[写在前面Git对于经常写代码的码农同志们并不陌生，几乎是必备的工具之一。由于本人现在经常参与机器人相关的项目，需要管理大量的项目代码。之前一直在电脑保存各式各样的代码版本，时间一长根本记不住每个版本之间的区别和改动，这才入了Git的坑，在了解了Git的工作原理和基本操作之后，便一发不可收拾，真后悔没有早些了解这个神奇的工具。下面我就以我对Git的了解介绍一下什么是Git以及Git的基本使用方法。 什么是Git？Git专业的叫法是：一种分布式版本控制系统。很多人不了解分布式版本控制系统的概念，没关系，我会用一种通俗的方式解释一下。 假设你现在要开发一个程序，你已经写好了一份代码，但是这份代码有很多BUG，而且功能也很不完善，你需要不断的修改这份代码，并且需要记录每次的改动，以便万一哪次改错了可以恢复之前的版本，如果没有Git，你会怎么做？ 很简单，我可以把每次的代码文件名后面加一个版本号，假设是code1，code2，…..，code100 等等。如果我修改过100次，那么就需要在电脑上保留100份代码，怎么样？是不是很简单？而且很直观，我还可以在每次修改的代码文件里加入一些修改的描述，比如此次修改了什么什么之类的话。 似乎看上去已经很完美了，无非是多存一些文件而已嘛，怕什么？！老子硬盘4个TB！！好吧，那我们再考虑一些情况，很多时候一个项目代码需要几个人一起维护，那么怎么去协调每个人修改的部分呢？ 这个稍微有一些麻烦了，不过没关系，我们可以让其中一个人先改，改完了将文件发给第二个人改，第二个人改完了发给第三个人，以此类推。当最后一个人改完了，将这个文件标记为最终版！！额。。。假设每个人都做过100次改动，有四个人来维护这个项目，那么产生的文件个数就是400个！这还只是一个项目而已，如果很多项目呢？对这些项目版本的管理会产生极其高昂的成本。 那么我们再假设一种情况，这个项目想新加入一个功能，但是不知道这个功能好不好，如果好就加到项目中去，如果不好就还是使用原来的项目。那么我们又该怎么管理这个项目的版本呢？ 提出了以上问题，就是Git诞生的原因，最初就是为了方便管理Linux内核代码而设计的工具。在我看来，Git的用处在于可以记录每次的项目文件改动，而且可以方便的新建项目分支、合并项目分支。以我在Github上的个人简历为例，我的个人简历是用LaTeX写的，从写简历开始，每一次的修改都被Git记录了下来，而且由于我的简历分为中文版和英文版，我的项目里就新建了2个分支，一个叫en分支，是英文版简历，一个叫zh分支，是中文版简历。所有的这些在我的电脑里，仅仅有一份文件就足够了，这就是神奇的Git。 Git的安装如果你在Linux下，那么Git的使用将会是异常方便的。你只需要在终端输入 1$ sudo apt-get install git 便可以使用Git了。当然，如果你不喜欢指令行形式的Git，你也可以使用一些GUI软件，个人比较推荐GitKraken，界面很漂亮，而且跨平台。 如果你在Windows下，你可以安装Git Bash，同样利用指令行来使用Git，或者使用GitKraken之类的GUI软件来管理你的项目版本。由于个人喜好，我喜欢直接利用指令来使用Git，这对于理解Git的工作原理也有很多好处，当然你也可以更直观的利用GUI来使用，下面我介绍的都是Git指令，理解了Git指令同样可以在GUI里游刃有余的使用Git。 Git的使用其实，Git只是一个记录文件改动的工具，因此完全可以独立在电脑上使用，并不一定非要将文件存放到网上。初始化Git很简单，新建一个你需要管理的项目文件夹，假设名为proj，进入文件夹，在终端里输入： 1usr@proj $ git init 你会发现，在文件夹里出现了一个隐藏的文件夹，名为.git，别小看了这个文件夹，今后你文件夹中所有的文件改动它都一清二楚地记录在里面，Git就是利用这个文件夹中的文件来进行版本控制的。 假设你的需要版本控制的文件名叫file.doc,那么你需要在终端输入： 1usr@proj $ git add file.doc 来告诉Git，我要跟踪file.doc这个文件的版本。或者如果文件夹下有很多文件，你全部需要跟踪，你可以输入： 1usr@proj $ git add . Git同时可以利用.gitignore文件控制需要忽略的文件，这个可以查看Git教程，这里不再赘述。下面你便可以对这个文件夹的文件进行修改，修改之后，在终端输入： 1usr@proj $ git status 你会发现，你所有的文件改动，包括修改，删除、新建的文件都没有逃过Git的法眼，但是根据Git的机制，Git目前还没有将这些改动暂存，如果你认为这一时刻的状态需要被Git记录下来，那么你就需要输入： 1usr@proj $ git commit -m &quot;这是我的修改&quot; 这样你的这次改动就被Git存储了下来，今后不管到什么版本，你都可以随时恢复到这次暂存的这个版本。怎么样？很神奇吧。神奇的还在后面呢。假如你想新建项目的另一个版本，同时又不想影响当前的版本，你可以在终端输入： 1usr@proj $ git checkout -b another 这样，你会看到Git新建了一个分支，叫another分支，今后你所有的修改就会发生在another分支上，而对之前的分支（默认分支master）没有任何影响，如果你有一天想要回到之前的分支，继续之前的工作，那么简单，在终端输入： 1usr@proj $ git checkout master 这样就轻松的切换回了主分支master，你会看到所有的文件都恢复到了master分支的状态。 这就是Git最基本的用法，当然了，版本回退、分支合并等操作也可以轻松实现，你也可以将代码push到GitHub或者Gitee等代码托管网站上，你也可以将别处的改动pull到本地，或是git clone网站上的代码到本地，这些在这里不在赘述，可以参考文献《Pro Git中文版》，里面有关于Git的详细用法。 写在后面Git可以管理几乎你的任何文件，虽然不推荐使用Git来管理非文本类的文件，but anyway，这是你的自由，只要你想Git就可以做！]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux与Windows双系统搭建]]></title>
    <url>%2F2018%2F04%2F14%2Flinux_windows%2F</url>
    <content type="text"><![CDATA[写在前面这篇教程是我自己安装Linux与Windows双系统的心得。其实安装Linux与Windows双系统对于很多IT人士来讲是很普通的一件事，就像吃饭要用筷子一样，网上类似的教程也有很多，其实并不难。但是身处高校科研这么多年来，我却发现，在中国高校，Linux的普及率很低，很多机器人方向的博士甚至都没有接触过。作为一个Linux的脑残粉，我这里不但要介绍一下双系统的搭建，而且也顺便将我在Linux下所用到很多高效开发工具介绍给大家。 什么是Linux百度百科上是这么介绍Linux的：Linux是一套免费使用和自由传播的类Unix操作系统。 没错，和Windows一样，Linux就是一个操作系统。但是不同的是，Linux是免费的、自由的操作系统，而Windows是收费的。作为一名苦逼的博士，在经济条件捉急的情况下，能有一套免费的操作系统用当然很开心！但免费并不是我选择Linux的主要原因，因为毕竟Windows也可以破解嘛～在慢慢的使用过程中，我才领悟到Linux的精神在于自由，在于你可以按照一切你想要的样子去改造出属于自己的操作系统，可以裁剪、编译、修改等等，这也就是为什么目前绝大多数的嵌入式设备都采用Linux内核的原因之一。 Linux发行版其实Linux操作系统指的是采用Linux内核的操作系统。内核管理着操作系统最基本的部分，它必须配合一系列的软件，才可以构成一套方便用户使用的操作系统。很多软件公司把Linux内核与各类不同的软件打包发布，这就是所谓的Linux发行版，就像是都采用高通处理器的手机，有的叫小米、有的叫一加。 据我所知，目前最好用的发行版之一就是Ubuntu了。我也很推荐Ubuntu，不光是系统比较稳定，而且由于用户众多，出现各种问题上网一搜便能找到解决方案，的确很方便。并且由于ROS系统(Robot Operating System) 在Ubuntu下的支持最好，很多机器人方向的学生都首选Ubuntu。我现在使用的发行版是Linuxmint，它其实是基于Ubuntu的封装，只是界面风格和一些文件管理器做了一些改变，总体上和Ubuntu是没有区别的，使用体验上和Windows更类似一些。 Linux安装对于我来说，Linux上最大的问题是有一些成熟的商业软件只能在Windows上用，因此尽管我大部分时间都可以在Linux上使用，但是每个月总有那么一两次需要切换回Windows。况且Linux占用硬盘空间也很小，完全可以实现双系统，所以我一般推荐在电脑上安装Windows与Linux双系统。安装双系统其实很简单，如果不是有什么特别癖好，只需要以下几步便可以完成。 准备Linux系统启动U盘 在Windows系统下分配空间给Linux 安装Linux 配置Boot(不一定需要) 准备系统启动U盘很简单，去Linuxmint或者Ubuntu之类的Linux发行版官网，均可以找到最新的镜像安装包(.iso)，下载之后将ISO里的东西全部拷贝到一个空U盘里即可。推荐下载LTS的安装包，LTS代表long time support，长期支持。 分配空间给Linux在Windows的磁盘管理下，利用压缩卷，释放一定的可用空间给Linux，一般50G~100G就完全够用了。 安装Linux重新启动电脑，设置U盘启动，这里要注意一下BIOS是legacy还是UEFI，一般Linux都这两种启动方式都支持。只是如果是Windows 10且采用UEFI启动的话，可能需要关闭Security Boot选项，否则无法安装。 安装过程比较简单，可以手动配置空间分配大小，但是我推荐可以选择与Windows共存选项，系统会自动分配空间大小。之后按照提示一步一步安装至重启即可。 设置BOOT如果选择与Windows共存的话一般不用设置，启动后便进入GRUB界面，可以选择想启动的操作系统。但是如果是自己选择的空间分配，有可能需要在Windows下利用EasyBCD等软件设置启动分区。推荐使用GRUB启动，因为可以修改主题，使启动界面也很漂亮。 Linux下的生产力工具对于高校的科研工作者来说，我认为Linux是非常好用的，因为上面有许许多多免费开源的生产力工具，当然这些工具一般都是跨平台的，也可以在Windows下使用。但是当你熟悉了Linux下的指令行操作，你就明白Linux的魅力所在了。在这里我推荐几个我最常用的软件。 TeXLiveTexlive是由TUG维护的LaTeX发行版，在Windows和Linux下均可以使用，对于经常需要期刊投稿的高校科研工作者，我认为LaTeX是必备技能之一，完全可以摆脱Word。 Inkscape鼎鼎大名的开源矢量绘图软件，我论文里的插图几乎都是用Inkscape绘制的，不但可以直接存成svg格式，也可以转换为png等图片格式，更神奇的是，可以转换为PStricks格式供LaTeX使用，简直不要太牛逼！也有Windows版本哦～ VeuszVeusz是一个科研绘图的神奇，不但界面简单，做出的曲线图也十分漂亮，完全可以取代Origin。同样是跨平台的哦～ GitGit分布式代码管理系统，这个不用多说，管理你的代码简直就是神器，在Linux下直接命令行操作，这种快感真是爽歪歪了。 QtQt这个跨平台的C++库，可以实现一套代码，跑遍各种操作系统，而且独有的信号和槽的机制，使得程序的编写更加简单。 Mendeley牛逼的文献管理软件，完全可以取代笨重的Endnote. JabRef配合LaTeX使用的文献管理工具，跨平台 GitKraken跨平台的Git图形化管理工具，超级好用，一目了然。 这只是一小部分我使用的软件，其实在Linux下，还有很多例如Vim之类的超级好用软件，这些软件的特点通常就是入门门槛高，但是一旦会用便无法自拔，而且——免费！妈妈再也不用担心我没有破解工具了。 写在后面各个操作系统都有自己的优缺点，Linux也一样，只要适合自己便是好的操作系统，多用才是王道，任何一个操作系统只要能熟练使用，提升工作效率我认为就足够了。]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How To Writing Academic Essay | 学术论文写作总结]]></title>
    <url>%2F2017%2F10%2F18%2Facademic_essay%2F</url>
    <content type="text"><![CDATA[写在前面最近正在写学术论文，无意间拜读到了一篇国外大牛的文章，里面详细的讲解了如何去组织、撰写一篇学术论文。我把这个文章原文放在这里，也加入了一些自己的理解，希望对看到这篇博客的人能有所帮助吧。。。 Writing IntroductionsThere are many ways to introduce an academic essay or assignment. Most academic writers, however, appear to do one or more of the following in their introductions: establish the context, background and/or importance of the topic indicate a problem, controversy or a gap in the field of study define the topic or key terms state of the purpose of the essay/writing provide an overview of the coverage and/or structure of the writing Introduction的结构：背景，问题，目的，结构 Examples of phrases which are commonly employed to realise these functions are listed below. Note that there may be a certain amount of overlap between some of the categories under which the phrases are listed. Introductory sections for research dissertations, are normally much more complex than this and, as well as the elements above, may include the following: a synopsis of key literature/current state of knowledge, synopsis of methods ,lists of research questions or hypotheses to be tested, significance of the study, recognition of the limitations of the study, reasons for personal interest in the topic. Establishing the importance of the topicOne of the most significant current discussions in legal and moral philososphy is ……It is becoming increasingly difficult to ignore the …..X is the leading cause of death in western industrialised countries.X is a common disorder characterised by ……X is an important component in the climate system, and plays a key role in Y.In the new global economy, X has become a central issue for ……In the history of development economics, X has been thought of as a key factor in …….Xs are one of the most widely used groups of antibacterial agents and ……Xs are the most potent anti-infammatory agents known. Recent developments in X have heightened the need for ……In recent years, there has been an increasing interest in ……Recent developments in the field of X have led to a renewed interest in ……Recently, researchers have shown an increased interest in ……The past decade has seen the rapid development of X in many …….The past thirty years have seen increasingly rapid advances in the field of……Over the past century there has been a dramatic increase in ……One of the most important events of the 1970s was ……Traditionally, Xs have subscribed to the belief that ……X proved an important literary genre in the early Y community.The changes experienced by Xs over the past decade remain unprecedented.Xs are one of the most widely used groups of antibacterial agents and have been extensively used for decades to ……. Highlighting a problem or controversy in the field of study 研究领域有争议，有问题的写法 However, these rapid changes are having a serious effect ……However, a major problem with this kind of application is ……To date there has been little agreement on what ……More recently, literature has emerged that offers contradictory findings about …..There is increasing concern that some Xs are being disadvantaged ……Despite its long clinical success, X has a number of problems in use.Despite its safety and efficacy, X suffers from several major drawbacks:Concerns have been raised by several relevant bodies about the poor ……One of the most significant current discussions in legal and moral philososphy is ……One observer has already drawn attention to the paradox in ……In many Xs a debate is taking place between Ys and Zs concerning ……The controversy about scientific evidence for X has raged unabated for over a century.The issue of X has been a controversial and much disputed subject within the field of …….The issue has grown in importancein light of recent ……One major theoretical issue that has dominated the field for many years concerns ……One major issue in early X research concerned……. 研究领域有问题被忽视 So far, however, there has been little discussion about ……However, far too little attention has been paid to ……Most studies in X have only been carried out in a small number of areas.The research to date has tended to focus on X rather than Y.In addition, no research has been found that surveyed …….So far this method has only been applied to ……Several studies have produced estimates of X (Smith, 2002; Jones, 2003), but there is still insufficient data for …..However, there have been no controlled studies which compare differences in……The experimental data arerather controversial, and there is no general agreement about …… Focus and aimThis paper will focus on/examine/give an account of ……This paper seeks to address the following questions: …..This essay critically examines/discusses/traces ……The purpose of this paper is to review recent research into the ……This paper will review the research conducted on ……In this paper I argue that …..This chapter reviews the literature concerning the usefulness of using ……The aim of this paper is to determine/examine ……The aim of this study was to evaluate and validate …… Outline of structureThe main questions/issues addressed in this paper are: a), b and c).This paper has been divided into four parts. The first part deals with ……The essay has been organised in the following way.This paper first gives a brief overview of the recent history of X.This paper begins by …… It will then go on to ……The first section of this paper will examine ……Finally, …….Chapter 2 begins by laying out the theoretical dimensions of the research, and looks at how ……Chapter 3 describes the design, synthesis, characterization and evaluation of ……The last chapter assesses the …… Explaining KeywordsWhile a variety of definitions of the term X have been suggested, this paper will use the definition first suggested by Smith (1968) who saw it as …….Throughout this paper the term X will refer to/will be used to refer to …….In this article the acronym/abbreviation XYZ will be used. Being CriticalAs an academic writer, you are expected to be critical of the sources that you use. This essentially means questioning what you read and not necessarily agreeing with it just because the information has been published. Being critical can also mean looking for reasons why we should not just accept something as being correct or true. This can require you to identify problems with a writer’s arguments or methods, or perhaps to refer to other people’s criticisms of these. Constructive criticism goes beyond this by suggesting ways in which a piece of research or writing could be improved.…..being against is not enough. We also need to develop habits of constructive thinking. Edward de Bono Introducing questions, problems and limitationstheoryOne question that needs to be asked, however, is whether ……A serious weakness with this argument, however, is that ……One of the limitations with this explanation is that it does not explain why …..One criticism of much of the literature on X is that ……The key problem with this explanation is that ……The existing accounts fail to resolve the contradiction between X and Y.However, there is an inconsistency with this argument.Smith’s argument relies too heavily on qualitative analysis of ……It seems that Jones’ understanding of the X framework is questionable.Smith’s interpretation overlooks much of the historical research ……One major criticism of Smith’s work is that …..Many writers have challenged Jones&#39; claim on the grounds that ……. method/practiceAnother problem with this approach is that it fails totake X into account.Perhaps the most serious disadvantage of this method is that …..Difficulties arise, however, when an attempt is made to implement the policy.Nevertheless, the strategy has not escaped criticism from governments, agencies and academics.One major drawback of this approach is that ……The main limitation of biosynthetic incorporation, however, is ……However, this method of analysis has a number of limitations.However, approaches of this kind carry with them various well known limitations.All the studies reviewed so far, however, suffer from the fact that …However, all the previously mentioned methods suffer from some serious limitations/weaknesses/disadvantages/drawbacks. Identifying a study’s weaknessthe main weakness of the study is the failure to address how …….the study fails to consider the differing categories of damage that …..the research does not take into account pre-existing …… such as ……the author offers no explanation for the distinction between X and Y.Smith makes no attempt to differentiate between various different types of X.Jones fails to fully acknowledge the significance of ……the paper would appear to be over ambitious in its claimsthe author overlooks the fact that X contributes to Y.what Smith fails to do is to draw a distinction between ……another weakness is that we are given no explanantion of how …… Offering constructive suggestionsSmith&#39;s paper/Her conclusions/The study/The findings would/might have been more/much more/far more useful/convincing/interesting/persuasive/original if he/she/author had included/considered/adopted/used….. A better study would examine a large, randomly selected sample of societies with ……A much more systematic study would identify how X interacts with other variables that are believed to be linked to …… Introducing other people’s criticismsHowever, Jones (2003) points out that …..Many analysts now argue that the strategy of X has not been successful. Jones (2003), for example, argues that …..Non-government agencies are also very critical of the new policies.The X theory has been vigorously / strongly challenged in recent years by a number of writers.Smith’s analysis has been criticised by a number of writers. Jones (1993), for example, points out that ……Smith’s meta-analysis has been subjected to considerable criticism.The most important of these criticisms is that Smith failed to note that ……Jones (2003) is probably the best known critic of the X theory. He argues that .….The latter point has been devastatingly critiqued by Jones (2003).Critics have also argued that not only do social surveys provide an inaccurate measure of X, but the……Critics question the ability of poststructuralist theory to provide ……More recent arguments against X have been summarised by Smith and Jones (1982):Jones (2003) is critical of the conclusions that Smith draws from his findings. Reporting ResultsThe standrard approach is to this section of dissertations is to merely present the results, without elaborate discussion or comment. This does not mean that you do not need any text to describe data presented in tables and figures. Writers usually comment on the significant data presented in the tables and figures. This often takes the form of the location or summary statement, which identifies the table or figure and indicates its content. This may be followed by a statement or statements which point out and describe the relevant or significant data. All your tables should be numbered and given a title. More elaborate commentary on the results is normally restricted to the Discussion section. In research articles, however, authors may comment extensively on their results as they are presented, and it is not uncommon for the Results section to be combined with the Discussion section under the heading: Results and Discussion. Reference to aim/methodTo assess X, the Y questionnaire was used.To distinguish between these two possibilities, ……In order to assess Z, repeated measures of ANOVA were used.Regression analysis was used to predict the ……Changes in X and Y were compared using ……The average scores of X and Y were compared in order to ……Nine items on the questionnaire measured the extent to which ……The correlation between X and Y was tested.The first set of analyses examined the impact of ……Simple statistical analysis was used to ……A scatter diagram and a Pearson’s product moment correlation were used to determine the relationship between ……T-tests were used to analyse the relationship between …… 学术论文中一般对方法的描述都是被动语态，例如 be used to….. Location and summary statementsTable 1/Figure 1 shows/compares/presents/provides the experimental data on X/the results obtained from the preliminary analysis of X/the intercorrelations among the nine measures of X. The results obtained from the preliminary analysis of X are shown/can becompared/are presented in Table 1/Figure 1. As shown in Figure 12.1/As canbe seen from the table (above)/It canbe seen from the data in Table 12.1 that/From the graph above we can see that the X group reported significantly more Y than the other two groups. The table below illustrates/The pie chart above shows some of the main characteristics of the...../the breakdown of..... Highlighting significant data in a table/chartIt is apparent from this table that very few ……This table is quite revealing in several ways. First, unlike the other tables ……Data from this table canbe compared with the data in Table 4.6 which shows ……From the data in Figure 9, it is apparent that the length of time left between ……From this data we can see that Study 2 resulted in the lowest value of ……The histogram in Fig 1. indicates that ……What is interesting in this data is that ……In Fig.10 there is a clear trend of decreasing ……As Table III shows, there is a significant difference (t = -2.15, p = 0.03) between the two groups. Statements of resultpositiveStrong evidence of X was found when ……This result is significant at the p = 0.05 level.There was a significant positive correlation between ……There was a signifcant difference between the two conditions ……On average, Xs were shown to have ……The mean score for X was ……Interestingly, for those subjects with X, ……A positive correlation was found between X and Y. Further analysis showed that ……Further statistical tests revealed ….. negativeThere was no increase of X associated with …..There were no significant differences between ……No significant differences were found between …..No increase in X was detected.No difference greater than X was observed.The Chi-square test did not show any significant differences between ……None of these differences were statistically significant.Overall, X did not affect males and females differently in these measure Highlighting significant, interesting or surprising resultsThe most striking result to emerge from the data is that ……Interestingly, this correlation is related to …..The correlation between X and Y is interesting because ……The more surprising correlation is with the ……The single most striking observation to emerge from the data comparison was …… Reporting results from questionnaires and interviewsThe response rate was 60% at six months and 56% at 12 months.Of the study population, 90 subjects completed and returned the questionnaire.Of the initial cohort of 123 students, 66 were female and 57 male.The majority of respondents/those who responded felt that …..Over half of those surveyed reported that ……70% of those who were interviewed indicated that ……Almost two-thirds of the participants (64%) said that ……Approximately half of those surveyed did not comment on ……A small number of those interviewed suggested that ……Only a small number of respondents indicated that ……Of the 148 patients who completed the questionnaire, just over half indicated that …….A minority of participants (17%) indicated ……In response to Question 1, most of those surveyed indicated that ……The overall response to this question was very positive.When the subject were asked ……, the majority commented that …..Other responses to this question included ……The overall response to this question was poor. Transition statementsTurning now to the experimental evidence on ……Comparing the two results, it can be seen that ……A comparison of the two results reveals ……If we now turn to ……]]></content>
      <categories>
        <category>学术天地</category>
      </categories>
      <tags>
        <tag>学术写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How To Writing Academic Essay | 学术论文词汇总结]]></title>
    <url>%2F2017%2F10%2F18%2Facademic_essay_words%2F</url>
    <content type="text"><![CDATA[介词转折关系 然而 However; Nevertheless 尽管 Despite; 递进关系 更进一步地 Moreover; Furthermore; In addition; 尤其地 Particularly; 同时 whilst; 因果关系 因此 Consequently; Therefore 由于 Due to 过渡与总结 到目前为止 By now; To date; More recently; as-of-yet; So far; 大体上来说 by and large; 短语 展示、呈现 be present; be depicted;be described; be displayed ; indicate that... ; 利用 use; leverage; 缺点、劣势 disadvantages; drawbacks; 关注 drawn attention to; concerning; concern about; conducted on; 根据、依据 according to; in light of; 广泛使用 extensively used; widely used 被简化为 be abbreviated to; 上述的、上面提及的 abovementioned; aforementioned; 期望的 desired; expected; 描绘、关注…问题 focus on; examine; discuss; trace; take ... into account; 忽视 overlook; ignore; 意义、重要性 significance; 有意义的，相关的 relevant; significant; 强烈地 vigorously; strongly 遭受 be subjected to; suffer from 仅仅 merely; barely; 详尽的 elaborate; accommodate 适应 denote 表示 proof-of-concept 概念验证 has raged unabated for over a century 持续了一个多世纪 via 通过 adhere to 坚持、追随、秉承 in either/this scenario 在 其他/这种 情景 heuristically 启发式地、试探性地 an account of 一份…的说明 recent research 最近的研究 limitations 局限性 rely too heavily on…. 过于依赖 questionable 可疑的，有问题的 challenged Jones’ claim on the grounds 对Jone的主张提出质疑 pre-existing 先已存在的 systematic study 系统研究 interacts with 相互作用 point out 指出 assess 评估、评价 专业词汇three-phase dc-brushless motor 三相直流无刷电机 resolver 旋转变压器 three-bladed nylon propeller 三叶的尼龙桨 pulsewidth-modulated (PWM) 脉宽调制 4096 counts per revolution 每转4096线 revolution 转速 advance speed 推进速度、前进速度 four quadrant nonlinear function 四象限非线性方程 wake fraction number 伴流系数(0.1~0.4) affine thruster model 仿射的推进器模型 lump parameter of various constants 集中参数 cavitation 空化现象]]></content>
      <categories>
        <category>学术天地</category>
      </categories>
      <tags>
        <tag>学术词汇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F10%2F17%2Fhexo_intro%2F</url>
    <content type="text"><![CDATA[写在前面折腾了整整一周，终于搭建好了我的个人博客。感谢互联网的发达让信息共享如此方便，让我仅仅用了不到三天就弄好了自己的独立博客。在这篇博客的最后我也会列出非常值得参考的几篇博客教程与网站供大家学习。 准备工作在打造个人博客之前，需要进行以下准备工作： Github账号注册 这是为了在Github上部署你的博客，相当于申请了一个服务器，空间免费。 七牛账号注册 由于Github上的免费空间有限，一些大图片保存在Github上会占用空间，七牛上提供免费的10G空间，可以存储一些图片视频之类文件。 申请一个域名 有了独立域名，逼格才能满满~我是在腾讯云申请的域名，一年10多块钱。 有了这些，就可以开始打造自己的独立博客了，那么首先我们在电脑上安装一些软件。 软件安装我是在Windows下使用Github的，所以需要安装以下软件： Node.js 一个基于 Chrome V8 引擎的JavaScript 运行时 Git 用来部署Git 有了这两个软件，其实就已经可以开始接下来的部署Hexo了。不过由于Hexo是用Markdown语言来写博客的，为了方便起见，我推荐一个Markdown的编辑器： Typora 超级好用，界面还美观 Visual Studio Code 微软推出的代码编辑器，因为配置Hexo时候需要修改一些xml文件，感觉这个编辑器挺好用的 好啦，软件安装完毕，那么我们就开始配置域名吧~ 域名配置域名申请完之后要设置域名解析，设置如下： 域名的DNS要设置为：f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net 主机记录 记录类型 记录值 @ A 192.30.252.153 @ A 192.30.252.154 www CNAME githubname.github.io 其中githubname为自己的github账号名称，这样你自己申请域名就能够解析到你的Github Pages上了。 配置Github我们要配置SSH keys将本地的Git项目与远程Github建立联系 检查电脑上现有的SSH keys: 1$ cd ~/. ssh 检查本机SSH keys 如果提示：No such file or directory 说明为第一次使用Git 生成新的SSH key： 1$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 之后回车，然后输密码，以后提交项目的时候就输入这个密码。 将本机的SSH key添加到Github上，在id_rsa.pub文件中。登陆Github-&gt;Accout Settings-&gt;SSH Public keys-&gt;add another public keys，把文件中的密钥粘贴到里面，点击add key。 测试一下，输入以下命令 1$ ssh -T git@github.com 设置用户信息： 12$ git config --global user.name &quot;cnfeat&quot;//用户名$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱 在Github上创建一个新仓库，名字后缀固定，比如我的Github账号为thinkexist1989，那么仓库的名字就要设置为thinkexist1989.github.io. 搭建Hexo框架Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。 安装Hexo打开Git Bash 1$ npm install -g hexo 部署Hexo新建一个文件夹，然后在这个文件夹中运行Git Bash 1$ hexo init Hexo随后会在这个文件夹下生成网站所需要的所有文件，之后可以本地部署并查看生成的网页 12$ hexo g$ hexo s -p 5000 然后在浏览器输入localhost:5000便可以查看网页了(因为我安了福昕PDF，占用了4000端口)，建议使用Chrome浏览器 安装NeXT主题参考中的NeXT主题官方网站中有更加详细的安装与配置说明，在这里只简单介绍一下安装步骤： 中有更加详细的安装与配置说明，在这里只简单介绍一下安装步骤： 下载主题在Hexo文件夹下运行Git Bash： 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开Hexo根目录下的_config.xml文件，找到theme字段，将其值改成next 1theme:next 这样便配置好了NeXT主题，NeXT具有丰富的功能与样式配置，具体的可以参考[NeXT主题官方网站][NeXT主题官方网站] 发布博客博客需要用Markdown语言编写，写好之后，将博客放到source-&gt;_post文件夹下，这里就是存放所有博客文件的地方，之后执行如下命令： 12$ hexo clean$ hexo g -d 执行完上述语句之后，GIthub上便已经部署好了，但是还有一个重要的步骤：登陆Github，进入博客的仓库，新建一个文件，重命名为CNAME，内容填写为你自己的域名，比如www.yluoblog.cn。之后保存。这样在网页中输入自己的域名，才能够解析到Github Pages。 写在后面从无到有，经过自己的一顿折腾，在网页中输入自己的域名可以登录到博客的那一刻，心情真的是很激动！我之后也会将我所学到一些东西在博客中分享出来！学习是一个快乐的过程，希望每个人都能从学习中找到属于自己的快乐！ 参考 如何搭建一个独立博客——简明Github Pages与Hexo教程 如何使用10个小时搭建出个人域名而又Geek的独立博客？ Hexo官方网站 NeXT主题官方网站]]></content>
      <categories>
        <category>技术探索</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
